<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Number Theory Utils: include/nut/dirichlet.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_awesome_sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="/Number-Theory-Utils/index.html">Number Theory Utils</a><span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dirichlet_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dirichlet.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.2.0 </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Dirichlet Hyperbola based functions for computing sums of multiplicative functions at a single value quickly</p>
<p>For a function f defined over the natural numbers, we say f is multiplicative if f(ab) = f(a)f(b) whenever a and b are coprime (have gcd 1). There are many functions in number theory that satisfy this condition, with one of the most well known being euler's phi function.</p>
<p>A brief list of common multiplicative functions is: (see here <a href="https://en.wikipedia.org/wiki/Multiplicative_function">https://en.wikipedia.org/wiki/Multiplicative_function</a>) The dirichlet convolution identity (explained later): I(n) = 1 if n == 1; 0 otherwise Sometimes written epsilon(n), (very confusingly) u(n), or delta(n, 0) (since it is just a kroneker delta function of course) The constant function: u(n) = 1 Sometimes written 1(n) The identity function: N(n) = n Sometimes written Id(n) or id(n) The power functions: N_k(n) = n**k Sometimes written Id_k(n) The divisor count function: d(n) = #{k | n} (the number of natural numbers including 1 and n which divide n) The generalized divisor functions: d_k(n) = # k-tuples ks of natural numbers such that ks multiplies out to n The divisor power sum functions: sigma_a(n) = sum(k | n, k**a) (note that a can be any real number) The mobius function: mu(n) = 0 if n is not squarefree; (-1)**Omega(n) otherwise, where Omega(n) is the number of prime factors of n with multiplicity Euler's totient function: phi(n) = #{k = 1 ... n : (k coprime n)} Any constant raised to the power of Omega(n) or omega(n) (the number of prime factors of n counted with and without multiplicity respectively) The number of non-isomorphic abelian groups of order n: a(n) The Ramanujan tau function: tau(n) The unitary divisor power sums: sigma_a^*(n) = sum(d | n where (d coprime n/d), d**a) All dirichlet characters, including the legendre symbol (n/p) for fixed p and gcd(n, m) for fixed m</p>
<p>Some of these are fully multiplicative, meaning not only do they satisfy f(ab) = f(a)f(b) for a, b coprime, but they satisfy it for all a, b. In particular, I, u, N, and N_k are fully multiplicative.</p>
<p>We often want to find the sum of a multiplicative function, often denoted by a capital version, for instance phi and Phi, f and F (for a general function, etc). We also often want to be able to analyze multiplicative functions in terms of simpler functions.</p>
<p>Multiplicative functions are fully determined by their values at prime powers, which often leads to efficient sieve based approaches to calculating them. This header provides some functions for doing this, the nut_euler_sieve family of functions, although these are mainly intended as low level subroutines for the upcoming Dirichlet Hyperbola algorithm.</p>
<p>However, if we only want to compute the sum of a multiplicative function up to some value n, sieve based methods will basically be O(nlogn), which seems very bad considering how structured multiplicative functions are.</p>
<p>Indeed, we can often do better, in particular when we want to find the sum H(n) of some multiplicative function h(n) defined as h = f &lt;*&gt; g where &lt;*&gt; denotes Dirichlet convolution. What is Dirichlet convolution? It is an operation for combining functions, similar to ordinary multiplication, division, addition, subtraction, composition, and so on. It is defined as (f &lt;*&gt; g)(n) = sum(k | n, f(k)g(n/k)). This is mostly useful because when f and g are multiplicative f &lt;*&gt; g will be as well, and it lets us build up more complicated functions in terms of simpler ones. (see here <a href="https://en.wikipedia.org/wiki/Dirichlet_convolution">https://en.wikipedia.org/wiki/Dirichlet_convolution</a>)</p>
<p>Obviously, not all operations on multiplicative functions will produce multiplicative functions. For example, if f is multiplicative, 2f is not, so multiplicative functions are not closed under scalar multiplication, and thus they are not closed under addition. They are closed under multiplication and dirichlet convolution though.</p>
<p>The Dirichlet Hyperbola algorithm lets us rewrite H(x) = sum(n &lt;= x, h(n)) in terms of F and G as well as f and g, but crucially it lets us evaluate them at fewer values.</p>
<p>In particular, sum(n &lt;= x, (f &lt;*&gt; g)(n)) = sum(n &lt;= x, ab = n, f(a)g(b)) = sum(ab &lt;= x, f(a)g(b)) = sum(a &lt;= A, b &lt;= x/a, f(a)g(b)) + sum(b &lt;= B, a &lt;= x/b, f(a)g(b)) - sum(a &lt;= A, b &lt;= B, f(a)g(b)) = sum(a &lt;= A, f(a)G(x/a)) + sum(b &lt;= B, F(x/b)g(b)) - F(A)G(B) where AB = x. (see here <a href="https://gbroxey.github.io/blog/2023/04/30/mult-sum-1.html">https://gbroxey.github.io/blog/2023/04/30/mult-sum-1.html</a>) (see here <a href="https://angyansheng.github.io/blog/dirichlet-hyperbola-method">https://angyansheng.github.io/blog/dirichlet-hyperbola-method</a>) (you may also find this instructive <a href="https://en.wikipedia.org/wiki/Marginal_distribution">https://en.wikipedia.org/wiki/Marginal_distribution</a>) To accomplish this rearrangement, we first expanded (f &lt;*&gt; g) using the definition of dirichlet convolution. Then, we interpreted the sum both as an a-indexed sum and as a b-indexed sum. We could find the sum either way, but considering both sets us up to cut the work down quadratically. These two ways of interpreting the sum are EXACTLY EQUIVALENT to the trick of transforming an integral of f(x) in terms of x into an integral of f_inverse(y) in terms of y. For integrals, it is common to just pick whichever interpretation is easier, but for our sum, we benefit from realizing that if we sum f(a)g(b) for (a &lt;= A, b &lt;= x/a) and then separately for (b &lt;= B, a &lt;= x/b), then we double count the rectangular region (a &lt;= A, b &lt;= B). But more importantly, if we pick A = B = sqrt(x), then we've turned one sum over (f &lt;*&gt; g) for n from 1 to x, which we could accomplish in about O(xlogx), into two sums over f*G and F*g for n from 1 to sqrt(x), which we can sometimes accomplish in O(sqrt(x)).</p>
<p>There is a big catch though, we now need to know values of F and G as well as f and g. Wonderfully though, we only need to know F(x/n) and G(x/n) for integral values of n, and floor(x/n) has at most 2sqrt(x) distinct values. That, arguably, is the real magic, since it lets us store only O(sqrt(x)) values of F and G. When we want to compute only H(x), this is fine, but when we want to repeatedly compute the table of values of H(x/n) for integral values of n, it is often better to make A larger than B, eg A = x**(2/3) and B = x**(1/3). </p>

<p class="definition">Definition in file <a class="el" href="dirichlet_8h_source.html">dirichlet.h</a>.</p>
</div>
<p><a href="dirichlet_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnut__Diri.html">nut_Diri</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to hold values of some multiplicative function.  <a href="structnut__Diri.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2db407b902fdb86d740d579e445223c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#a2db407b902fdb86d740d579e445223c8">nut_dirichlet_D</a> (uint64_t max, uint64_t m)</td></tr>
<tr class="memdesc:a2db407b902fdb86d740d579e445223c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of the divisor count function d from 1 to max.  <a href="dirichlet_8h.html#a2db407b902fdb86d740d579e445223c8">More...</a><br /></td></tr>
<tr class="separator:a2db407b902fdb86d740d579e445223c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2f0dc86d8486a52cc05f57a42ec453"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#aff2f0dc86d8486a52cc05f57a42ec453">nut_euler_sieve_conv_u</a> (int64_t n, int64_t m, const int64_t f_vals[static n+1], int64_t f_conv_u_vals[restrict static n+1])</td></tr>
<tr class="memdesc:aff2f0dc86d8486a52cc05f57a42ec453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a table of values of a multiplicative function f, compute (f &lt;*&gt; u)(x) for all x from 1 to n See <a class="el" href="dirichlet_8h.html#aff2f0dc86d8486a52cc05f57a42ec453">nut_euler_sieve_conv_u</a> for more info}.  <a href="dirichlet_8h.html#aff2f0dc86d8486a52cc05f57a42ec453">More...</a><br /></td></tr>
<tr class="separator:aff2f0dc86d8486a52cc05f57a42ec453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74180d3515220729cf659328a49154c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#a74180d3515220729cf659328a49154c9">nut_euler_sieve_conv_N</a> (int64_t n, int64_t m, const int64_t f_vals[static n+1], int64_t f_conv_N_vals[restrict static n+1])</td></tr>
<tr class="memdesc:a74180d3515220729cf659328a49154c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a table of values of a multiplicative function f, compute (f &lt;*&gt; N)(x) for all x from 1 to n See <a class="el" href="dirichlet_8h.html#aff2f0dc86d8486a52cc05f57a42ec453">nut_euler_sieve_conv_u</a> for more info}.  <a href="dirichlet_8h.html#a74180d3515220729cf659328a49154c9">More...</a><br /></td></tr>
<tr class="separator:a74180d3515220729cf659328a49154c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f9358d979df1a3063c09cfbe19d93d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#a52f9358d979df1a3063c09cfbe19d93d">nut_euler_sieve_conv</a> (int64_t n, int64_t m, const int64_t f_vals[static n+1], const int64_t g_vals[static n+1], int64_t f_conv_g_vals[restrict static n+1])</td></tr>
<tr class="memdesc:a52f9358d979df1a3063c09cfbe19d93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given tables of values of multiplicative functions f and g, compute (f &lt;*&gt; g)(x) for all x from 1 to n This uses Euler's sieve, a variant of the sieve of Eratosthenes that only marks off each multiple once.  <a href="dirichlet_8h.html#a52f9358d979df1a3063c09cfbe19d93d">More...</a><br /></td></tr>
<tr class="separator:a52f9358d979df1a3063c09cfbe19d93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f69060eec4fdf127316bd2998e356d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *self, int64_t x, int64_t y)</td></tr>
<tr class="memdesc:a4f69060eec4fdf127316bd2998e356d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate internal buffers for a diri table self-&gt;buf will have f(0) through f(y) at indicies 0 through y, and then f(x/1) through f(x/(yinv - 1)) at indicies y + 1 through y + yinv - 1.  <a href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">More...</a><br /></td></tr>
<tr class="separator:a4f69060eec4fdf127316bd2998e356d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b561a6ee692252d8d17e479f14144e8"><td class="memItemLeft" align="right" valign="top"><a id="a4b561a6ee692252d8d17e479f14144e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#a4b561a6ee692252d8d17e479f14144e8">nut_Diri_copy</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict dest, const <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict src)</td></tr>
<tr class="memdesc:a4b561a6ee692252d8d17e479f14144e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the values from one diri table to another, which must be initialized. <br /></td></tr>
<tr class="separator:a4b561a6ee692252d8d17e479f14144e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11c54899255356be156c2246edb24d2"><td class="memItemLeft" align="right" valign="top"><a id="ad11c54899255356be156c2246edb24d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#ad11c54899255356be156c2246edb24d2">nut_Diri_destroy</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *self)</td></tr>
<tr class="memdesc:ad11c54899255356be156c2246edb24d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate internal buffers for a diri table. <br /></td></tr>
<tr class="separator:ad11c54899255356be156c2246edb24d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72111f9468ba6240298b9265dc3f0ddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#a72111f9468ba6240298b9265dc3f0ddd">nut_Diri_compute_I</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *self)</td></tr>
<tr class="memdesc:a72111f9468ba6240298b9265dc3f0ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just memset's the dense part, then sets index 1 and y + 1 through y + yinv - 1 to 1 (remember the sparse indicies are sums)  <a href="dirichlet_8h.html#a72111f9468ba6240298b9265dc3f0ddd">More...</a><br /></td></tr>
<tr class="separator:a72111f9468ba6240298b9265dc3f0ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd834fdb77cadd1e63b935220295e47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#a8bd834fdb77cadd1e63b935220295e47">nut_Diri_compute_u</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *self, int64_t m)</td></tr>
<tr class="memdesc:a8bd834fdb77cadd1e63b935220295e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value table for the unit function u(n) = 1 Fills the dense part of the table with 1s, and computes the sparse entries with table[y + k] = U(x/k) = x/k.  <a href="dirichlet_8h.html#a8bd834fdb77cadd1e63b935220295e47">More...</a><br /></td></tr>
<tr class="separator:a8bd834fdb77cadd1e63b935220295e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3a0c29121da13a74cec34c49d77d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#aef3a0c29121da13a74cec34c49d77d4b">nut_Diri_compute_N</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *self, int64_t m)</td></tr>
<tr class="memdesc:aef3a0c29121da13a74cec34c49d77d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value table for the identity function N(n) = n Fills the dense part of the table with increasing numbers, and computes the sparse entries with table[y + k] = sum_N(v = x/k) = v*(v+1)/2.  <a href="dirichlet_8h.html#aef3a0c29121da13a74cec34c49d77d4b">More...</a><br /></td></tr>
<tr class="separator:aef3a0c29121da13a74cec34c49d77d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de369be5cae92e31d9f073144b6645d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#a1de369be5cae92e31d9f073144b6645d">nut_Diri_compute_mertens</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict self, int64_t m, const uint8_t mobius[restrict static self-&gt;y/4+1])</td></tr>
<tr class="memdesc:a1de369be5cae92e31d9f073144b6645d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value table for the mobius function mu(n) (whose sum is called the Mertens function) Requires both an initialized <a class="el" href="structnut__Diri.html" title="Wrapper to hold values of some multiplicative function.">nut_Diri</a> from <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a> and a packed table of mobius values from <a class="el" href="sieves_8h.html#aed3a407903d4975ef6e95c867ed3c42e">nut_sieve_mobius</a>.  <a href="dirichlet_8h.html#a1de369be5cae92e31d9f073144b6645d">More...</a><br /></td></tr>
<tr class="separator:a1de369be5cae92e31d9f073144b6645d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa27d52f1bde28bec89dbe3ee2eb1c11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#aaa27d52f1bde28bec89dbe3ee2eb1c11">nut_Diri_compute_dk</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict self, uint64_t k, int64_t m, <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict f_tbl, <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict g_tbl)</td></tr>
<tr class="memdesc:aaa27d52f1bde28bec89dbe3ee2eb1c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value table for the kth generalized divisor function dk(n) dk(n) = da(n) &lt;*&gt; db(n) whenever a + b = k.  <a href="dirichlet_8h.html#aaa27d52f1bde28bec89dbe3ee2eb1c11">More...</a><br /></td></tr>
<tr class="separator:aaa27d52f1bde28bec89dbe3ee2eb1c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd2807d0e18d42c365be9f634633f00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#adbd2807d0e18d42c365be9f634633f00">nut_Diri_compute_Nk</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict self, uint64_t k, int64_t m)</td></tr>
<tr class="memdesc:adbd2807d0e18d42c365be9f634633f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value table for the kth power function N^k(n) N^k(n) = n^k, so we can find the sums using <a href="https://en.wikipedia.org/wiki/Faulhaber%27s_formula">https://en.wikipedia.org/wiki/Faulhaber%27s_formula</a> (we actually do this by taking a lower triangular matrix of pascal's triangle and inverting it) This is one of the core components needed to compute the Dirichlet sum table for f where f(p) is a polynomial, the other one being <a href="https://en.wikipedia.org/wiki/Jordan%27s_totient_function">https://en.wikipedia.org/wiki/Jordan%27s_totient_function</a>.  <a href="dirichlet_8h.html#adbd2807d0e18d42c365be9f634633f00">More...</a><br /></td></tr>
<tr class="separator:adbd2807d0e18d42c365be9f634633f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3257dcff1b06c34b128c156572a4dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#abc3257dcff1b06c34b128c156572a4dd">nut_Diri_compute_conv_u</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict self, int64_t m, const <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict f_tbl)</td></tr>
<tr class="memdesc:abc3257dcff1b06c34b128c156572a4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value table for h = f &lt;*&gt; u, the dirichlet convolution of f and u (the unit function u(n) = 1), given the value table for f See <a class="el" href="dirichlet_8h.html#ac129473cb990ee5563de30608d75d253">nut_Diri_compute_conv</a> for details, this is just that function but with several specializations due to u being very simple.  <a href="dirichlet_8h.html#abc3257dcff1b06c34b128c156572a4dd">More...</a><br /></td></tr>
<tr class="separator:abc3257dcff1b06c34b128c156572a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54146e9f9dea0bbee06a22395833093a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#a54146e9f9dea0bbee06a22395833093a">nut_Diri_compute_conv_N</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict self, int64_t m, const <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict f_tbl)</td></tr>
<tr class="memdesc:a54146e9f9dea0bbee06a22395833093a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value table for h = f &lt;*&gt; N, the dirichlet convolution of f and N (the identity function N(n) = n), given the value table for f See <a class="el" href="dirichlet_8h.html#ac129473cb990ee5563de30608d75d253">nut_Diri_compute_conv</a> for details, this is just that function but with several specializations due to N being very simple.  <a href="dirichlet_8h.html#a54146e9f9dea0bbee06a22395833093a">More...</a><br /></td></tr>
<tr class="separator:a54146e9f9dea0bbee06a22395833093a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac129473cb990ee5563de30608d75d253"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#ac129473cb990ee5563de30608d75d253">nut_Diri_compute_conv</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict self, int64_t m, const <a class="el" href="structnut__Diri.html">nut_Diri</a> *f_tbl, const <a class="el" href="structnut__Diri.html">nut_Diri</a> *g_tbl)</td></tr>
<tr class="memdesc:ac129473cb990ee5563de30608d75d253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value table for h = f &lt;*&gt; g, the dirichlet convolution of f and g, given value tables for the operands self must have been initialized using <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a>, and in particular the lengths and cutoffs for self, f_tbl, and g_tbl must be set and match This uses a sieve to compute h(1) through h(y), then uses dirichlet's hyperbola formula to compute H(x/1) through H(x/(yinv-1)) If one of the operands is a simple standard multiplicative function like the unit function u or the mobius function mu, then try to use a specialized function from this library and use that instead.  <a href="dirichlet_8h.html#ac129473cb990ee5563de30608d75d253">More...</a><br /></td></tr>
<tr class="separator:ac129473cb990ee5563de30608d75d253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa888abb382e18f4b8a1cc645434d9c03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#aa888abb382e18f4b8a1cc645434d9c03">nut_Diri_convdiv</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict self, int64_t m, const <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict f_tbl, const <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict g_tbl)</td></tr>
<tr class="memdesc:aa888abb382e18f4b8a1cc645434d9c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value table for h such that f = g &lt;*&gt; h, aka h = f &lt;/&gt; g where the division is in terms of dirichlet convolution self must have been initialized using <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a>, and in particular the lengths and cutoffs for self, f_tbl, and g_tbl must be set and match This is the inverse of &lt;*&gt;, in the sense that if h = f &lt;/&gt; g, then h &lt;*&gt; g = f.  <a href="dirichlet_8h.html#aa888abb382e18f4b8a1cc645434d9c03">More...</a><br /></td></tr>
<tr class="separator:aa888abb382e18f4b8a1cc645434d9c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2db407b902fdb86d740d579e445223c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db407b902fdb86d740d579e445223c8">&#9670;&nbsp;</a></span>nut_dirichlet_D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> uint64_t nut_dirichlet_D </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the sum of the divisor count function d from 1 to max. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of range to compute sum for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce result by, or 0 to skip reducing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum d(1) + ... + d(max) </dd></dl>

</div>
</div>
<a id="aff2f0dc86d8486a52cc05f57a42ec453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2f0dc86d8486a52cc05f57a42ec453">&#9670;&nbsp;</a></span>nut_euler_sieve_conv_u()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_euler_sieve_conv_u </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>f_vals</em>[static n+1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>f_conv_u_vals</em>[restrict static n+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a table of values of a multiplicative function f, compute (f &lt;*&gt; u)(x) for all x from 1 to n See <a class="el" href="dirichlet_8h.html#aff2f0dc86d8486a52cc05f57a42ec453">nut_euler_sieve_conv_u</a> for more info}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>inclusive upper bound of range to compute f &lt;*&gt; u over </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_vals</td><td>table of values for f </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_conv_u_vals</td><td>table to store values of f &lt;*&gt; u in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on allocation failure </dd></dl>

</div>
</div>
<a id="a74180d3515220729cf659328a49154c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74180d3515220729cf659328a49154c9">&#9670;&nbsp;</a></span>nut_euler_sieve_conv_N()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_euler_sieve_conv_N </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>f_vals</em>[static n+1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>f_conv_N_vals</em>[restrict static n+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a table of values of a multiplicative function f, compute (f &lt;*&gt; N)(x) for all x from 1 to n See <a class="el" href="dirichlet_8h.html#aff2f0dc86d8486a52cc05f57a42ec453">nut_euler_sieve_conv_u</a> for more info}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>inclusive upper bound of range to compute f &lt;*&gt; N over </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_vals</td><td>table of values for f </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_conv_N_vals</td><td>table to store values of f &lt;*&gt; N in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on allocation failure </dd></dl>

</div>
</div>
<a id="a52f9358d979df1a3063c09cfbe19d93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f9358d979df1a3063c09cfbe19d93d">&#9670;&nbsp;</a></span>nut_euler_sieve_conv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_euler_sieve_conv </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>f_vals</em>[static n+1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>g_vals</em>[static n+1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>f_conv_g_vals</em>[restrict static n+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given tables of values of multiplicative functions f and g, compute (f &lt;*&gt; g)(x) for all x from 1 to n This uses Euler's sieve, a variant of the sieve of Eratosthenes that only marks off each multiple once. </p>
<p>This generally has worse performance than the sieve of Eratosthenes, but some preliminary tests showed that Eratosthenes is only about 14% faster in release mode than Euler, so currently only Euler's sieve is implemented. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>inclusive upper bound of range to compute f &lt;*&gt; g over </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_vals</td><td>table of values for f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g_vals</td><td>table of values for f </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_conv_g_vals</td><td>table to store values of f &lt;*&gt; g in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on allocation failure </dd></dl>

</div>
</div>
<a id="a4f69060eec4fdf127316bd2998e356d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f69060eec4fdf127316bd2998e356d4">&#9670;&nbsp;</a></span>nut_Diri_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_Diri_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate internal buffers for a diri table self-&gt;buf will have f(0) through f(y) at indicies 0 through y, and then f(x/1) through f(x/(yinv - 1)) at indicies y + 1 through y + yinv - 1. </p>
<p>The first two indicies, f(0) and f(1), are basically dummies though: f(0) should never be relied on, and f(1) should always be 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>inclusive upper bound of the domain of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>inclusive upper bound of the dense portion of the domain of interest. Will be increased to sqrt(x) if needed, so 0 can be used to explicitly signal you want that behavior </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on allocation failure </dd></dl>

</div>
</div>
<a id="a72111f9468ba6240298b9265dc3f0ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72111f9468ba6240298b9265dc3f0ddd">&#9670;&nbsp;</a></span>nut_Diri_compute_I()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nut_Diri_compute_I </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Just memset's the dense part, then sets index 1 and y + 1 through y + yinv - 1 to 1 (remember the sparse indicies are sums) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, and take the bounds from. Must be initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bd834fdb77cadd1e63b935220295e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd834fdb77cadd1e63b935220295e47">&#9670;&nbsp;</a></span>nut_Diri_compute_u()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nut_Diri_compute_u </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value table for the unit function u(n) = 1 Fills the dense part of the table with 1s, and computes the sparse entries with table[y + k] = U(x/k) = x/k. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, and take the bounds from. Must be initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef3a0c29121da13a74cec34c49d77d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3a0c29121da13a74cec34c49d77d4b">&#9670;&nbsp;</a></span>nut_Diri_compute_N()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nut_Diri_compute_N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value table for the identity function N(n) = n Fills the dense part of the table with increasing numbers, and computes the sparse entries with table[y + k] = sum_N(v = x/k) = v*(v+1)/2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, and take the bounds from. Must be initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1de369be5cae92e31d9f073144b6645d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de369be5cae92e31d9f073144b6645d">&#9670;&nbsp;</a></span>nut_Diri_compute_mertens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nut_Diri_compute_mertens </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mobius</em>[restrict static self-&gt;y/4+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value table for the mobius function mu(n) (whose sum is called the Mertens function) Requires both an initialized <a class="el" href="structnut__Diri.html" title="Wrapper to hold values of some multiplicative function.">nut_Diri</a> from <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a> and a packed table of mobius values from <a class="el" href="sieves_8h.html#aed3a407903d4975ef6e95c867ed3c42e">nut_sieve_mobius</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, and take the bounds from. Must be initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mobius</td><td>packed table of mobius values, from <a class="el" href="sieves_8h.html#aed3a407903d4975ef6e95c867ed3c42e">nut_sieve_mobius</a> (with upper bound self-&gt;y). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa27d52f1bde28bec89dbe3ee2eb1c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa27d52f1bde28bec89dbe3ee2eb1c11">&#9670;&nbsp;</a></span>nut_Diri_compute_dk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_Diri_compute_dk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>f_tbl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>g_tbl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value table for the kth generalized divisor function dk(n) dk(n) = da(n) &lt;*&gt; db(n) whenever a + b = k. </p>
<p>This function uses binary exponentiation to compute dk in only log(k) convolutions. However, if all dk's are needed, calling <a class="el" href="dirichlet_8h.html#abc3257dcff1b06c34b128c156572a4dd">nut_Diri_compute_conv_u</a> is more efficient </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, initialized by <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a>. self-&gt;y, self-&gt;x, and self-&gt;yinv must be set and consistent with the inputs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>k, ie which generalized divisor function to compute. dk is u &lt;*&gt; u &lt;*&gt; ... &lt;*&gt; u with k u's </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce the result by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f_tbl,g_tbl</td><td>temporary tables for scratch work, initialized by <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a>, fields y, x, and yinv must be set Will still have scratch data stored on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbd2807d0e18d42c365be9f634633f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd2807d0e18d42c365be9f634633f00">&#9670;&nbsp;</a></span>nut_Diri_compute_Nk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_Diri_compute_Nk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value table for the kth power function N^k(n) N^k(n) = n^k, so we can find the sums using <a href="https://en.wikipedia.org/wiki/Faulhaber%27s_formula">https://en.wikipedia.org/wiki/Faulhaber%27s_formula</a> (we actually do this by taking a lower triangular matrix of pascal's triangle and inverting it) This is one of the core components needed to compute the Dirichlet sum table for f where f(p) is a polynomial, the other one being <a href="https://en.wikipedia.org/wiki/Jordan%27s_totient_function">https://en.wikipedia.org/wiki/Jordan%27s_totient_function</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, and take the bounds from. Must be initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the power of the power function to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce the result by, or 0 to skip reducing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc3257dcff1b06c34b128c156572a4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3257dcff1b06c34b128c156572a4dd">&#9670;&nbsp;</a></span>nut_Diri_compute_conv_u()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_Diri_compute_conv_u </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>f_tbl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value table for h = f &lt;*&gt; u, the dirichlet convolution of f and u (the unit function u(n) = 1), given the value table for f See <a class="el" href="dirichlet_8h.html#ac129473cb990ee5563de30608d75d253">nut_Diri_compute_conv</a> for details, this is just that function but with several specializations due to u being very simple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, initialized by <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a>. self-&gt;y, self-&gt;x, and self-&gt;yinv must be set and consistent with the inputs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_tbl</td><td>table for the first operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54146e9f9dea0bbee06a22395833093a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54146e9f9dea0bbee06a22395833093a">&#9670;&nbsp;</a></span>nut_Diri_compute_conv_N()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_Diri_compute_conv_N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>f_tbl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value table for h = f &lt;*&gt; N, the dirichlet convolution of f and N (the identity function N(n) = n), given the value table for f See <a class="el" href="dirichlet_8h.html#ac129473cb990ee5563de30608d75d253">nut_Diri_compute_conv</a> for details, this is just that function but with several specializations due to N being very simple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, initialized by <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a>. self-&gt;y, self-&gt;x, and self-&gt;yinv must be set and consistent with the inputs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_tbl</td><td>table for the first operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac129473cb990ee5563de30608d75d253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac129473cb990ee5563de30608d75d253">&#9670;&nbsp;</a></span>nut_Diri_compute_conv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_Diri_compute_conv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnut__Diri.html">nut_Diri</a> *&#160;</td>
          <td class="paramname"><em>f_tbl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnut__Diri.html">nut_Diri</a> *&#160;</td>
          <td class="paramname"><em>g_tbl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value table for h = f &lt;*&gt; g, the dirichlet convolution of f and g, given value tables for the operands self must have been initialized using <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a>, and in particular the lengths and cutoffs for self, f_tbl, and g_tbl must be set and match This uses a sieve to compute h(1) through h(y), then uses dirichlet's hyperbola formula to compute H(x/1) through H(x/(yinv-1)) If one of the operands is a simple standard multiplicative function like the unit function u or the mobius function mu, then try to use a specialized function from this library and use that instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, initialized by <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a>. self-&gt;y, self-&gt;x, and self-&gt;yinv must be set and consistent with the inputs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_tbl</td><td>table for the first operand (dirichlet convolution is commutative, so order doesn't matter) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g_tbl</td><td>table for the second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa888abb382e18f4b8a1cc645434d9c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa888abb382e18f4b8a1cc645434d9c03">&#9670;&nbsp;</a></span>nut_Diri_convdiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_Diri_convdiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>f_tbl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>g_tbl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value table for h such that f = g &lt;*&gt; h, aka h = f &lt;/&gt; g where the division is in terms of dirichlet convolution self must have been initialized using <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a>, and in particular the lengths and cutoffs for self, f_tbl, and g_tbl must be set and match This is the inverse of &lt;*&gt;, in the sense that if h = f &lt;/&gt; g, then h &lt;*&gt; g = f. </p>
<p>In fact, this function is essentially implemented by solving this for H(v) and applying the dirichlet hyperbola method (see the code comments for details). Unlike the <code>compute_conv_*</code> family of functions, this needs to allocate space for scratch work, which can cause it to fail if there is not enough memory. About 16*(self-&gt;y + 1) bytes will be allocated. Currently there are not specialized functions for dividing by simple standard functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, initialized by <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a>. self-&gt;y, self-&gt;x, and self-&gt;yinv must be set ant consistent with the inputs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_tbl</td><td>table for the first operand (the "numerator" aka "dividend" in the "division") </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g_tbl</td><td>the table for the second operand (the "denominator" aka "divisor" in the "division") </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_073faa820624379b5730e5b4f5cb1c42.html">nut</a></li><li class="navelem"><a class="el" href="dirichlet_8h.html">dirichlet.h</a></li>
    <li class="footer">Generated on Thu May 2 2024 17:09:45 for Number Theory Utils by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
