<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Number Theory Utils: include/nut/dirichlet.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_awesome_sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="/Number-Theory-Utils/index.html">Number Theory Utils</a><span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dirichlet_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">dirichlet.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.2.0 </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Dirichlet Hyperbola based functions for computing sums of multiplicative functions at a single value quickly</p>
<p>For a function f defined over the natural numbers, we say f is multiplicative if f(ab) = f(a)f(b) whenever a and b are coprime (have gcd 1). There are many functions in number theory that satisfy this condition, with one of the most well known being euler's phi function.</p>
<p>A brief list of common multiplicative functions is: (see here <a href="https://en.wikipedia.org/wiki/Multiplicative_function">https://en.wikipedia.org/wiki/Multiplicative_function</a>) The dirichlet convolution identity (explained later): I(n) = 1 if n == 1; 0 otherwise Sometimes written epsilon(n), (very confusingly) u(n), or delta(n, 0) (since it is just a kroneker delta function of course) The constant function: u(n) = 1 Sometimes written 1(n) The identity function: N(n) = n Sometimes written Id(n) or id(n) The power functions: N_k(n) = n**k Sometimes written Id_k(n) The divisor count function: d(n) = #{k | n} (the number of natural numbers including 1 and n which divide n) The generalized divisor functions: d_k(n) = # k-tuples ks of natural numbers such that ks multiplies out to n The divisor power sum functions: sigma_a(n) = sum(k | n, k**a) (note that a can be any real number) The mobius function: mu(n) = 0 if n is not squarefree; (-1)**Omega(n) otherwise, where Omega(n) is the number of prime factors of n with multiplicity Euler's totient function: phi(n) = #{k = 1 ... n : (k coprime n)} Any constant raised to the power of Omega(n) or omega(n) (the number of prime factors of n counted with and without multiplicity respectively) The number of non-isomorphic abelian groups of order n: a(n) The Ramanujan tau function: tau(n) The unitary divisor power sums: sigma_a^*(n) = sum(d | n where (d coprime n/d), d**a) All dirichlet characters, including the legendre symbol (n/p) for fixed p and gcd(n, m) for fixed m</p>
<p>Some of these are fully multiplicative, meaning not only do they satisfy f(ab) = f(a)f(b) for a, b coprime, but they satisfy it for all a, b. In particular, I, u, N, and N_k are fully multiplicative.</p>
<p>We often want to find the sum of a multiplicative function, often denoted by a capital version, for instance phi and Phi, f and F (for a general function, etc). We also often want to be able to analyze multiplicative functions in terms of simpler functions.</p>
<p>Multiplicative functions are fully determined by their values at prime powers, which often leads to efficient sieve based approaches to calculating them. This header provides some functions for doing this, the nut_euler_sieve family of functions, although these are mainly intended as low level subroutines for the upcoming Dirichlet Hyperbola algorithm.</p>
<p>However, if we only want to compute the sum of a multiplicative function up to some value n, sieve based methods will basically be O(nlogn), which seems very bad considering how structured multiplicative functions are.</p>
<p>Indeed, we can often do better, in particular when we want to find the sum H(n) of some multiplicative function h(n) defined as h = f &lt;*&gt; g where &lt;*&gt; denotes Dirichlet convolution. What is Dirichlet convolution? It is an operation for combining functions, similar to ordinary multiplication, division, addition, subtraction, composition, and so on. It is defined as (f &lt;*&gt; g)(n) = sum(k | n, f(k)g(n/k)). This is mostly useful because when f and g are multiplicative f &lt;*&gt; g will be as well, and it lets us build up more complicated functions in terms of simpler ones. (see here <a href="https://en.wikipedia.org/wiki/Dirichlet_convolution">https://en.wikipedia.org/wiki/Dirichlet_convolution</a>)</p>
<p>Obviously, not all operations on multiplicative functions will produce multiplicative functions. For example, if f is multiplicative, 2f is not, so multiplicative functions are not closed under scalar multiplication, and thus they are not closed under addition. They are closed under multiplication and dirichlet convolution though.</p>
<p>The Dirichlet Hyperbola algorithm lets us rewrite H(x) = sum(n &lt;= x, h(n)) in terms of F and G as well as f and g, but crucially it lets us evaluate them at fewer values.</p>
<p>In particular, sum(n &lt;= x, (f &lt;*&gt; g)(n)) = sum(n &lt;= x, ab = n, f(a)g(b)) = sum(ab &lt;= x, f(a)g(b)) = sum(a &lt;= A, b &lt;= x/a, f(a)g(b)) + sum(b &lt;= B, a &lt;= x/b, f(a)g(b)) - sum(a &lt;= A, b &lt;= B, f(a)g(b)) = sum(a &lt;= A, f(a)G(x/a)) + sum(b &lt;= B, F(x/b)g(b)) - F(A)G(B) where AB = x. (see here <a href="https://gbroxey.github.io/blog/2023/04/30/mult-sum-1.html">https://gbroxey.github.io/blog/2023/04/30/mult-sum-1.html</a>) (see here <a href="https://angyansheng.github.io/blog/dirichlet-hyperbola-method">https://angyansheng.github.io/blog/dirichlet-hyperbola-method</a>) (you may also find this instructive <a href="https://en.wikipedia.org/wiki/Marginal_distribution">https://en.wikipedia.org/wiki/Marginal_distribution</a>) To accomplish this rearrangement, we first expanded (f &lt;*&gt; g) using the definition of dirichlet convolution. Then, we interpreted the sum both as an a-indexed sum and as a b-indexed sum. We could find the sum either way, but considering both sets us up to cut the work down quadratically. These two ways of interpreting the sum are EXACTLY EQUIVALENT to the trick of transforming an integral of f(x) in terms of x into an integral of f_inverse(y) in terms of y. For integrals, it is common to just pick whichever interpretation is easier, but for our sum, we benefit from realizing that if we sum f(a)g(b) for (a &lt;= A, b &lt;= x/a) and then separately for (b &lt;= B, a &lt;= x/b), then we double count the rectangular region (a &lt;= A, b &lt;= B). But more importantly, if we pick A = B = sqrt(x), then we've turned one sum over (f &lt;*&gt; g) for n from 1 to x, which we could accomplish in about O(xlogx), into two sums over f*G and F*g for n from 1 to sqrt(x), which we can sometimes accomplish in O(sqrt(x)).</p>
<p>There is a big catch though, we now need to know values of F and G as well as f and g. Wonderfully though, we only need to know F(x/n) and G(x/n) for integral values of n, and floor(x/n) has at most 2sqrt(x) distinct values. That, arguably, is the real magic, since it lets us store only O(sqrt(x)) values of F and G. When we want to compute only H(x), this is fine, but when we want to repeatedly compute the table of values of H(x/n) for integral values of n, it is often better to make A larger than B, eg A = x**(2/3) and B = x**(1/3). </p>

<p class="definition">Definition in file <a class="el" href="dirichlet_8h_source.html">dirichlet.h</a>.</p>
</div>
<p><a href="dirichlet_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnut__Diri.html">nut_Diri</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to hold values of some multiplicative function.  <a href="structnut__Diri.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a48cf875993b4e4c48c3bb214d84285b1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#a48cf875993b4e4c48c3bb214d84285b1">nut_dirichlet_D</a> (uint64_t max, uint64_t m)</td></tr>
<tr class="memdesc:a48cf875993b4e4c48c3bb214d84285b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of the divisor count function d from 1 to max.  <a href="dirichlet_8h.html#a48cf875993b4e4c48c3bb214d84285b1">More...</a><br /></td></tr>
<tr class="separator:a48cf875993b4e4c48c3bb214d84285b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6281d3554686ce3abc5195a104945526"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#a6281d3554686ce3abc5195a104945526">NUT_ATTR_ACCESS</a> (read_only, 3, 1) NUT_ATTR_ACCESS(read_write</td></tr>
<tr class="memdesc:a6281d3554686ce3abc5195a104945526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a table of values of a multiplicative function f, compute (f &lt;*&gt; u)(x) for all x from 1 to n See <a class="el" href="">nut_euler_sieve_conv_u</a> for more info}.  <a href="dirichlet_8h.html#a6281d3554686ce3abc5195a104945526">More...</a><br /></td></tr>
<tr class="separator:a6281d3554686ce3abc5195a104945526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2f0dc86d8486a52cc05f57a42ec453"><td class="memItemLeft" align="right" valign="top"><a id="aff2f0dc86d8486a52cc05f57a42ec453"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>nut_euler_sieve_conv_u</b> (int64_t n, int64_t m, const int64_t f_vals[static n+1], int64_t f_conv_u_vals[restrict static n+1])</td></tr>
<tr class="separator:aff2f0dc86d8486a52cc05f57a42ec453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74180d3515220729cf659328a49154c9"><td class="memItemLeft" align="right" valign="top"><a id="a74180d3515220729cf659328a49154c9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>nut_euler_sieve_conv_N</b> (int64_t n, int64_t m, const int64_t f_vals[static n+1], int64_t f_conv_N_vals[restrict static n+1])</td></tr>
<tr class="separator:a74180d3515220729cf659328a49154c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c97cee216670192e4e6601449f406c1"><td class="memItemLeft" align="right" valign="top"><a id="a0c97cee216670192e4e6601449f406c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NUT_ATTR_ACCESS</b> (read_write, 5, 1) bool nut_euler_sieve_conv(int64_t n</td></tr>
<tr class="separator:a0c97cee216670192e4e6601449f406c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f69060eec4fdf127316bd2998e356d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *self, int64_t x, int64_t y)</td></tr>
<tr class="memdesc:a4f69060eec4fdf127316bd2998e356d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate internal buffers for a diri table self-&gt;buf will have f(0) through f(y) at indicies 0 through y, and then f(x/1) through f(x/(yinv - 1)) at indicies y + 1 through y + yinv - 1.  <a href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">More...</a><br /></td></tr>
<tr class="separator:a4f69060eec4fdf127316bd2998e356d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b561a6ee692252d8d17e479f14144e8"><td class="memItemLeft" align="right" valign="top"><a id="a4b561a6ee692252d8d17e479f14144e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#a4b561a6ee692252d8d17e479f14144e8">nut_Diri_copy</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict dest, const <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict src)</td></tr>
<tr class="memdesc:a4b561a6ee692252d8d17e479f14144e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the values from one diri table to another, which must be initialized. <br /></td></tr>
<tr class="separator:a4b561a6ee692252d8d17e479f14144e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11c54899255356be156c2246edb24d2"><td class="memItemLeft" align="right" valign="top"><a id="ad11c54899255356be156c2246edb24d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#ad11c54899255356be156c2246edb24d2">nut_Diri_destroy</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *self)</td></tr>
<tr class="memdesc:ad11c54899255356be156c2246edb24d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate internal buffers for a diri table. <br /></td></tr>
<tr class="separator:ad11c54899255356be156c2246edb24d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72111f9468ba6240298b9265dc3f0ddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#a72111f9468ba6240298b9265dc3f0ddd">nut_Diri_compute_I</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *self)</td></tr>
<tr class="memdesc:a72111f9468ba6240298b9265dc3f0ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just memset's the dense part, then sets index 1 and y + 1 through y + yinv - 1 to 1 (remember the sparse indicies are sums)  <a href="dirichlet_8h.html#a72111f9468ba6240298b9265dc3f0ddd">More...</a><br /></td></tr>
<tr class="separator:a72111f9468ba6240298b9265dc3f0ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd834fdb77cadd1e63b935220295e47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#a8bd834fdb77cadd1e63b935220295e47">nut_Diri_compute_u</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *self, int64_t m)</td></tr>
<tr class="memdesc:a8bd834fdb77cadd1e63b935220295e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value table for the unit function u(n) = 1 Fills the dense part of the table with 1s, and computes the sparse entries with table[y + k] = U(x/k) = x/k.  <a href="dirichlet_8h.html#a8bd834fdb77cadd1e63b935220295e47">More...</a><br /></td></tr>
<tr class="separator:a8bd834fdb77cadd1e63b935220295e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3a0c29121da13a74cec34c49d77d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#aef3a0c29121da13a74cec34c49d77d4b">nut_Diri_compute_N</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *self, int64_t m)</td></tr>
<tr class="memdesc:aef3a0c29121da13a74cec34c49d77d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value table for the identity function N(n) = n Fills the dense part of the table with increasing numbers, and computes the sparse entries with table[y + k] = sum_N(v = x/k) = v*(v+1)/2.  <a href="dirichlet_8h.html#aef3a0c29121da13a74cec34c49d77d4b">More...</a><br /></td></tr>
<tr class="separator:aef3a0c29121da13a74cec34c49d77d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23dcc7562e209acadb64a6e4fa8414f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#ad23dcc7562e209acadb64a6e4fa8414f">NUT_ATTR_ACCESS</a> (read_write, 1) NUT_ATTR_ACCESS(read_only</td></tr>
<tr class="memdesc:ad23dcc7562e209acadb64a6e4fa8414f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value table for the mobius function mu(n) (whose sum is called the Mertens function) Requires both an initialized <a class="el" href="structnut__Diri.html" title="Wrapper to hold values of some multiplicative function.">nut_Diri</a> from <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a> and a packed table of mobius values from <a class="el" href="sieves_8h.html#ac1184e4b679ee165bb5e6ae0179f2d4b">nut_sieve_mobius</a>.  <a href="dirichlet_8h.html#ad23dcc7562e209acadb64a6e4fa8414f">More...</a><br /></td></tr>
<tr class="separator:ad23dcc7562e209acadb64a6e4fa8414f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de369be5cae92e31d9f073144b6645d"><td class="memItemLeft" align="right" valign="top"><a id="a1de369be5cae92e31d9f073144b6645d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>nut_Diri_compute_mertens</b> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict self, int64_t m, const uint8_t mobius[restrict static self-&gt;y/4+1])</td></tr>
<tr class="separator:a1de369be5cae92e31d9f073144b6645d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa27d52f1bde28bec89dbe3ee2eb1c11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dirichlet_8h.html#aaa27d52f1bde28bec89dbe3ee2eb1c11">nut_Diri_compute_dk</a> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict self, uint64_t k, int64_t m, <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict f_tbl, <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict g_tbl)</td></tr>
<tr class="memdesc:aaa27d52f1bde28bec89dbe3ee2eb1c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value table for the kth generalized divisor function dk(n) dk(n) = da(n) &lt;*&gt; db(n) whenever a + b = k.  <a href="dirichlet_8h.html#aaa27d52f1bde28bec89dbe3ee2eb1c11">More...</a><br /></td></tr>
<tr class="separator:aaa27d52f1bde28bec89dbe3ee2eb1c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3257dcff1b06c34b128c156572a4dd"><td class="memItemLeft" align="right" valign="top"><a id="abc3257dcff1b06c34b128c156572a4dd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>nut_Diri_compute_conv_u</b> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict self, int64_t m, const <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict f_tbl)</td></tr>
<tr class="separator:abc3257dcff1b06c34b128c156572a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54146e9f9dea0bbee06a22395833093a"><td class="memItemLeft" align="right" valign="top"><a id="a54146e9f9dea0bbee06a22395833093a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>nut_Diri_compute_conv_N</b> (<a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict self, int64_t m, const <a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict f_tbl)</td></tr>
<tr class="separator:a54146e9f9dea0bbee06a22395833093a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797a93f1c667ba4876d390e57953aabc"><td class="memItemLeft" align="right" valign="top"><a id="a797a93f1c667ba4876d390e57953aabc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NUT_ATTR_ACCESS</b> (read_only, 4) bool nut_Diri_compute_conv(<a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict self</td></tr>
<tr class="separator:a797a93f1c667ba4876d390e57953aabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3500d32707f04424ffa97759a0dbac14"><td class="memItemLeft" align="right" valign="top"><a id="a3500d32707f04424ffa97759a0dbac14"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>m</b></td></tr>
<tr class="separator:a3500d32707f04424ffa97759a0dbac14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd887471564417d3361a6eaa5c1958a9"><td class="memItemLeft" align="right" valign="top"><a id="abd887471564417d3361a6eaa5c1958a9"></a>
int64_t const int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>f_vals</b> [static n+1]</td></tr>
<tr class="separator:abd887471564417d3361a6eaa5c1958a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc187c85461251571e98be6893a9cd4"><td class="memItemLeft" align="right" valign="top"><a id="a2cc187c85461251571e98be6893a9cd4"></a>
int64_t const int64_t const int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>g_vals</b> [static n+1]</td></tr>
<tr class="separator:a2cc187c85461251571e98be6893a9cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f0998994a1d94edf25c460b84c5e24"><td class="memItemLeft" align="right" valign="top"><a id="a02f0998994a1d94edf25c460b84c5e24"></a>
int64_t const int64_t const int64_t int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>f_conv_g_vals</b> [restrict static n+1]</td></tr>
<tr class="separator:a02f0998994a1d94edf25c460b84c5e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17e814985ed472ec37fe1d0b357b8b0"><td class="memItemLeft" align="right" valign="top"><a id="ac17e814985ed472ec37fe1d0b357b8b0"></a>
int64_t const <a class="el" href="structnut__Diri.html">nut_Diri</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>f_tbl</b></td></tr>
<tr class="separator:ac17e814985ed472ec37fe1d0b357b8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963e45ca4677560c96f56b25289ba599"><td class="memItemLeft" align="right" valign="top"><a id="a963e45ca4677560c96f56b25289ba599"></a>
int64_t const <a class="el" href="structnut__Diri.html">nut_Diri</a> const <a class="el" href="structnut__Diri.html">nut_Diri</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>g_tbl</b></td></tr>
<tr class="separator:a963e45ca4677560c96f56b25289ba599"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a48cf875993b4e4c48c3bb214d84285b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cf875993b4e4c48c3bb214d84285b1">&#9670;&nbsp;</a></span>nut_dirichlet_D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nut_dirichlet_D </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the sum of the divisor count function d from 1 to max. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of range to compute sum for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce result by, or 0 to skip reducing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum d(1) + ... + d(max) </dd></dl>

</div>
</div>
<a id="a6281d3554686ce3abc5195a104945526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6281d3554686ce3abc5195a104945526">&#9670;&nbsp;</a></span>NUT_ATTR_ACCESS() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NUT_ATTR_ACCESS </td>
          <td>(</td>
          <td class="paramtype">read_only&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">3&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a table of values of a multiplicative function f, compute (f &lt;*&gt; u)(x) for all x from 1 to n See <a class="el" href="">nut_euler_sieve_conv_u</a> for more info}. </p>
<p>Given tables of values of multiplicative functions f and g, compute (f &lt;*&gt; g)(x) for all x from 1 to n This uses Euler's sieve, a variant of the sieve of Eratosthenes that only marks off each multiple once.</p>
<p>Given a table of values of a multiplicative function f, compute (f &lt;*&gt; N)(x) for all x from 1 to n See <a class="el" href="">nut_euler_sieve_conv_u</a> for more info}.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>inclusive upper bound of range to compute f &lt;*&gt; u over </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_vals</td><td>table of values for f </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_conv_u_vals</td><td>table to store values of f &lt;*&gt; u in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on allocation failure</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>inclusive upper bound of range to compute f &lt;*&gt; N over </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_vals</td><td>table of values for f </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_conv_N_vals</td><td>table to store values of f &lt;*&gt; N in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on allocation failure</dd></dl>
<p>This generally has worse performance than the sieve of Eratosthenes, but some preliminary tests showed that Eratosthenes is only about 14% faster in release mode than Euler, so currently only Euler's sieve is implemented. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>inclusive upper bound of range to compute f &lt;*&gt; g over </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_vals</td><td>table of values for f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g_vals</td><td>table of values for f </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_conv_g_vals</td><td>table to store values of f &lt;*&gt; g in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on allocation failure </dd></dl>

</div>
</div>
<a id="a4f69060eec4fdf127316bd2998e356d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f69060eec4fdf127316bd2998e356d4">&#9670;&nbsp;</a></span>nut_Diri_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_Diri_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate internal buffers for a diri table self-&gt;buf will have f(0) through f(y) at indicies 0 through y, and then f(x/1) through f(x/(yinv - 1)) at indicies y + 1 through y + yinv - 1. </p>
<p>The first two indicies, f(0) and f(1), are basically dummies though: f(0) should never be relied on, and f(1) should always be 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>inclusive upper bound of the domain of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>inclusive upper bound of the dense portion of the domain of interest. Will be increased to sqrt(x) if needed, so 0 can be used to explicitly signal you want that behavior </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on allocation failure </dd></dl>

</div>
</div>
<a id="a72111f9468ba6240298b9265dc3f0ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72111f9468ba6240298b9265dc3f0ddd">&#9670;&nbsp;</a></span>nut_Diri_compute_I()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nut_Diri_compute_I </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Just memset's the dense part, then sets index 1 and y + 1 through y + yinv - 1 to 1 (remember the sparse indicies are sums) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, and take the bounds from. Must be initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bd834fdb77cadd1e63b935220295e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd834fdb77cadd1e63b935220295e47">&#9670;&nbsp;</a></span>nut_Diri_compute_u()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nut_Diri_compute_u </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value table for the unit function u(n) = 1 Fills the dense part of the table with 1s, and computes the sparse entries with table[y + k] = U(x/k) = x/k. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, and take the bounds from. Must be initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef3a0c29121da13a74cec34c49d77d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3a0c29121da13a74cec34c49d77d4b">&#9670;&nbsp;</a></span>nut_Diri_compute_N()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nut_Diri_compute_N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value table for the identity function N(n) = n Fills the dense part of the table with increasing numbers, and computes the sparse entries with table[y + k] = sum_N(v = x/k) = v*(v+1)/2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, and take the bounds from. Must be initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad23dcc7562e209acadb64a6e4fa8414f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23dcc7562e209acadb64a6e4fa8414f">&#9670;&nbsp;</a></span>NUT_ATTR_ACCESS() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NUT_ATTR_ACCESS </td>
          <td>(</td>
          <td class="paramtype">read_write&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value table for the mobius function mu(n) (whose sum is called the Mertens function) Requires both an initialized <a class="el" href="structnut__Diri.html" title="Wrapper to hold values of some multiplicative function.">nut_Diri</a> from <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a> and a packed table of mobius values from <a class="el" href="sieves_8h.html#ac1184e4b679ee165bb5e6ae0179f2d4b">nut_sieve_mobius</a>. </p>
<p>Attempt to find a divisor of f_d.</p>
<p>Compute the product of all irreducible factors of degree d.</p>
<p>Compute the power of a polynomial mod another polynomial.</p>
<p>Find the gcd of two polynomials.</p>
<p>Divide two polynomials to get a quotient and remainder.</p>
<p>Compose polynomial f(g(x)) mod n and store the result in h.</p>
<p>Raise f**x mod n and store the result in g.</p>
<p>Multiply polynomials f*g mod n and store the result in h.</p>
<p>Multiply a polynomial f by a scalar a and store the result in h.</p>
<p>Take the termwise product of polynomials f and g mod n and store the result in h.</p>
<p>Subtract polynomials f - g mod n and store the result in h.</p>
<p>Add polynomials f + g mod n and store the result in h.</p>
<p>Convert a string to a polynomial (and possibly modulus)</p>
<p>Print a polynomial to a file.</p>
<p>Add all prime/power pairs in one factorization to another.</p>
<p>Get the next entry from a powerful number iterator This entry will have out-&gt;n set to a powerful number and out-&gt;hn set to the value of h evaluated at that n, where h is the function defined at iterator creation time.</p>
<p>Mainly for internal use Pop an entry from the internal stack of a powerful number iterator Doing this together with calling <a class="el" href="">nut_PfIt_next</a> will obviously break.</p>
<p>Compute the value table for h = f &lt;*&gt; g, the dirichlet convolution of f and g, given value tables for the operands self must have been initialized using <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a>, and in particular the lengths and cutoffs for self, f_tbl, and g_tbl must be set and match This uses a sieve to compute h(1) through h(y), then uses dirichlet's hyperbola formula to compute H(x/1) through H(x/(yinv-1)) If one of the operands is a simple standard multiplicative function like the unit function u or the mobius function mu, then try to use a specialized function from this library and use that instead.</p>
<p>Compute the value table for h = f &lt;*&gt; N, the dirichlet convolution of f and N (the identity function N(n) = n), given the value table for f See <a class="el" href="">nut_Diri_compute_conv</a> for details, this is just that function but with several specializations due to N being very simple.</p>
<p>Compute the value table for h = f &lt;*&gt; u, the dirichlet convolution of f and u (the unit function u(n) = 1), given the value table for f See <a class="el" href="">nut_Diri_compute_conv</a> for details, this is just that function but with several specializations due to u being very simple.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, and take the bounds from. Must be initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mobius</td><td>packed table of mobius values, from <a class="el" href="sieves_8h.html#ac1184e4b679ee165bb5e6ae0179f2d4b">nut_sieve_mobius</a> (with upper bound self-&gt;y).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, initialized by <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a>. self-&gt;y, self-&gt;x, and self-&gt;yinv must be set and consistent with the inputs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_tbl</td><td>table for the first operand</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, initialized by <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a>. self-&gt;y, self-&gt;x, and self-&gt;yinv must be set and consistend with the inputs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce results by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_tbl</td><td>table for the first operand (dirichlet convolution is commutative, so order doesn't matter) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g_tbl</td><td>table for the second operand</td></tr>
  </table>
  </dd>
</dl>
<p>out-&gt;i is not meaningful to the caller.</p>
<p>If both inputs are sorted, the result will be sorted and no dupliate entries will be created. Acts as if <a class="el" href="">factors_append</a> were called repeatedly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factors</td><td>pointer to factorization struct which should be extended </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors2</td><td>pointer to factorization struct whose entries will be added to the other struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>power to multiply entries of factors2 by, for if some composite number m was discovered where m^k divides n and we have factored m</td></tr>
  </table>
  </dd>
</dl>
<p>Skips zero terms, coefficients of 1 or -1, powers of 0 or 1, and any leading plus sign. Thus the the format is "x^2 + 2x + 1". The zero polynomial is displayed as "0", and a leading negative sign is always displayed as "-" with no trailing space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td>file to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>polynomial to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vname</td><td>string to use for variable, eg "x" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>string to use for adding two monomials together, eg "+" or " + " </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub</td><td>string to use for subtracting two monomials, eg "-" or " - " </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pow</td><td>string to use for exponents, eg "**" for "x**2" or "^" for "x^2" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descending</td><td>if true, print higher terms down to lower terms, otherwise print lower terms up to higher terms (Taylor Series order) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of characters printed</dd></dl>
<p>Ignores whitespace, ignores variable names, allows multiplication signs, duplicate terms, and duplicate minus signs. The format is poly = monomial (+|- monomial)* ("mod" \d+)? monomial = -* ((coeff *? vpow) | coeff | vpow) coeff = \d+ vpow = \w (("**"|"^") \d+)? </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>polynomial to store output in </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>pointer to store modulus n in if found </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to parse </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">end</td><td>pointer to store end of parsed content (first unparsed character, ie typically '\0') </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on failure, 1 if polynomial was parsed without modulus, 2 if both polynomial and modulus were parsed</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store the sum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store the difference f - g mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to subtract </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to multiply termwise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>polynomial in which to store a*f mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>polynomial to multiply by a scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>scalar to multiply by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure</dd></dl>
<p>Uses the basic algorithm </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store f*g mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to multiply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>polynomial in which to store f**x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>polynomial to find a power of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>exponent to raise f to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cn</td><td>carmichael lambda function of n, basically modulus for exponents, see <a class="el" href="">carmichael_lambda</a> and <a class="el" href="sieves_8h.html#a80312f8b853eeb8a9df48ff15078c2f0">nut_sieve_carmichael</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmps</td><td>polynomial for scratch work, must have 1 initialized (or at least zeroed out) polynomial (<a class="el" href="">nut_Poly_pow_modn_tmptmp</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure</dd></dl>
<p>Like <a class="el" href="">nut_Poly_pow_modn</a> except temporary polynomials are allocated and freed internally instead of using supplied temporaries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>polynomial in which to store f**x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>polynomial to find a power of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>exponent to raise f to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cn</td><td>carmichael lambda function of n, basically modulus for exponents, see <a class="el" href="">carmichael_lambda</a> and <a class="el" href="sieves_8h.html#a80312f8b853eeb8a9df48ff15078c2f0">nut_sieve_carmichael</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store f(g(x)) mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to compose </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cn</td><td>carmichael lambda function of n, basically modulus for exponents, see <a class="el" href="">carmichael_lambda</a> and <a class="el" href="sieves_8h.html#a80312f8b853eeb8a9df48ff15078c2f0">nut_sieve_carmichael</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmps</td><td>polynomial for scratch work, must have 1 initialized (or at least zeroed out) polynomial (<a class="el" href="">nut_Poly_compose_modn_tmptmp</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure</dd></dl>
<p>Like <a class="el" href="">nut_Poly_compose_modn</a> except temporary polynomials are allocated and freed internally instead of using supplied temporaries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store f(g(x)) mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to compose </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cn</td><td>carmichael lambda function of n, basically modulus for exponents, see <a class="el" href="">carmichael_lambda</a> and <a class="el" href="sieves_8h.html#a80312f8b853eeb8a9df48ff15078c2f0">nut_sieve_carmichael</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure</dd></dl>
<p>f = q*g + r mod n. Uses extended synthetic division. Note that while weaker forms of polynomial division can be defined for weaker forms of rings than fields, the synthetic division algorithm can fail if the coefficient ring is not a field because division by the leading coefficient might fail. Even if n is composite, if the leading coefficient of the divisor is 1 then this algorithm will not fail, otherwise, this function fails. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">q,r</td><td>polynomials in which to store the quotient and remainder such that f = q*g + r mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to divide </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure. Can fail if the leading cofficient of g is not invertable mod n, as well as on allocation failure</dd></dl>
<p>The gcd is reduced to be monic, so if n is not prime this can fail. If d = gcd(f, g), then there is some pair of polynomials a and b so that f = ad and g = bd (d is a common divisor), and for any other common divisor h, d = ch for some polynomial c (d is greatest because it has at least as high degree as any other common divisor. Note that in the integers, we have two choices for gcd, which are associates (meaning one is the negative of the other) and we pick the positive one by convention. Similarly for polynomials with coefficients from a field, the the gcd is not unique and any associate of the gcd is also a gcd. Thus we restrict the gcd to be monic. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>polynomial in which to store the monic gcd, or store 0 if both f and n are 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to take the gcd of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus for the coefficient ring </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmps</td><td>polynomials for scratch work, cannot be NULL (<a class="el" href="">nut_Poly_gcd_modn_tmptmp</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure. Can fail if a non-invertable leading coefficient is encountered, as well as on allocation failure.</dd></dl>
<p>Like <a class="el" href="">nut_Poly_gcd_modn</a> except temporary polynomials are allocated and freed internally instead of using supplied temporaries. Less efficient because early checking is not done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>polynomial in which to store the monic gcd, or store 0 if both f and n are 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to take the gcd of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus for the coefficient ring </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure. Can fail if a non-invertable leading coefficient is encountered, as well as on allocation failure.</dd></dl>
<p>Uses binary exponentiation. The coefficients themselves are in the cyclic group Z_n as usual. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>base </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>exponent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>coefficient modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmps</td><td>polynomials for scratch work, must have 3 initialized (or at least zeroed out) polynomials (<a class="el" href="">nut_Poly_powmod_modn_tmptmp</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure. Can fail if a non-invertable leading coefficient is encountered, as well as on allocation failure.</dd></dl>
<p>Like <a class="el" href="">nut_Poly_powmod_modn</a> except temporary polynomials are allocated and freed internally instead of using supplied temporaries. Less efficient because early checking is not done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>base </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>exponent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>coefficient modulus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure. Can fail if a non-invertable leading coefficient is encountered, as well as on allocation failure.</dd></dl>
<p>This should be called repeatedly on squarefree factors, or else it will extract repeat factors for d &gt; 1. Thus if we only want roots in the field Z_p, or equivalently we only want linear factors, we can call this function without bothering to make f squarefree first. In the general case, getting the squarefree factorization of f is easy: any repeated root of f (in Z_p or indeed the splitting field of f) is also a root of f' the derivative of f, so we can say the squarefree part of f is f / gcd(f, f'). We can repeat this to find polynomials representing roots which occur exactly once (f / gcd(f, f')), roots which occur exactly twice (sqrt(gcd(f, f') / gcd(f, f''))), roots which occur exactly thrice (cbrt(gcd(f, f'') / gcd(f, f'''))), etc. Eventually, these quotients will saturate and just become 1 forever. If f is already squarefree, let f_i be the product of all irreducible factors of f with degree i. Then we have f_1 = gcd(x^p-x, f), f_2 = gcd(x^(p^2), f/f_1), f_3 = gcd(x^(p^3), f/f_1/f_2), etc. Once the expression f/f_1/f_2/.../f_i becomes 1, we are done. This clearly takes at most k steps, where k is the degree of f. It is possible to show an irreducible f is irreducible by only showing it has no factors of degree k/q for any prime divisor q, ie f | x^(p^k) but gcd(f, x^(p^(k/q))) = 1 for all q. This function only takes care of computing gcd(x^(p^d)-x, f/f_1/.../f_(d-1)) given p, d, and f/f_1/.../f_(d-1). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f_d</td><td>the product of all degree d irreducible factors of f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the polynomial to factor, which should be squarefree and have no irreducible factors with degree less than d </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>the degree of irreducible factors to extract. Note that f should be free from irreducible factors with lower degree, so once d exceeds half the degree of f, f must be irreducible. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>coefficient modulus. MUST be prime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmps</td><td>polynomials for scratch work, must have 4 initialized (or at least zeroed out) polynomials </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure</dd></dl>
<p>Given a squarefree polynomial f whose irreducible factors all have degree d, if f has degree k which is greater than d (it must be a multiple of d) it must split. Mod an odd prime p, we can find a nontrivial factor of f by 1) choosing a random r with degree less than k (if gcd(r, f) isn't 1 we are done), 2) computing s = r^((p^d-1)/2) mod f, 3) gcd(s + 1, f) is a nontrivial factor with probability greater than 1/2. This works because not only does x^(p^d)-x factor as x(x^((p^d-1)/2)-1)(x^((p^d-1)/2)+1), this holds if we replace x with any polynomial. If a factor isn't contained in the first term, it has about a 1/2 chance of being contained in the second term, hence this algorithm. This function returns a single nontrivial factor g, and both g and f/g may need to be factored further if they are not degree d. Note that if f is degree 2 with irreducible factors of degree 1, completing the square/using the quadratic formula is faster, although for such small polynomials this is unimportant. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>a nontrivial factor of f. Both g and f/g could potentially need to be factored further with more calls to this method. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the polynomial to factor, which should be squarefree and have multiple irreducible factors of degree d </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>the degree of irreducible factors of f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>coefficient modulus. MUST be prime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmps</td><td>polynomials for scratch work, must have 4 initialized (or at least zeroed out) polynomials </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="aaa27d52f1bde28bec89dbe3ee2eb1c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa27d52f1bde28bec89dbe3ee2eb1c11">&#9670;&nbsp;</a></span>nut_Diri_compute_dk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_Diri_compute_dk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>f_tbl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnut__Diri.html">nut_Diri</a> *restrict&#160;</td>
          <td class="paramname"><em>g_tbl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value table for the kth generalized divisor function dk(n) dk(n) = da(n) &lt;*&gt; db(n) whenever a + b = k. </p>
<p>This function uses binary exponentiation to compute dk in only log(k) convolutions. However, if all dk's are needed, calling <a class="el" href="">nut_Diri_compute_conv_u</a> is more efficient </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>the table to store the result in, initialized by <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a>. self-&gt;y, self-&gt;x, and self-&gt;yinv must be set and consistent with the inputs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>k, ie which generalized divisor function to compute. dk is u &lt;*&gt; u &lt;*&gt; ... &lt;*&gt; u with k u's </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>modulus to reduce the result by, or 0 to skip reducing </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f_tbl,g_tbl</td><td>temporary tables for scratch work, initialized by <a class="el" href="dirichlet_8h.html#a4f69060eec4fdf127316bd2998e356d4">nut_Diri_init</a>, fields y, x, and yinv must be set Will still have scratch data stored on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_073faa820624379b5730e5b4f5cb1c42.html">nut</a></li><li class="navelem"><a class="el" href="dirichlet_8h.html">dirichlet.h</a></li>
    <li class="footer">Generated on Mon Oct 30 2023 20:16:38 for Number Theory Utils by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
