<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Number Theory Utils: include/nut/polynomial.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_awesome_sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="/Number-Theory-Utils/index.html">Number Theory Utils</a><span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('polynomial_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">polynomial.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.2.0 </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Functions for dealing with polynomials with integer coefficients, especially over finite fields. </p>

<p class="definition">Definition in file <a class="el" href="polynomial_8h_source.html">polynomial.h</a>.</p>
</div>
<p><a href="polynomial_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpoly__t.html">poly_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polynomial with signed integer coefficients.  <a href="structpoly__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpoly__roots__t.html">poly_roots_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The roots of a polynomial over a finite field, ignoring multiplicity.  <a href="structpoly__roots__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a608927f8b707837b8fcd315bcea00341"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a608927f8b707837b8fcd315bcea00341">init_poly</a> (<a class="el" href="structpoly__t.html">poly_t</a> *f, uint64_t reserve)</td></tr>
<tr class="memdesc:a608927f8b707837b8fcd315bcea00341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a polynomial with at least a given capacity.  <a href="polynomial_8h.html#a608927f8b707837b8fcd315bcea00341">More...</a><br /></td></tr>
<tr class="separator:a608927f8b707837b8fcd315bcea00341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9bf7cc123816ef3e68640e17ca6f81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a8b9bf7cc123816ef3e68640e17ca6f81">destroy_poly</a> (<a class="el" href="structpoly__t.html">poly_t</a> *f)</td></tr>
<tr class="memdesc:a8b9bf7cc123816ef3e68640e17ca6f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free resources held by a polynomial struct.  <a href="polynomial_8h.html#a8b9bf7cc123816ef3e68640e17ca6f81">More...</a><br /></td></tr>
<tr class="separator:a8b9bf7cc123816ef3e68640e17ca6f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1346a0c296eb7dc64e7362c29dda6e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#ad1346a0c296eb7dc64e7362c29dda6e8">cmp_polys</a> (const <a class="el" href="structpoly__t.html">poly_t</a> *a, const <a class="el" href="structpoly__t.html">poly_t</a> *b)</td></tr>
<tr class="memdesc:ad1346a0c296eb7dc64e7362c29dda6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asymptotically compare polynomials.  <a href="polynomial_8h.html#ad1346a0c296eb7dc64e7362c29dda6e8">More...</a><br /></td></tr>
<tr class="separator:ad1346a0c296eb7dc64e7362c29dda6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0010cb7659c53c79e3ec3ada1809b978"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a0010cb7659c53c79e3ec3ada1809b978">init_poly_roots</a> (<a class="el" href="structpoly__roots__t.html">poly_roots_t</a> *roots, uint64_t reserve)</td></tr>
<tr class="memdesc:a0010cb7659c53c79e3ec3ada1809b978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a root buffer with at least a given capacity.  <a href="polynomial_8h.html#a0010cb7659c53c79e3ec3ada1809b978">More...</a><br /></td></tr>
<tr class="separator:a0010cb7659c53c79e3ec3ada1809b978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae501a32ed22a602c6da05679442e9ab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#ae501a32ed22a602c6da05679442e9ab6">destroy_poly_roots</a> (<a class="el" href="structpoly__roots__t.html">poly_roots_t</a> *roots)</td></tr>
<tr class="memdesc:ae501a32ed22a602c6da05679442e9ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free resources held by a root buffer.  <a href="polynomial_8h.html#ae501a32ed22a602c6da05679442e9ab6">More...</a><br /></td></tr>
<tr class="separator:ae501a32ed22a602c6da05679442e9ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f47d92ef4f1a07f4ddf3d99f244abc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a5f47d92ef4f1a07f4ddf3d99f244abc1">ensure_poly_cap</a> (<a class="el" href="structpoly__t.html">poly_t</a> *f, uint64_t cap)</td></tr>
<tr class="memdesc:a5f47d92ef4f1a07f4ddf3d99f244abc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend the capacity of a polynomial struct if needed.  <a href="polynomial_8h.html#a5f47d92ef4f1a07f4ddf3d99f244abc1">More...</a><br /></td></tr>
<tr class="separator:a5f47d92ef4f1a07f4ddf3d99f244abc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbd98a9607a1cbcddfe4d812550121b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a6dbd98a9607a1cbcddfe4d812550121b">zero_extend_poly</a> (<a class="el" href="structpoly__t.html">poly_t</a> *f, uint64_t len)</td></tr>
<tr class="memdesc:a6dbd98a9607a1cbcddfe4d812550121b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend the capacity of a polynomial struct if needed and set any new terms to 0.  <a href="polynomial_8h.html#a6dbd98a9607a1cbcddfe4d812550121b">More...</a><br /></td></tr>
<tr class="separator:a6dbd98a9607a1cbcddfe4d812550121b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a86948d29f075bdb00c6a2d3870b09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a57a86948d29f075bdb00c6a2d3870b09">ensure_poly_roots_cap</a> (<a class="el" href="structpoly__roots__t.html">poly_roots_t</a> *roots, uint64_t cap)</td></tr>
<tr class="memdesc:a57a86948d29f075bdb00c6a2d3870b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend the capacity of a root buffer if needed.  <a href="polynomial_8h.html#a57a86948d29f075bdb00c6a2d3870b09">More...</a><br /></td></tr>
<tr class="separator:a57a86948d29f075bdb00c6a2d3870b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace328b1c13ce42b4407116b48db24876"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#ace328b1c13ce42b4407116b48db24876">normalize_poly</a> (<a class="el" href="structpoly__t.html">poly_t</a> *f)</td></tr>
<tr class="memdesc:ace328b1c13ce42b4407116b48db24876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip off terms so the leading term is nonzero if needed.  <a href="polynomial_8h.html#ace328b1c13ce42b4407116b48db24876">More...</a><br /></td></tr>
<tr class="separator:ace328b1c13ce42b4407116b48db24876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098b5a4655e573b5151be13bac6cb254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a098b5a4655e573b5151be13bac6cb254">normalize_poly_modn</a> (<a class="el" href="structpoly__t.html">poly_t</a> *f, int64_t n, int use_negatives)</td></tr>
<tr class="memdesc:a098b5a4655e573b5151be13bac6cb254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce coefficients mod n, then normalize.  <a href="polynomial_8h.html#a098b5a4655e573b5151be13bac6cb254">More...</a><br /></td></tr>
<tr class="separator:a098b5a4655e573b5151be13bac6cb254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dd0ce039c8ce903e7e40aef587f93e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#ab0dd0ce039c8ce903e7e40aef587f93e">normalize_exponents_modn</a> (<a class="el" href="structpoly__t.html">poly_t</a> *f, uint64_t cn)</td></tr>
<tr class="memdesc:ab0dd0ce039c8ce903e7e40aef587f93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce any exponents over cn.  <a href="polynomial_8h.html#ab0dd0ce039c8ce903e7e40aef587f93e">More...</a><br /></td></tr>
<tr class="separator:ab0dd0ce039c8ce903e7e40aef587f93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e779775e04d83955296bdda258fc44a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a4e779775e04d83955296bdda258fc44a">copy_poly</a> (<a class="el" href="structpoly__t.html">poly_t</a> *g, const <a class="el" href="structpoly__t.html">poly_t</a> *f)</td></tr>
<tr class="memdesc:a4e779775e04d83955296bdda258fc44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a polynomial.  <a href="polynomial_8h.html#a4e779775e04d83955296bdda258fc44a">More...</a><br /></td></tr>
<tr class="separator:a4e779775e04d83955296bdda258fc44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388a67e34664ce74e3890bec295e907d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a388a67e34664ce74e3890bec295e907d">const_poly</a> (<a class="el" href="structpoly__t.html">poly_t</a> *f, int64_t c)</td></tr>
<tr class="memdesc:a388a67e34664ce74e3890bec295e907d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a polynomial to a constant (linear terms and up zero).  <a href="polynomial_8h.html#a388a67e34664ce74e3890bec295e907d">More...</a><br /></td></tr>
<tr class="separator:a388a67e34664ce74e3890bec295e907d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67e8b256693afb95134c8bdcea71f89"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#ad67e8b256693afb95134c8bdcea71f89">eval_poly_modn</a> (const <a class="el" href="structpoly__t.html">poly_t</a> *f, int64_t x, int64_t n)</td></tr>
<tr class="memdesc:ad67e8b256693afb95134c8bdcea71f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a polynomial mod a number.  <a href="polynomial_8h.html#ad67e8b256693afb95134c8bdcea71f89">More...</a><br /></td></tr>
<tr class="separator:ad67e8b256693afb95134c8bdcea71f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76265f19adf322b7cd06e174ef490fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#af76265f19adf322b7cd06e174ef490fd">fprint_poly</a> (FILE *file, const <a class="el" href="structpoly__t.html">poly_t</a> *f, const char *vname, const char *add, const char *sub, const char *pow, int descending)</td></tr>
<tr class="memdesc:af76265f19adf322b7cd06e174ef490fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a polynomial to a file.  <a href="polynomial_8h.html#af76265f19adf322b7cd06e174ef490fd">More...</a><br /></td></tr>
<tr class="separator:af76265f19adf322b7cd06e174ef490fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4092e751842766c3739d7c43226bee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#aaa4092e751842766c3739d7c43226bee">str_to_poly</a> (<a class="el" href="structpoly__t.html">poly_t</a> *f, int64_t *n, const char *str, const char **end)</td></tr>
<tr class="memdesc:aaa4092e751842766c3739d7c43226bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a polynomial (and possibly modulus)  <a href="polynomial_8h.html#aaa4092e751842766c3739d7c43226bee">More...</a><br /></td></tr>
<tr class="separator:aaa4092e751842766c3739d7c43226bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab430241bd078f4ab28f06e64dd935526"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#ab430241bd078f4ab28f06e64dd935526">rand_poly_modn</a> (<a class="el" href="structpoly__t.html">poly_t</a> *f, uint64_t max_len, int64_t n)</td></tr>
<tr class="memdesc:ab430241bd078f4ab28f06e64dd935526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random polynomial.  <a href="polynomial_8h.html#ab430241bd078f4ab28f06e64dd935526">More...</a><br /></td></tr>
<tr class="separator:ab430241bd078f4ab28f06e64dd935526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1338d410578bd4b6225494f8fc6dbc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#ac1338d410578bd4b6225494f8fc6dbc6">add_poly_modn</a> (<a class="el" href="structpoly__t.html">poly_t</a> *h, const <a class="el" href="structpoly__t.html">poly_t</a> *f, const <a class="el" href="structpoly__t.html">poly_t</a> *g, int64_t n)</td></tr>
<tr class="memdesc:ac1338d410578bd4b6225494f8fc6dbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add polynomials f + g mod n and store the result in h.  <a href="polynomial_8h.html#ac1338d410578bd4b6225494f8fc6dbc6">More...</a><br /></td></tr>
<tr class="separator:ac1338d410578bd4b6225494f8fc6dbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f5f895e0fabfc02f670aebd38fe9c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#ac2f5f895e0fabfc02f670aebd38fe9c1">sub_poly_modn</a> (<a class="el" href="structpoly__t.html">poly_t</a> *h, const <a class="el" href="structpoly__t.html">poly_t</a> *f, const <a class="el" href="structpoly__t.html">poly_t</a> *g, int64_t n)</td></tr>
<tr class="memdesc:ac2f5f895e0fabfc02f670aebd38fe9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract polynomials f - g mod n and store the result in h.  <a href="polynomial_8h.html#ac2f5f895e0fabfc02f670aebd38fe9c1">More...</a><br /></td></tr>
<tr class="separator:ac2f5f895e0fabfc02f670aebd38fe9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf6feb8398004536da3a7798cfc38a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#acdf6feb8398004536da3a7798cfc38a2">dot_poly_modn</a> (<a class="el" href="structpoly__t.html">poly_t</a> *h, const <a class="el" href="structpoly__t.html">poly_t</a> *f, const <a class="el" href="structpoly__t.html">poly_t</a> *g, int64_t n)</td></tr>
<tr class="memdesc:acdf6feb8398004536da3a7798cfc38a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the termwise product of polynomials f and g mod n and store the result in h.  <a href="polynomial_8h.html#acdf6feb8398004536da3a7798cfc38a2">More...</a><br /></td></tr>
<tr class="separator:acdf6feb8398004536da3a7798cfc38a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c199565663ad2afe5545af89862a20e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a9c199565663ad2afe5545af89862a20e">scale_poly_modn</a> (<a class="el" href="structpoly__t.html">poly_t</a> *g, const <a class="el" href="structpoly__t.html">poly_t</a> *f, int64_t a, int64_t n)</td></tr>
<tr class="memdesc:a9c199565663ad2afe5545af89862a20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a polynomial f by a scalar a and store the result in h.  <a href="polynomial_8h.html#a9c199565663ad2afe5545af89862a20e">More...</a><br /></td></tr>
<tr class="separator:a9c199565663ad2afe5545af89862a20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e708389fed41e77730f6a2325137c26"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a3e708389fed41e77730f6a2325137c26">mul_poly_modn</a> (<a class="el" href="structpoly__t.html">poly_t</a> *restrict h, const <a class="el" href="structpoly__t.html">poly_t</a> *f, const <a class="el" href="structpoly__t.html">poly_t</a> *g, int64_t n)</td></tr>
<tr class="memdesc:a3e708389fed41e77730f6a2325137c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply polynomials f*g mod n and store the result in h.  <a href="polynomial_8h.html#a3e708389fed41e77730f6a2325137c26">More...</a><br /></td></tr>
<tr class="separator:a3e708389fed41e77730f6a2325137c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac19f1e0aba417e5ab0c0e9eb09e733"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#aaac19f1e0aba417e5ab0c0e9eb09e733">pow_poly_modn</a> (<a class="el" href="structpoly__t.html">poly_t</a> *restrict g, const <a class="el" href="structpoly__t.html">poly_t</a> *f, uint64_t e, int64_t n, uint64_t cn, <a class="el" href="structpoly__t.html">poly_t</a> tmps[static 2])</td></tr>
<tr class="memdesc:aaac19f1e0aba417e5ab0c0e9eb09e733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise f**x mod n and store the result in g.  <a href="polynomial_8h.html#aaac19f1e0aba417e5ab0c0e9eb09e733">More...</a><br /></td></tr>
<tr class="separator:aaac19f1e0aba417e5ab0c0e9eb09e733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fdacf71dafef123812710ea492d403"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#ac2fdacf71dafef123812710ea492d403">pow_poly_modn_tmptmp</a> (<a class="el" href="structpoly__t.html">poly_t</a> *restrict g, const <a class="el" href="structpoly__t.html">poly_t</a> *f, uint64_t e, int64_t n, uint64_t cn)</td></tr>
<tr class="memdesc:ac2fdacf71dafef123812710ea492d403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise f**x mod n and store the result in g.  <a href="polynomial_8h.html#ac2fdacf71dafef123812710ea492d403">More...</a><br /></td></tr>
<tr class="separator:ac2fdacf71dafef123812710ea492d403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d088d0460ff8af443f3dd367a767563"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a1d088d0460ff8af443f3dd367a767563">compose_poly_modn</a> (<a class="el" href="structpoly__t.html">poly_t</a> *restrict h, const <a class="el" href="structpoly__t.html">poly_t</a> *f, const <a class="el" href="structpoly__t.html">poly_t</a> *g, int64_t n, uint64_t cn, <a class="el" href="structpoly__t.html">poly_t</a> tmps[static 2])</td></tr>
<tr class="memdesc:a1d088d0460ff8af443f3dd367a767563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose polynomial f(g(x)) mod n and store the result in h.  <a href="polynomial_8h.html#a1d088d0460ff8af443f3dd367a767563">More...</a><br /></td></tr>
<tr class="separator:a1d088d0460ff8af443f3dd367a767563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91028700dde9e550210e3cf02b5a8422"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a91028700dde9e550210e3cf02b5a8422">compose_poly_modn_tmptmp</a> (<a class="el" href="structpoly__t.html">poly_t</a> *restrict h, const <a class="el" href="structpoly__t.html">poly_t</a> *f, const <a class="el" href="structpoly__t.html">poly_t</a> *g, int64_t n, uint64_t cn)</td></tr>
<tr class="memdesc:a91028700dde9e550210e3cf02b5a8422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose polynomial f(g(x)) mod n and store the result in h.  <a href="polynomial_8h.html#a91028700dde9e550210e3cf02b5a8422">More...</a><br /></td></tr>
<tr class="separator:a91028700dde9e550210e3cf02b5a8422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad361b57fd06b102b19372d58496c2af9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#ad361b57fd06b102b19372d58496c2af9">quotrem_poly_modn</a> (<a class="el" href="structpoly__t.html">poly_t</a> *restrict q, <a class="el" href="structpoly__t.html">poly_t</a> *restrict r, const <a class="el" href="structpoly__t.html">poly_t</a> *restrict f, const <a class="el" href="structpoly__t.html">poly_t</a> *restrict g, int64_t n)</td></tr>
<tr class="memdesc:ad361b57fd06b102b19372d58496c2af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide two polynomials to get a quotient and remainder.  <a href="polynomial_8h.html#ad361b57fd06b102b19372d58496c2af9">More...</a><br /></td></tr>
<tr class="separator:ad361b57fd06b102b19372d58496c2af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0367653abc70dbb16442c2af3f0521a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#aa0367653abc70dbb16442c2af3f0521a">gcd_poly_modn</a> (<a class="el" href="structpoly__t.html">poly_t</a> *d, const <a class="el" href="structpoly__t.html">poly_t</a> *restrict f, const <a class="el" href="structpoly__t.html">poly_t</a> *restrict g, int64_t n, <a class="el" href="structpoly__t.html">poly_t</a> tmps[static 3])</td></tr>
<tr class="memdesc:aa0367653abc70dbb16442c2af3f0521a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the gcd of two polynomials.  <a href="polynomial_8h.html#aa0367653abc70dbb16442c2af3f0521a">More...</a><br /></td></tr>
<tr class="separator:aa0367653abc70dbb16442c2af3f0521a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21df0cb319b523d0ada902566dc46a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#aa21df0cb319b523d0ada902566dc46a3">gcd_poly_modn_tmptmp</a> (<a class="el" href="structpoly__t.html">poly_t</a> *d, const <a class="el" href="structpoly__t.html">poly_t</a> *restrict f, const <a class="el" href="structpoly__t.html">poly_t</a> *restrict g, int64_t n)</td></tr>
<tr class="memdesc:aa21df0cb319b523d0ada902566dc46a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the gcd of two polynomials.  <a href="polynomial_8h.html#aa21df0cb319b523d0ada902566dc46a3">More...</a><br /></td></tr>
<tr class="separator:aa21df0cb319b523d0ada902566dc46a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9997f17df7d049fb37fac0c1cc17e98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#ab9997f17df7d049fb37fac0c1cc17e98">powmod_poly_modn</a> (<a class="el" href="structpoly__t.html">poly_t</a> *h, const <a class="el" href="structpoly__t.html">poly_t</a> *restrict f, uint64_t e, const <a class="el" href="structpoly__t.html">poly_t</a> *restrict g, int64_t n, <a class="el" href="structpoly__t.html">poly_t</a> tmps[static 3])</td></tr>
<tr class="memdesc:ab9997f17df7d049fb37fac0c1cc17e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the power of a polynomial mod another polynomial.  <a href="polynomial_8h.html#ab9997f17df7d049fb37fac0c1cc17e98">More...</a><br /></td></tr>
<tr class="separator:ab9997f17df7d049fb37fac0c1cc17e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14744ac34129a1c97ec0ee2e0d2a9d97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a14744ac34129a1c97ec0ee2e0d2a9d97">powmod_poly_modn_tmptmp</a> (<a class="el" href="structpoly__t.html">poly_t</a> *h, const <a class="el" href="structpoly__t.html">poly_t</a> *restrict f, uint64_t e, const <a class="el" href="structpoly__t.html">poly_t</a> *restrict g, int64_t n)</td></tr>
<tr class="memdesc:a14744ac34129a1c97ec0ee2e0d2a9d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the power of a polynomial mod another polynomial.  <a href="polynomial_8h.html#a14744ac34129a1c97ec0ee2e0d2a9d97">More...</a><br /></td></tr>
<tr class="separator:a14744ac34129a1c97ec0ee2e0d2a9d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af8bba9147873e5df2cd7bb5c833e81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a3af8bba9147873e5df2cd7bb5c833e81">factors_d_poly_modn</a> (<a class="el" href="structpoly__t.html">poly_t</a> *f_d, const <a class="el" href="structpoly__t.html">poly_t</a> *f, uint64_t d, int64_t n, <a class="el" href="structpoly__t.html">poly_t</a> tmps[static 4])</td></tr>
<tr class="memdesc:a3af8bba9147873e5df2cd7bb5c833e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of all irreducible factors of degree d.  <a href="polynomial_8h.html#a3af8bba9147873e5df2cd7bb5c833e81">More...</a><br /></td></tr>
<tr class="separator:a3af8bba9147873e5df2cd7bb5c833e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f98cbd3d02406302a8824c1cdff982"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a87f98cbd3d02406302a8824c1cdff982">factor1_poly_modn</a> (<a class="el" href="structpoly__t.html">poly_t</a> *g, const <a class="el" href="structpoly__t.html">poly_t</a> *f, uint64_t d, int64_t n, <a class="el" href="structpoly__t.html">poly_t</a> tmps[static 4])</td></tr>
<tr class="memdesc:a87f98cbd3d02406302a8824c1cdff982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to find a divisor of f_d.  <a href="polynomial_8h.html#a87f98cbd3d02406302a8824c1cdff982">More...</a><br /></td></tr>
<tr class="separator:a87f98cbd3d02406302a8824c1cdff982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054b72254844b9bada1169f504cd290f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a054b72254844b9bada1169f504cd290f">roots_poly_modn</a> (const <a class="el" href="structpoly__t.html">poly_t</a> *f, int64_t n, <a class="el" href="structpoly__roots__t.html">poly_roots_t</a> *roots, <a class="el" href="structpoly__t.html">poly_t</a> tmps[static 6])</td></tr>
<tr class="memdesc:a054b72254844b9bada1169f504cd290f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all roots of a polynomial in an odd prime field.  <a href="polynomial_8h.html#a054b72254844b9bada1169f504cd290f">More...</a><br /></td></tr>
<tr class="separator:a054b72254844b9bada1169f504cd290f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4447d3bca8cc270b9ceba25708b347ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="polynomial_8h.html#a4447d3bca8cc270b9ceba25708b347ba">roots_poly_modn_tmptmp</a> (const <a class="el" href="structpoly__t.html">poly_t</a> *f, int64_t n, <a class="el" href="structpoly__roots__t.html">poly_roots_t</a> *roots)</td></tr>
<tr class="memdesc:a4447d3bca8cc270b9ceba25708b347ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all roots of a polynomial in an odd prime field.  <a href="polynomial_8h.html#a4447d3bca8cc270b9ceba25708b347ba">More...</a><br /></td></tr>
<tr class="separator:a4447d3bca8cc270b9ceba25708b347ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a608927f8b707837b8fcd315bcea00341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608927f8b707837b8fcd315bcea00341">&#9670;&nbsp;</a></span>init_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int init_poly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>reserve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a polynomial with at least a given capacity. </p>
<p>If the given capacity is 0, it defaults to 4. The polynomial is set to the zero polynomial. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>polynomial to initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reserve</td><td>initial capacity, defaults to 4 if 0 is given </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="a8b9bf7cc123816ef3e68640e17ca6f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9bf7cc123816ef3e68640e17ca6f81">&#9670;&nbsp;</a></span>destroy_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_poly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free resources held by a polynomial struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f</td><td>polynomial to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1346a0c296eb7dc64e7362c29dda6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1346a0c296eb7dc64e7362c29dda6e8">&#9670;&nbsp;</a></span>cmp_polys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cmp_polys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asymptotically compare polynomials. </p>
<p>Does not assume the inputs are normalized. Finds the highest degree term without matching coefficients. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>polynomials to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if a &lt; b, 1 if a &gt; b, 0 if a == b </dd></dl>

</div>
</div>
<a id="a0010cb7659c53c79e3ec3ada1809b978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0010cb7659c53c79e3ec3ada1809b978">&#9670;&nbsp;</a></span>init_poly_roots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int init_poly_roots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__roots__t.html">poly_roots_t</a> *&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>reserve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a root buffer with at least a given capacity. </p>
<p>If the given capacity is 0, it defaults to 4. The list will be empty (len=0). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">roots</td><td>root buffer to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reserve</td><td>initial capacity, defaults to 4 if 0 is given </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="ae501a32ed22a602c6da05679442e9ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae501a32ed22a602c6da05679442e9ab6">&#9670;&nbsp;</a></span>destroy_poly_roots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_poly_roots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__roots__t.html">poly_roots_t</a> *&#160;</td>
          <td class="paramname"><em>roots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free resources held by a root buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">roots</td><td>root buffer to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f47d92ef4f1a07f4ddf3d99f244abc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f47d92ef4f1a07f4ddf3d99f244abc1">&#9670;&nbsp;</a></span>ensure_poly_cap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ensure_poly_cap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extend the capacity of a polynomial struct if needed. </p>
<p>Generally called at the beginning of most functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f</td><td>polynomial to extend </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>minimum capacity the polynomial should have aferwards </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="a6dbd98a9607a1cbcddfe4d812550121b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dbd98a9607a1cbcddfe4d812550121b">&#9670;&nbsp;</a></span>zero_extend_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zero_extend_poly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extend the capacity of a polynomial struct if needed and set any new terms to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f</td><td>polynomial to extend </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length to extend poly to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="a57a86948d29f075bdb00c6a2d3870b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a86948d29f075bdb00c6a2d3870b09">&#9670;&nbsp;</a></span>ensure_poly_roots_cap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ensure_poly_roots_cap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__roots__t.html">poly_roots_t</a> *&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extend the capacity of a root buffer if needed. </p>
<p>Called by <a class="el" href="polynomial_8h.html#a054b72254844b9bada1169f504cd290f">roots_poly_modn</a> and <a class="el" href="polynomial_8h.html#a4447d3bca8cc270b9ceba25708b347ba">roots_poly_modn_tmptmp</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">roots</td><td>root buffer to extend </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>minimum capacity the root buffer should have aferwards </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="ace328b1c13ce42b4407116b48db24876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace328b1c13ce42b4407116b48db24876">&#9670;&nbsp;</a></span>normalize_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void normalize_poly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strip off terms so the leading term is nonzero if needed. </p>
<p>Generally called at the end of most functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f</td><td>polynomial to normalize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a098b5a4655e573b5151be13bac6cb254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098b5a4655e573b5151be13bac6cb254">&#9670;&nbsp;</a></span>normalize_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void normalize_poly_modn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_negatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce coefficients mod n, then normalize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f</td><td>polynomial to normalize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce coefficients by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_negatives</td><td>if false, coefficients will be in the range [0,n), otherwise [(1-n)/2,n/2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0dd0ce039c8ce903e7e40aef587f93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dd0ce039c8ce903e7e40aef587f93e">&#9670;&nbsp;</a></span>normalize_exponents_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void normalize_exponents_modn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce any exponents over cn. </p>
<p>Generally called by functions that take a cn (carmichael lambda function of n) argument Remove any term x**(k*cn + a) where 0 &lt; a &lt;= cn and add its coefficient to term x**a </p>

</div>
</div>
<a id="a4e779775e04d83955296bdda258fc44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e779775e04d83955296bdda258fc44a">&#9670;&nbsp;</a></span>copy_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int copy_poly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="a388a67e34664ce74e3890bec295e907d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388a67e34664ce74e3890bec295e907d">&#9670;&nbsp;</a></span>const_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int const_poly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a polynomial to a constant (linear terms and up zero). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>polynomial to set to constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>constant to set polynomial to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="ad67e8b256693afb95134c8bdcea71f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67e8b256693afb95134c8bdcea71f89">&#9670;&nbsp;</a></span>eval_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t eval_poly_modn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a polynomial mod a number. </p>
<p>Uses a Horner scheme with modulus taken after every multiply/add step. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>polynomial to evaluate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>point at which to evaluate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus for the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f(x) mod n </dd></dl>

</div>
</div>
<a id="af76265f19adf322b7cd06e174ef490fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76265f19adf322b7cd06e174ef490fd">&#9670;&nbsp;</a></span>fprint_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fprint_poly </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>descending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a polynomial to a file. </p>
<p>Skips zero terms, coefficients of 1 or -1, powers of 0 or 1, and any leading plus sign. Thus the the format is "x^2 + 2x + 1". The zero polynomial is displayed as "0", and a leading negative sign is always displayed as "-" with no trailing space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td>file to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>polynomial to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vname</td><td>string to use for variable, eg "x" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>string to use for adding two monomials together, eg "+" or " + " </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub</td><td>string to use for subtracting two monomials, eg "-" or " - " </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pow</td><td>string to use for exponents, eg "**" for "x**2" or "^" for "x^2" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descending</td><td>if true, print higher terms down to lower terms, otherwise print lower terms up to higher terms (Taylor Series order) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of characters printed </dd></dl>

</div>
</div>
<a id="aaa4092e751842766c3739d7c43226bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4092e751842766c3739d7c43226bee">&#9670;&nbsp;</a></span>str_to_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int str_to_poly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to a polynomial (and possibly modulus) </p>
<p>Ignores whitespace, ignores variable names, allows multiplication signs, duplicate terms, and duplicate minus signs. The format is poly = monomial (+|- monomial)* ("mod" \d+)? monomial = -* ((coeff *? vpow) | coeff | vpow) coeff = \d+ vpow = \w (("**"|"^") \d+)? </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>polynomial to store output in </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>pointer to store modulus n in if found </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to parse </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">end</td><td>pointer to store end of parsed content (first unparsed character, ie typically '\0') </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on failure, 1 if polynomial was parsed without modulus, 2 if both polynomial and modulus were parsed </dd></dl>

</div>
</div>
<a id="ab430241bd078f4ab28f06e64dd935526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab430241bd078f4ab28f06e64dd935526">&#9670;&nbsp;</a></span>rand_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rand_poly_modn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random polynomial. </p>
<p>Coefficients are integers chosen uniformly on [0,n). max_len are chosen and then the polynomial is normalized (<a class="el" href="polynomial_8h.html#ace328b1c13ce42b4407116b48db24876">normalize_poly</a>). So max_len minus the actual length has bounded geometric distribution with success probability 1/n. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>polynomial to randomize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_len</td><td>number of coefficients to generate before normalizing. If 0, the output polynomial is always set to zero </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus for coefficients </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on succes, 0 on failure </dd></dl>

</div>
</div>
<a id="ac1338d410578bd4b6225494f8fc6dbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1338d410578bd4b6225494f8fc6dbc6">&#9670;&nbsp;</a></span>add_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int add_poly_modn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add polynomials f + g mod n and store the result in h. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store the sum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="ac2f5f895e0fabfc02f670aebd38fe9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f5f895e0fabfc02f670aebd38fe9c1">&#9670;&nbsp;</a></span>sub_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sub_poly_modn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract polynomials f - g mod n and store the result in h. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store the difference f - g mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to subtract </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="acdf6feb8398004536da3a7798cfc38a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf6feb8398004536da3a7798cfc38a2">&#9670;&nbsp;</a></span>dot_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dot_poly_modn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the termwise product of polynomials f and g mod n and store the result in h. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to multiply termwise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="a9c199565663ad2afe5545af89862a20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c199565663ad2afe5545af89862a20e">&#9670;&nbsp;</a></span>scale_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int scale_poly_modn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a polynomial f by a scalar a and store the result in h. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>polynomial in which to store a*f mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>polynomial to multiply by a scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>scalar to multiply by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="a3e708389fed41e77730f6a2325137c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e708389fed41e77730f6a2325137c26">&#9670;&nbsp;</a></span>mul_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mul_poly_modn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply polynomials f*g mod n and store the result in h. </p>
<p>Uses the basic algorithm </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store f*g mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to multiply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="aaac19f1e0aba417e5ab0c0e9eb09e733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac19f1e0aba417e5ab0c0e9eb09e733">&#9670;&nbsp;</a></span>pow_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pow_poly_modn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a>&#160;</td>
          <td class="paramname"><em>tmps</em>[static 2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raise f**x mod n and store the result in g. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>polynomial in which to store f**x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>polynomial to find a power of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>exponent to raise f to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cn</td><td>carmichael lambda function of n, basically modulus for exponents, see <a class="el" href="factorization_8h.html#a25a68da474286694c8abd6c37e26425f">carmichael_lambda</a> and <a class="el" href="sieves_8h.html#ae19a3c1887d6cdc9375c32f0abfd2ab3">sieve_carmichael</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmps</td><td>polynomial for scratch work, must have 1 initialized (or at least zeroed out) polynomial (<a class="el" href="polynomial_8h.html#ac2fdacf71dafef123812710ea492d403">pow_poly_modn_tmptmp</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="ac2fdacf71dafef123812710ea492d403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fdacf71dafef123812710ea492d403">&#9670;&nbsp;</a></span>pow_poly_modn_tmptmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pow_poly_modn_tmptmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raise f**x mod n and store the result in g. </p>
<p>Like <a class="el" href="polynomial_8h.html#aaac19f1e0aba417e5ab0c0e9eb09e733">pow_poly_modn</a> except temporary polynomials are allocated and freed internally instead of using supplied temporaries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>polynomial in which to store f**x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>polynomial to find a power of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>exponent to raise f to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cn</td><td>carmichael lambda function of n, basically modulus for exponents, see <a class="el" href="factorization_8h.html#a25a68da474286694c8abd6c37e26425f">carmichael_lambda</a> and <a class="el" href="sieves_8h.html#ae19a3c1887d6cdc9375c32f0abfd2ab3">sieve_carmichael</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="a1d088d0460ff8af443f3dd367a767563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d088d0460ff8af443f3dd367a767563">&#9670;&nbsp;</a></span>compose_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compose_poly_modn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a>&#160;</td>
          <td class="paramname"><em>tmps</em>[static 2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose polynomial f(g(x)) mod n and store the result in h. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store f(g(x)) mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to compose </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cn</td><td>carmichael lambda function of n, basically modulus for exponents, see <a class="el" href="factorization_8h.html#a25a68da474286694c8abd6c37e26425f">carmichael_lambda</a> and <a class="el" href="sieves_8h.html#ae19a3c1887d6cdc9375c32f0abfd2ab3">sieve_carmichael</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmps</td><td>polynomial for scratch work, must have 1 initialized (or at least zeroed out) polynomial (<a class="el" href="polynomial_8h.html#a91028700dde9e550210e3cf02b5a8422">compose_poly_modn_tmptmp</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="a91028700dde9e550210e3cf02b5a8422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91028700dde9e550210e3cf02b5a8422">&#9670;&nbsp;</a></span>compose_poly_modn_tmptmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compose_poly_modn_tmptmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose polynomial f(g(x)) mod n and store the result in h. </p>
<p>Like <a class="el" href="polynomial_8h.html#a1d088d0460ff8af443f3dd367a767563">compose_poly_modn</a> except temporary polynomials are allocated and freed internally instead of using supplied temporaries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store f(g(x)) mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to compose </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cn</td><td>carmichael lambda function of n, basically modulus for exponents, see <a class="el" href="factorization_8h.html#a25a68da474286694c8abd6c37e26425f">carmichael_lambda</a> and <a class="el" href="sieves_8h.html#ae19a3c1887d6cdc9375c32f0abfd2ab3">sieve_carmichael</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="ad361b57fd06b102b19372d58496c2af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad361b57fd06b102b19372d58496c2af9">&#9670;&nbsp;</a></span>quotrem_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int quotrem_poly_modn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide two polynomials to get a quotient and remainder. </p>
<p>f = q*g + r mod n. Uses extended synthetic division. Note that while weaker forms of polynomial division can be defined for weaker forms of rings than fields, the synthetic division algorithm can fail if the coefficient ring is not a field because division by the leading coefficient might fail. Even if n is composite, if the leading coefficient of the divisor is 1 then this algorithm will not fail, otherwise, this function fails. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">q,r</td><td>polynomials in which to store the quotient and remainder such that f = q*g + r mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to divide </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus to reduce result by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure. Can fail if the leading cofficient of g is not invertable mod n, as well as on allocation failure </dd></dl>

</div>
</div>
<a id="aa0367653abc70dbb16442c2af3f0521a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0367653abc70dbb16442c2af3f0521a">&#9670;&nbsp;</a></span>gcd_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gcd_poly_modn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a>&#160;</td>
          <td class="paramname"><em>tmps</em>[static 3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the gcd of two polynomials. </p>
<p>The gcd is reduced to be monic, so if n is not prime this can fail. If d = gcd(f, g), then there is some pair of polynomials a and b so that f = ad and g = bd (d is a common divisor), and for any other common divisor h, d = ch for some polynomial c (d is greatest because it has at least as high degree as any other common divisor. Note that in the integers, we have two choices for gcd, which are associates (meaning one is the negative of the other) and we pick the positive one by convention. Similarly for polynomials with coefficients from a field, the the gcd is not unique and any associate of the gcd is also a gcd. Thus we restrict the gcd to be monic. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>polynomial in which to store the monic gcd, or store 0 if both f and n are 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to take the gcd of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus for the coefficient ring </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmps</td><td>polynomials for scratch work, cannot be NULL (<a class="el" href="polynomial_8h.html#aa21df0cb319b523d0ada902566dc46a3">gcd_poly_modn_tmptmp</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure. Can fail if a non-invertable leading coefficient is encountered, as well as on allocation failure. </dd></dl>

</div>
</div>
<a id="aa21df0cb319b523d0ada902566dc46a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21df0cb319b523d0ada902566dc46a3">&#9670;&nbsp;</a></span>gcd_poly_modn_tmptmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gcd_poly_modn_tmptmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the gcd of two polynomials. </p>
<p>Like <a class="el" href="polynomial_8h.html#aa0367653abc70dbb16442c2af3f0521a">gcd_poly_modn</a> except temporary polynomials are allocated and freed internally instead of using supplied temporaries. Less efficient because early checking is not done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>polynomial in which to store the monic gcd, or store 0 if both f and n are 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f,g</td><td>polynomials to take the gcd of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus for the coefficient ring </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure. Can fail if a non-invertable leading coefficient is encountered, as well as on allocation failure. </dd></dl>

</div>
</div>
<a id="ab9997f17df7d049fb37fac0c1cc17e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9997f17df7d049fb37fac0c1cc17e98">&#9670;&nbsp;</a></span>powmod_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int powmod_poly_modn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a>&#160;</td>
          <td class="paramname"><em>tmps</em>[static 3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the power of a polynomial mod another polynomial. </p>
<p>Uses binary exponentiation. The coefficients themselves are in the cyclic group Z_n as usual. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>base </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>exponent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>coefficient modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmps</td><td>polynomials for scratch work, must have 3 initialized (or at least zeroed out) polynomials (<a class="el" href="polynomial_8h.html#a14744ac34129a1c97ec0ee2e0d2a9d97">powmod_poly_modn_tmptmp</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure. Can fail if a non-invertable leading coefficient is encountered, as well as on allocation failure. </dd></dl>

</div>
</div>
<a id="a14744ac34129a1c97ec0ee2e0d2a9d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14744ac34129a1c97ec0ee2e0d2a9d97">&#9670;&nbsp;</a></span>powmod_poly_modn_tmptmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int powmod_poly_modn_tmptmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *restrict&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the power of a polynomial mod another polynomial. </p>
<p>Like <a class="el" href="polynomial_8h.html#ab9997f17df7d049fb37fac0c1cc17e98">powmod_poly_modn</a> except temporary polynomials are allocated and freed internally instead of using supplied temporaries. Less efficient because early checking is not done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>polynomial in which to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>base </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>exponent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>modulus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>coefficient modulus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure. Can fail if a non-invertable leading coefficient is encountered, as well as on allocation failure. </dd></dl>

</div>
</div>
<a id="a3af8bba9147873e5df2cd7bb5c833e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af8bba9147873e5df2cd7bb5c833e81">&#9670;&nbsp;</a></span>factors_d_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int factors_d_poly_modn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a>&#160;</td>
          <td class="paramname"><em>tmps</em>[static 4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the product of all irreducible factors of degree d. </p>
<p>This should be called repeatedly on squarefree factors, or else it will extract repeat factors for d &gt; 1. Thus if we only want roots in the field Z_p, or equivalently we only want linear factors, we can call this function without bothering to make f squarefree first. If f is already squarefree, let f_i be the product of all irreducible factors of f with degree i. Then we have f_1 = gcd(x^p-x, f), f_2 = gcd(x^(p^2), f/f_1), f_3 = gcd(x^(p^3), f/f_1/f_2), etc. Once the expression f/f_1/f_2/.../f_i becomes 1, we are done. This clearly takes at most k steps, where k is the degree of f. It is possible to show an irreducible f is irreducible by only showing it has no factors of degree k/q for any prime divisor q, ie f | x^(p^k) but gcd(f, x^(p^(k/q))) = 1 for all q. This function only takes care of computing gcd(x^(p^d)-x, f/f_1/.../f_(d-1)) given p, d, and f/f_1/.../f_(d-1). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f_d</td><td>the product of all degree d irreducible factors of f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the polynomial to factor, which should be squarefree and have no irreducible factors with degree less than d </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>the degree of irreducible factors to extract. Note that f should be free from irreducible factors with lower degree, so once d exceeds half the degree of f, f must be irreducible. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>coefficient modulus. MUST be prime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmps</td><td>polynomials for scratch work, must have 4 initialized (or at least zeroed out) polynomials </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="a87f98cbd3d02406302a8824c1cdff982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f98cbd3d02406302a8824c1cdff982">&#9670;&nbsp;</a></span>factor1_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int factor1_poly_modn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a>&#160;</td>
          <td class="paramname"><em>tmps</em>[static 4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to find a divisor of f_d. </p>
<p>Given a squarefree polynomial f whose irreducible factors all have degree d, if f has degree k which is greater than d (it must be a multiple of d) it must split. Mod an odd prime p, we can find a nontrivial factor of f by 1) choosing a random r with degree less than k (if gcd(r, f) isn't 1 we are done), 2) computing s = r^((p^d-1)/2) mod f, 3) gcd(s + 1, f) is a nontrivial factor with probability greater than 1/2. This works because not only does x^(p^d)-x factor as x(x^((p^d-1)/2)-1)(x^((p^d-1)/2)+1), this holds if we replace x with any polynomial. If a factor isn't contained in the first term, it has about a 1/2 chance of being contained in the second term, hence this algorithm. This function returns a single nontrivial factor g, and both g and f/g may need to be factored further if they are not degree d. Note that if f is degree 2 with irreducible factors of degree 1, completing the square/using the quadratic formula is faster, although for such small polynomials this is unimportant. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>a nontrivial factor of f. Both g and f/g could potentially need to be factored further with more calls to this method. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the polynomial to factor, which should be squarefree and have multiple irreducible factors of degree d </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>the degree of irreducible factors of f </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>coefficient modulus. MUST be prime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmps</td><td>polynomials for scratch work, must have 4 initialized (or at least zeroed out) polynomials </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="a054b72254844b9bada1169f504cd290f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054b72254844b9bada1169f504cd290f">&#9670;&nbsp;</a></span>roots_poly_modn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int roots_poly_modn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoly__roots__t.html">poly_roots_t</a> *&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoly__t.html">poly_t</a>&#160;</td>
          <td class="paramname"><em>tmps</em>[static 6]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all roots of a polynomial in an odd prime field. </p>
<p>Uses the Cantor-Zassenhaus algorithm, specialized for linear factors (so we can skip squarefree factorization). This is implemented in the functions <a class="el" href="polynomial_8h.html#a3af8bba9147873e5df2cd7bb5c833e81">factors_d_poly_modn</a> and <a class="el" href="polynomial_8h.html#a87f98cbd3d02406302a8824c1cdff982">factor1_poly_modn</a>. After the first function, we know how many roots there are and allocate a buffer. The second function is called as many times as needed to find all the roots. TODO: optimize factoring quadratics using quadratic formula. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>polynomial to find roots of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus of the coefficient field. MUST be prime. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">roots</td><td>store roots here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmps</td><td>polynomials for scratch work, must have 6 initialized (or at least zeroed out) polynomials (<a class="el" href="polynomial_8h.html#a4447d3bca8cc270b9ceba25708b347ba">roots_poly_modn_tmptmp</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success (including if the polynomial has 0 roots), 0 on failure. </dd></dl>

</div>
</div>
<a id="a4447d3bca8cc270b9ceba25708b347ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4447d3bca8cc270b9ceba25708b347ba">&#9670;&nbsp;</a></span>roots_poly_modn_tmptmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int roots_poly_modn_tmptmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpoly__t.html">poly_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoly__roots__t.html">poly_roots_t</a> *&#160;</td>
          <td class="paramname"><em>roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all roots of a polynomial in an odd prime field. </p>
<p>Like <a class="el" href="polynomial_8h.html#a054b72254844b9bada1169f504cd290f">roots_poly_modn</a> except temporary polynomials are allocated and freed internally instead of using supplied temporaries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>polynomial to find roots of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>modulus of the coefficient field. MUST be prime. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">roots</td><td>store roots here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success (including if the polynomial has 0 roots), 0 on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_073faa820624379b5730e5b4f5cb1c42.html">nut</a></li><li class="navelem"><a class="el" href="polynomial_8h.html">polynomial.h</a></li>
    <li class="footer">Generated on Sat Mar 4 2023 20:46:53 for Number Theory Utils by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
