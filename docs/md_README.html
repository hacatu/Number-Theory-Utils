<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Number Theory Utils: Number Theory Utils (NUT)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Number Theory Utils
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Number Theory Utils (NUT) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://ci.appveyor.com/project/hacatu/number-theory-utils"><img src="https://ci.appveyor.com/api/projects/status/0uctn18i9nl5pmuj?svg=true" alt="Build status" class="inline"/></a></p>
<p>A collection of functions for working modular arithmetic, polynomials over finite fields, and related things.</p>
<p>Implements factorization of 64 bit numbers using trial division, Pollard's Rho algorithm with Brent or Floyd cycle finding, and Lenstra's Elliptic Curve algorithm with Wierstrass or Montgomery curves. Planned support for arbitrary precision integers and Kraitcheck style methods (ie quadratic sieve and number field sieve), although Flint and its extension library Arb may be more suited for your needs.</p>
<p>For polynomials, implements finding roots of a polynomial over a prime field using the Cantor-Zassenhaus algorithm.</p>
<p>Also includes general purpose modular arithmetic routines, including powers, Miller-Rabin prime checking, random numbers, random quadratic nonresidues, Jacobi symbols, modular square root including Tonelli-Shanks and Cippola, extended gcd, Chinese remainder theorem, and Euclidean remainder.</p>
<p>For polynomials, also includes arithmetic (addition, subtraction, scalar multiplication, coefficientwise multiplication, multiplication, quotient and remainder, Horner evaluation, gcd, and powers), printing/normalization, and distinct degree factorization. Currently there is a simple driver function that will find all roots of a polynomial over a prime field, but if a full factorization is desired the squarefree step must still be done manually. Like the factorization part of the library, polynomials use 64 bit integers, so computations involving numbers larger than about 2<sup>30</sup> potentially can fail due to overflow.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Building</h1>
<p>This library uses variant makefiles for each build type. To build the debug variant, simply run <code>make</code> in the project root directory. The resulting files will be in <code>build/debug/lib</code> and <code>build/debug/bin</code>.</p>
<p>To build a different variant, change the <code></code> variable from <code>build/debug</code> to <code>build/release</code> or some other value, for instance <code>make BUILD_ROOT="build/release"</code>. You can check what variants exist by looking at the subdirectories of <code>build</code>, and you can create your own by copying and modifying <code>build/debug</code>.</p>
<p>The files in a variant build directory are arranged as follows: <code>Makefile</code> is the makefile, variants probably won't have to modify this much aside from removing coverage information; <code>cflags.txt</code>, <code>ldflags.txt</code>, and <code>makedeps_cflags.txt</code> contain configuration flags that should be passed to the compiler and linker. Flag files are used to consolidate compiler flags, reduce how often the makefile needs to be tweaked, and clean up build logs.</p>
<p>Based on the source files in <code>include</code> and <code>src</code>, together with the configuration in a variant build directory, output files are produced in the following subdirectories of <code></code>: <code>bin</code> for executables, <code>bin/test</code> for test executables, <code>lib</code> for static and dynamic libraries, <code>obj</code> for object files and dependency files, <code>notes</code> for coverage information, <code>log</code> for test logs, and <code>cov</code> for human readable coverage reports.</p>
<p>Executables, static libraries, and test executables are automatically created based on the contents of <code>src</code>: every C file or directory in <code>src/bin</code> is turned into its own executable in <code>/bin</code>, every C file or directory in <code>src/lib</code> is turned into its own static library in <code>/lib</code>, and every C file or directory in <code>src/test</code> is turned into its own test executable in <code>/bin/test</code>.</p>
<p>To run tests, simply run <code>make test</code> (or <code>make BUILD_ROOT=build/release test</code>). For build variants where coverage testing should be done, <code>make coverage</code> is better since both will re-run all tests every time.</p>
<p><code>make clean</code> should remove all output files in all variant build directories, as well as all generated documentation.</p>
<p>Finally, <code>make docs</code> generates the documentation in the <code>docs</code> directory. Like <code>make clean</code>, this is not tied to a build variant and even if you specify one the same thing will happen.</p>
<p><code>make debug_makefile</code> simply exists to facillitate printing make variables, don't worry about it.</p>
<p>Only Linux is properly supported. To build, only <code>gcc</code>, <code>ar</code>, and <code>make</code> are strictly required, but <code>lcov</code> and <code>doxygen</code> are required for coverage and documentation, and <code>lld</code> is specified as the linker by default. If you do not have <code>lld</code>, you can switch the line <code>-fuse-ld=lld</code> to <code>-fuse-ld=gold</code> or remove it in <code>/ldflags.txt</code>.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Linking</h1>
<p>Once the library has been built, it can be linked with C programs by adding the flags <code>-Lbuild/debug -lnut</code> or <code>-L -lnut</code> to use a different variant build. If you're feeling dangerous, you can install it to your system libraries by doing <code>sudo cp build/debug/lib/libnut.a /usr/lib/</code> or <code>sudo cp /lib/libnut.a /usr/lib</code>. Then the <code>-L</code> flag can be omitted and the library can be linked with simply <code>-lnut</code>.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md4"></a>
Solve a quadratic equation mod some primes</h2>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(uint64_t i = 0; i &lt; 100; ++i){</div>
<div class="line">    int64_t p = rand_u64(2, 1ull &lt;&lt; 30);</div>
<div class="line">    <span class="keywordflow">while</span>(!is_prime_dmr(p)){</div>
<div class="line">        ++p;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">//Want to solve n**2 - n + 1 == 0 mod p</span></div>
<div class="line">    <span class="comment">//&lt;=&gt; 4*n**2 - 4*n + 4 == 0 mod p</span></div>
<div class="line">    <span class="comment">//&lt;=&gt; (2*n - 1)**2 == -3 mod p</span></div>
<div class="line">    <span class="comment">//&lt;=&gt; n == 2**-1*(1 +- sqrt(-3)) mod p</span></div>
<div class="line">    <span class="keywordflow">switch</span>(jacobi(p - 3, p)){</div>
<div class="line">        <span class="keywordflow">case</span> -1:</div>
<div class="line">            printf(<span class="stringliteral">&quot;n**2 - n + 1 has no roots mod %&quot;</span>PRId64<span class="stringliteral">&quot;\n&quot;</span>, p);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> 0:<span class="comment">//-3 is a multiple of p, ie p == 3 so we only have 1 solution</span></div>
<div class="line">            printf(<span class="stringliteral">&quot;n**2 - n + 1 has a root at %&quot;</span>PRId64<span class="stringliteral">&quot; mod %&quot;</span>PRId64<span class="stringliteral">&quot;\n&quot;</span>, (p + 1)/2, p);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            <span class="comment">//WARNING: here we know p - 3 is a quadratic residue, but sqrt_mod does not check this and thus if a nonresidue is given and</span></div>
<div class="line">            <span class="comment">//Tonelli-Shanks is selected as the optimal algorithm for this p, this would be an infinite loop</span></div>
<div class="line">            int64_t r = sqrt_mod(p - 3, p);</div>
<div class="line">            printf(<span class="stringliteral">&quot;n**2 - n + 1 has roots at %&quot;</span>PRId64<span class="stringliteral">&quot; and %&quot;</span>PRId64<span class="stringliteral">&quot; mod %&quot;</span>PRId64<span class="stringliteral">&quot;\n&quot;</span>, mod((p + 1)/2*(1 + r), p), mod((p + 1)/2*(1 - r), p), p);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
Factor some numbers</h2>
<div class="fragment"><div class="line">factor_conf_t factor_conf = {</div>
<div class="line">    .pollard_max= 100000,    <span class="comment">//maximum number to use Pollard&#39;s Rho algorithm for</span></div>
<div class="line">    .pollard_stride= 10,     <span class="comment">//number of gcd operations to coalesce, decreases time for a single iteration at the cost of potentially doing twice this many extra iterations</span></div>
<div class="line">    .lenstra_max= UINT64_MAX,<span class="comment">//maximum number to use Lenstra&#39;s Elliptic Curve algorithm for</span></div>
<div class="line">    .lenstra_bfac= 10        <span class="comment">//roughly speaking, the number of iterations to try before picking a new random point and curve</span></div>
<div class="line">};</div>
<div class="line">factors_t *factors = init_factors_t_w(MAX_PRIMES_64);</div>
<div class="line"><span class="keywordflow">for</span>(uint64_t i = 0; i &lt; 100; ++i){</div>
<div class="line">    uint64_t n = rand_u64(2, 1ull &lt;&lt; 30);</div>
<div class="line">    <span class="comment">//factor_heuristic will check if the input and intermediate factors are prime</span></div>
<div class="line">    <span class="comment">//it returns the input n divided by all factors found, ie if n is factored completely it returns 1,</span></div>
<div class="line">    <span class="comment">//and it should not return &gt; 1 unless n is greater than all the *_max fields in factor_conf and composite.</span></div>
<div class="line">    <span class="comment">//the primes and num_primes arguments here are null because primes for trial division must be generated by</span></div>
<div class="line">    <span class="comment">//some other function</span></div>
<div class="line">    <span class="keywordflow">if</span>(factor_heuristic(n, 0, NULL, &amp;factor_conf, &amp;factors) != 1){</div>
<div class="line">        printf(<span class="stringliteral">&quot;Failed to factor %&quot;</span>PRIu64<span class="stringliteral">&quot;!\n&quot;</span>, n);</div>
<div class="line">    }<span class="keywordflow">else</span>{</div>
<div class="line">        printf(<span class="stringliteral">&quot;%&quot;</span>PRIu64<span class="stringliteral">&quot; = &quot;</span>, n);</div>
<div class="line">        factors_fprintf(stdout, factors);</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line">free(factors);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Factor a polynomial mod some primes</h2>
<div class="fragment"><div class="line">poly_t f[1];</div>
<div class="line">init_poly(f, 9);</div>
<div class="line"> </div>
<div class="line">f-&gt;coeffs[0] = 1;</div>
<div class="line">f-&gt;coeffs[1] = 1;</div>
<div class="line">f-&gt;coeffs[2] = 0;</div>
<div class="line">f-&gt;coeffs[3] = -1;</div>
<div class="line">f-&gt;coeffs[4] = -1;</div>
<div class="line">f-&gt;coeffs[5] = -1;</div>
<div class="line">f-&gt;coeffs[6] = 0;</div>
<div class="line">f-&gt;coeffs[7] = 1;</div>
<div class="line">f-&gt;coeffs[8] = 1;</div>
<div class="line">f-&gt;len = 9;</div>
<div class="line"> </div>
<div class="line">fprintf(stderr, <span class="stringliteral">&quot;\e[1;34mComputing roots of (&quot;</span>);</div>
<div class="line">fprint_poly(stderr, f, <span class="stringliteral">&quot;x&quot;</span>, <span class="stringliteral">&quot; + &quot;</span>, <span class="stringliteral">&quot; - &quot;</span>, <span class="stringliteral">&quot;**&quot;</span>, 1);</div>
<div class="line">fprintf(stderr, <span class="stringliteral">&quot;) mod p for %&quot;</span>PRIu64<span class="stringliteral">&quot; random primes...\e[0m\n&quot;</span>, trials);</div>
<div class="line"> </div>
<div class="line">poly_roots_t roots[1];</div>
<div class="line">init_poly_roots(roots, 8);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(uint64_t i = 0; i &lt; 50; ++i){</div>
<div class="line">    int64_t p = rand_u64(2, 1ull &lt;&lt; 30);</div>
<div class="line">    <span class="keywordflow">while</span>(!is_prime_dmr(p)){</div>
<div class="line">        ++p;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span>(!roots_poly_modn_tmptmp(f, p, roots)){</div>
<div class="line">        printf(<span class="stringliteral">&quot;Failed to factor (&quot;</span>);</div>
<div class="line">        fprint_poly(stdout, f, <span class="stringliteral">&quot;x&quot;</span>, <span class="stringliteral">&quot; + &quot;</span>, <span class="stringliteral">&quot; - &quot;</span>, <span class="stringliteral">&quot;**&quot;</span>, 1);</div>
<div class="line">        printf(<span class="stringliteral">&quot;) mod %&quot;</span>PRId64<span class="stringliteral">&quot;\n&quot;</span>, p)</div>
<div class="line">        <span class="keywordflow">continue</span>;</div>
<div class="line">    }</div>
<div class="line">    printf(<span class="stringliteral">&quot;Found %&quot;</span>PRIu64<span class="stringliteral">&quot; roots of (&quot;</span>, roots-&gt;len);</div>
<div class="line">    fprint_poly(stdout, f, <span class="stringliteral">&quot;x&quot;</span>, <span class="stringliteral">&quot; + &quot;</span>, <span class="stringliteral">&quot; - &quot;</span>, <span class="stringliteral">&quot;**&quot;</span>, 1);</div>
<div class="line">    printf(<span class="stringliteral">&quot;) mod %&quot;</span>PRId64, p);</div>
<div class="line">    <span class="keywordflow">if</span>(roots-&gt;len){</div>
<div class="line">        printf(<span class="stringliteral">&quot;: &quot;</span>);</div>
<div class="line">    }<span class="keywordflow">else</span>{</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span>(uint64_t i = 0; i &lt; roots-&gt;len; ++i){</div>
<div class="line">        printf();</div>
<div class="line">        <span class="keywordflow">if</span>(i != roots-&gt;len - 1){</div>
<div class="line">            printf(<span class="stringliteral">&quot;%&quot;</span>PRId64<span class="stringliteral">&quot;, &quot;</span>, roots-&gt;roots[i]);</div>
<div class="line">        }<span class="keywordflow">else</span>{</div>
<div class="line">            printf(<span class="stringliteral">&quot;and %&quot;</span>PRId64<span class="stringliteral">&quot;\n&quot;</span>, roots-&gt;roots[i]);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line">destroy_poly_roots(roots);</div>
<div class="line">destroy_poly(f);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
