<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Number Theory Utils: include/hash.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Number Theory Utils
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hash.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;inttypes.h&gt;</code><br />
</div>
<p><a href="hash_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhashtbl__t.html">hashtbl_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash table.  <a href="structhashtbl__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhashtbl__ft.html">hashtbl_ft</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function table for hash table.  <a href="structhashtbl__ft.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af43716c1dafc1120cba882b2b35cf02d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash_8h.html#af43716c1dafc1120cba882b2b35cf02d">hash_init</a> (<a class="el" href="structhashtbl__t.html">hashtbl_t</a> *, const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *, size_t reserve)</td></tr>
<tr class="memdesc:af43716c1dafc1120cba882b2b35cf02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a hash table.  <a href="hash_8h.html#af43716c1dafc1120cba882b2b35cf02d">More...</a><br /></td></tr>
<tr class="separator:af43716c1dafc1120cba882b2b35cf02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077f1d34d4355de9a652cd7cf77208f4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash_8h.html#a077f1d34d4355de9a652cd7cf77208f4">hash_get</a> (<a class="el" href="structhashtbl__t.html">hashtbl_t</a> *, const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *, const void *key)</td></tr>
<tr class="memdesc:a077f1d34d4355de9a652cd7cf77208f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to an entry in the hash table.  <a href="hash_8h.html#a077f1d34d4355de9a652cd7cf77208f4">More...</a><br /></td></tr>
<tr class="separator:a077f1d34d4355de9a652cd7cf77208f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c19e7135b43188e3f950d3a4296bfa5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash_8h.html#a8c19e7135b43188e3f950d3a4296bfa5">hash_insert</a> (<a class="el" href="structhashtbl__t.html">hashtbl_t</a> *, const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *, const void *key, int *status)</td></tr>
<tr class="memdesc:a8c19e7135b43188e3f950d3a4296bfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element into the hash table.  <a href="hash_8h.html#a8c19e7135b43188e3f950d3a4296bfa5">More...</a><br /></td></tr>
<tr class="separator:a8c19e7135b43188e3f950d3a4296bfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c944178b1573faca22dc7bfd6d856e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash_8h.html#ab8c944178b1573faca22dc7bfd6d856e">hash_append</a> (<a class="el" href="structhashtbl__t.html">hashtbl_t</a> *, const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *, void *key, int *status)</td></tr>
<tr class="memdesc:ab8c944178b1573faca22dc7bfd6d856e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element into the hash table or modify its value.  <a href="hash_8h.html#ab8c944178b1573faca22dc7bfd6d856e">More...</a><br /></td></tr>
<tr class="separator:ab8c944178b1573faca22dc7bfd6d856e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cd8d443a893040d6a40a68f192b92b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash_8h.html#a44cd8d443a893040d6a40a68f192b92b">hash_remove</a> (<a class="el" href="structhashtbl__t.html">hashtbl_t</a> *, const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *, const void *key)</td></tr>
<tr class="memdesc:a44cd8d443a893040d6a40a68f192b92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element with a given key.  <a href="hash_8h.html#a44cd8d443a893040d6a40a68f192b92b">More...</a><br /></td></tr>
<tr class="separator:a44cd8d443a893040d6a40a68f192b92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1471b49c25b6309defd37699bef175a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash_8h.html#a1471b49c25b6309defd37699bef175a8">hash_delete</a> (<a class="el" href="structhashtbl__t.html">hashtbl_t</a> *, const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *, void *ent)</td></tr>
<tr class="memdesc:a1471b49c25b6309defd37699bef175a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element of the hash table by pointer.  <a href="hash_8h.html#a1471b49c25b6309defd37699bef175a8">More...</a><br /></td></tr>
<tr class="separator:a1471b49c25b6309defd37699bef175a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b42ba0b0db78036b0d3ab49f68ea94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash_8h.html#aa6b42ba0b0db78036b0d3ab49f68ea94">hash_clear</a> (<a class="el" href="structhashtbl__t.html">hashtbl_t</a> *, const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *)</td></tr>
<tr class="memdesc:aa6b42ba0b0db78036b0d3ab49f68ea94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all entries from the hash table.  <a href="hash_8h.html#aa6b42ba0b0db78036b0d3ab49f68ea94">More...</a><br /></td></tr>
<tr class="separator:aa6b42ba0b0db78036b0d3ab49f68ea94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24aff9bdb9721b8c869c0e8458593c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash_8h.html#ae24aff9bdb9721b8c869c0e8458593c8">hash_destroy</a> (<a class="el" href="structhashtbl__t.html">hashtbl_t</a> *, const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *)</td></tr>
<tr class="memdesc:ae24aff9bdb9721b8c869c0e8458593c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the resources held by the hashtable.  <a href="hash_8h.html#ae24aff9bdb9721b8c869c0e8458593c8">More...</a><br /></td></tr>
<tr class="separator:ae24aff9bdb9721b8c869c0e8458593c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.3.0 </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>A fast hash table using quadratic probing and an incremental split table for growing. If the table needs to be extended, a second internal table will be created. All new entries will be placed in the second table, and all hash table operations will move one entry from the old table to the new table, to amortize the cost. </p>

<p class="definition">Definition in file <a class="el" href="hash_8h_source.html">hash.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af43716c1dafc1120cba882b2b35cf02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43716c1dafc1120cba882b2b35cf02d">&#9670;&nbsp;</a></span>hash_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hash_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashtbl__t.html">hashtbl_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reserve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a hash table. </p>
<p>The <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> argument should be configured manually. This is not likely to change. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reserve</td><td>how many entries to reserve space for. This is rounded up to a power of 2 and then DOWN to a prime. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a id="a077f1d34d4355de9a652cd7cf77208f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077f1d34d4355de9a652cd7cf77208f4">&#9670;&nbsp;</a></span>hash_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hash_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashtbl__t.html">hashtbl_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to an entry in the hash table. </p>
<p>This pointer could be invalidated if a new element is inserted into the hash table, or if any operation is performed while the secondary table is present. Thus the entry should be copied if it is needed after additional operations. If the hash table should be available from multiple threads, an external lock should be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key to search the hash table for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element if found (which could be invalidated by another hash table operation) or NULL if absent </dd></dl>

</div>
</div>
<a id="a8c19e7135b43188e3f950d3a4296bfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c19e7135b43188e3f950d3a4296bfa5">&#9670;&nbsp;</a></span>hash_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hash_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashtbl__t.html">hashtbl_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element into the hash table. </p>
<p>The element is copied from the pointer provided, so keep in mind both the "key" and "value" components of it should be initialized. Returns a pointer to the inserted element. As with <a class="el" href="hash_8h.html#a077f1d34d4355de9a652cd7cf77208f4">hash_get</a>, this pointer could be invalidated if another hash table operation is called, and the hash table should be externally locked if the hash table should be available from multiple threads. This function will not modify the hash table if an entry with the same key already exists, but a pointer to the existing element will be returned. <a class="el" href="hash_8h.html#ab8c944178b1573faca22dc7bfd6d856e">hash_append</a> can be used to change the behavior for existing keys. The status reported can be used to differentiate between the element being inserted and already being present. If the additional entry would bring the total number of entries over the capacity, the table expands with a second internal buffer. The capacity is recalculated according to the load factor supplied to this function, the number of elements to move per incremental rehash is recomputed (it is always 1 or 2 currently), and any future calls to most hash table operations will move this many elements from the old table to the new table until it can be free'd. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>element to insert. "key" and "value" components should be initialized. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>if not NULL, this pointer is set to 1 on success, 2 if an element with the same key is present already, and 0 on allocation failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an element with the same key if one exists, otherwise a pointer to the element inserted into the hash table, as if <a class="el" href="hash_8h.html#a077f1d34d4355de9a652cd7cf77208f4">hash_get</a> were called atomically afterwards </dd></dl>

</div>
</div>
<a id="ab8c944178b1573faca22dc7bfd6d856e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c944178b1573faca22dc7bfd6d856e">&#9670;&nbsp;</a></span>hash_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hash_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashtbl__t.html">hashtbl_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element into the hash table or modify its value. </p>
<p>Similar to <a class="el" href="hash_8h.html#a8c19e7135b43188e3f950d3a4296bfa5">hash_insert</a> except that if an element with the same key is present already, <a class="el" href="structhashtbl__ft.html#aa1a07bceaefd7eed8ec9ffcb3cb4ba6c">hashtbl_ft::add</a> is called to allow the existing element and even potentially the element pointed to by key to be modified. The latter is useful if elements "own" some resource, for example freeing a string in key after appending it to the string in the existing element. This function requires the add function to be specified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key</td><td>element to insert or modify existing element with. "key" and "value" components should be initialized. Can be modified if an element with the same key exists and the add function modifies its second argument. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>if not NULL, this pointer is set to 1 on success, 2 if an element with the same key is present already, and 0 on allocation failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an element with the same key if one exists, otherwise a pointer to the element inserted into the hash table, as if <a class="el" href="hash_8h.html#a077f1d34d4355de9a652cd7cf77208f4">hash_get</a> were called atomically afterwards </dd></dl>

</div>
</div>
<a id="a44cd8d443a893040d6a40a68f192b92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cd8d443a893040d6a40a68f192b92b">&#9670;&nbsp;</a></span>hash_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hash_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashtbl__t.html">hashtbl_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the element with a given key. </p>
<p>Equivalent to <a class="el" href="hash_8h.html#a077f1d34d4355de9a652cd7cf77208f4">hash_get</a> followed by <a class="el" href="hash_8h.html#a1471b49c25b6309defd37699bef175a8">hash_delete</a>. Sets the deleted bit in the hash table, although this bit is currently unused. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>"key" of the element to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the element is found (and removed), 0 if the element is not found </dd></dl>

</div>
</div>
<a id="a1471b49c25b6309defd37699bef175a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1471b49c25b6309defd37699bef175a8">&#9670;&nbsp;</a></span>hash_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hash_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashtbl__t.html">hashtbl_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an element of the hash table by pointer. </p>
<p>Useful if the element has already been found via <a class="el" href="hash_8h.html#a077f1d34d4355de9a652cd7cf77208f4">hash_get</a> or <a class="el" href="">hash_next</a>. Sets the deleted bit, although this is currently unused. Does NOT incrementally move entries from the old internal table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ent</td><td>the element to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6b42ba0b0db78036b0d3ab49f68ea94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b42ba0b0db78036b0d3ab49f68ea94">&#9670;&nbsp;</a></span>hash_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hash_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashtbl__t.html">hashtbl_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all entries from the hash table. </p>
<p><a class="el" href="structhashtbl__ft.html#a3e699c1199aab919272d6a4da41c32cd">hashtbl_ft::del</a> is called on every entry if specified, otherwise this is constant time assuming free is. Does not set the unused deleted bit unless a delete function is specified. Frees the older, smaller internal table if two are present, which will also cause incremental moving to stop the next time it would occur. </p>

</div>
</div>
<a id="ae24aff9bdb9721b8c869c0e8458593c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24aff9bdb9721b8c869c0e8458593c8">&#9670;&nbsp;</a></span>hash_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hash_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashtbl__t.html">hashtbl_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhashtbl__ft.html">hashtbl_ft</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the resources held by the hashtable. </p>
<p>If <a class="el" href="structhashtbl__ft.html#a3e699c1199aab919272d6a4da41c32cd">hashtbl_ft::del</a> is specified, it is called on every entry before free is called, otherwise, this function is constant time if free is. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
