<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Number Theory Utils: include/nut/sieves.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_awesome_sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="/Number-Theory-Utils/index.html">Number Theory Utils</a><span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('sieves_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sieves.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.2.0 </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Sieve based functions for computing primes in a range or divisor counts/ power sums/Euler's totient function/Carmichael's function on all numbers in a range. Arrays returned from sieve functions should be freed when no longer needed. </p>

<p class="definition">Definition in file <a class="el" href="sieves_8h_source.html">sieves.h</a>.</p>
</div>
<p><a href="sieves_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab85186e50e24074c1e6c5f437a301a2f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#ab85186e50e24074c1e6c5f437a301a2f">nut_max_prime_divs</a> (uint64_t max)</td></tr>
<tr class="memdesc:ab85186e50e24074c1e6c5f437a301a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum number of unique prime divisors a number can have.  <a href="sieves_8h.html#ab85186e50e24074c1e6c5f437a301a2f">More...</a><br /></td></tr>
<tr class="separator:ab85186e50e24074c1e6c5f437a301a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96915f632c263ea824284611230412cc"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a96915f632c263ea824284611230412cc">nut_max_primes_le</a> (uint64_t max)</td></tr>
<tr class="memdesc:a96915f632c263ea824284611230412cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an upper bound on the number of primes up to max.  <a href="sieves_8h.html#a96915f632c263ea824284611230412cc">More...</a><br /></td></tr>
<tr class="separator:a96915f632c263ea824284611230412cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c96f6c0f85946e60c6d5a7ec948fade"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a7c96f6c0f85946e60c6d5a7ec948fade">nut_u64_make_factorial_tbl</a> (uint64_t k, uint64_t modulus, uint64_t bits, uint64_t max_denom, uint64_t factorials[static bits+k], uint64_t inv_factorials[static max_denom+1])</td></tr>
<tr class="memdesc:a7c96f6c0f85946e60c6d5a7ec948fade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate factorials and inverse factorials for a given upper bound and modulus.  <a href="sieves_8h.html#a7c96f6c0f85946e60c6d5a7ec948fade">More...</a><br /></td></tr>
<tr class="separator:a7c96f6c0f85946e60c6d5a7ec948fade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae0bf943c49092ebc83d09d95cc2220"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a1ae0bf943c49092ebc83d09d95cc2220">nut_sieve_factorizations</a> (uint64_t max, uint64_t *_w)</td></tr>
<tr class="memdesc:a1ae0bf943c49092ebc83d09d95cc2220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the factorization for every number in the range from 0 to max.  <a href="sieves_8h.html#a1ae0bf943c49092ebc83d09d95cc2220">More...</a><br /></td></tr>
<tr class="separator:a1ae0bf943c49092ebc83d09d95cc2220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280efb1221ea2f423d3169c4b1bfff64"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a280efb1221ea2f423d3169c4b1bfff64">nut_get_factorizations_pitch</a> (uint64_t w)</td></tr>
<tr class="memdesc:a280efb1221ea2f423d3169c4b1bfff64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pitch for a pitched array of factorization structs with w unique prime divisors.  <a href="sieves_8h.html#a280efb1221ea2f423d3169c4b1bfff64">More...</a><br /></td></tr>
<tr class="separator:a280efb1221ea2f423d3169c4b1bfff64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67740f0cc15969487c93537cf52038d9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a67740f0cc15969487c93537cf52038d9">nut_sieve_factors</a> (uint64_t max, uint64_t *_w)</td></tr>
<tr class="memdesc:a67740f0cc15969487c93537cf52038d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the unique prime factors of every number in the range from 0 to max.  <a href="sieves_8h.html#a67740f0cc15969487c93537cf52038d9">More...</a><br /></td></tr>
<tr class="separator:a67740f0cc15969487c93537cf52038d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a65ee088513d19d5a014d3126c7d526"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a8a65ee088513d19d5a014d3126c7d526">nut_sieve_largest_factors</a> (uint64_t max)</td></tr>
<tr class="memdesc:a8a65ee088513d19d5a014d3126c7d526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the largest prime factor of every number in the range from 0 to max.  <a href="sieves_8h.html#a8a65ee088513d19d5a014d3126c7d526">More...</a><br /></td></tr>
<tr class="separator:a8a65ee088513d19d5a014d3126c7d526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23dcc7562e209acadb64a6e4fa8414f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#ad23dcc7562e209acadb64a6e4fa8414f">NUT_ATTR_ACCESS</a> (read_write, 1) NUT_ATTR_ACCESS(read_only</td></tr>
<tr class="memdesc:ad23dcc7562e209acadb64a6e4fa8414f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a table of largest prime factors to get the factorization of a number.  <a href="sieves_8h.html#ad23dcc7562e209acadb64a6e4fa8414f">More...</a><br /></td></tr>
<tr class="separator:ad23dcc7562e209acadb64a6e4fa8414f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b97b3bb9a75fc40a32f293d56a17ba"><td class="memItemLeft" align="right" valign="top"><a id="ab7b97b3bb9a75fc40a32f293d56a17ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>nut_fill_factors_from_largest</b> (<a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict out, uint64_t n, const uint64_t largest_factors[restrict static n+1])</td></tr>
<tr class="separator:ab7b97b3bb9a75fc40a32f293d56a17ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b227ca1422f01350c384254de63530"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a68b227ca1422f01350c384254de63530">nut_get_factors_pitch</a> (uint64_t w)</td></tr>
<tr class="memdesc:a68b227ca1422f01350c384254de63530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pitch for a pitched array of <a class="el" href="structnut__u64__Pitcharr.html">nut_u64_Pitcharr</a> factor lists.  <a href="sieves_8h.html#a68b227ca1422f01350c384254de63530">More...</a><br /></td></tr>
<tr class="separator:a68b227ca1422f01350c384254de63530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3bf51e510e831251cf83c53f63ef50"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a3b3bf51e510e831251cf83c53f63ef50">nut_sieve_sigma_0</a> (uint64_t max)</td></tr>
<tr class="memdesc:a3b3bf51e510e831251cf83c53f63ef50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of divisors (including 1 and n) for every number n from 0 to max.  <a href="sieves_8h.html#a3b3bf51e510e831251cf83c53f63ef50">More...</a><br /></td></tr>
<tr class="separator:a3b3bf51e510e831251cf83c53f63ef50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a923b3664a1ff3dd55c5ddccc716953"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a0a923b3664a1ff3dd55c5ddccc716953">nut_sieve_sigma_1</a> (uint64_t max)</td></tr>
<tr class="memdesc:a0a923b3664a1ff3dd55c5ddccc716953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of divisors (including 1 and n) for every number n from 0 to max.  <a href="sieves_8h.html#a0a923b3664a1ff3dd55c5ddccc716953">More...</a><br /></td></tr>
<tr class="separator:a0a923b3664a1ff3dd55c5ddccc716953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03de6de6ddfb26ac7ac9a867dd7d30e2"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a03de6de6ddfb26ac7ac9a867dd7d30e2">nut_sieve_sigma_e</a> (uint64_t max, uint64_t e)</td></tr>
<tr class="memdesc:a03de6de6ddfb26ac7ac9a867dd7d30e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of some power of divisors (including 1 and n) for every number n from 0 to max.  <a href="sieves_8h.html#a03de6de6ddfb26ac7ac9a867dd7d30e2">More...</a><br /></td></tr>
<tr class="separator:a03de6de6ddfb26ac7ac9a867dd7d30e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdace58bcbe68f4fc52b38a9bf6855f"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a7cdace58bcbe68f4fc52b38a9bf6855f">nut_sieve_dk</a> (uint64_t max, uint64_t k, uint64_t modulus)</td></tr>
<tr class="memdesc:a7cdace58bcbe68f4fc52b38a9bf6855f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the generalized divisor function dk(n) (number of k-tuples with product n) for every number n from 0 to max.  <a href="sieves_8h.html#a7cdace58bcbe68f4fc52b38a9bf6855f">More...</a><br /></td></tr>
<tr class="separator:a7cdace58bcbe68f4fc52b38a9bf6855f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af071928bf5a2b6ea12d5a5ccda164780"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#af071928bf5a2b6ea12d5a5ccda164780">nut_sieve_phi</a> (uint64_t max)</td></tr>
<tr class="memdesc:af071928bf5a2b6ea12d5a5ccda164780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Euler's totient function for every number from 0 to max.  <a href="sieves_8h.html#af071928bf5a2b6ea12d5a5ccda164780">More...</a><br /></td></tr>
<tr class="separator:af071928bf5a2b6ea12d5a5ccda164780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80312f8b853eeb8a9df48ff15078c2f0"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a80312f8b853eeb8a9df48ff15078c2f0">nut_sieve_carmichael</a> (uint64_t max)</td></tr>
<tr class="memdesc:a80312f8b853eeb8a9df48ff15078c2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Carmichael function for every number from 0 to max.  <a href="sieves_8h.html#a80312f8b853eeb8a9df48ff15078c2f0">More...</a><br /></td></tr>
<tr class="separator:a80312f8b853eeb8a9df48ff15078c2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1184e4b679ee165bb5e6ae0179f2d4b"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#ac1184e4b679ee165bb5e6ae0179f2d4b">nut_sieve_mobius</a> (uint64_t max)</td></tr>
<tr class="memdesc:ac1184e4b679ee165bb5e6ae0179f2d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Mobius function for every number from 0 to max.  <a href="sieves_8h.html#ac1184e4b679ee165bb5e6ae0179f2d4b">More...</a><br /></td></tr>
<tr class="separator:ac1184e4b679ee165bb5e6ae0179f2d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9f97397c57da8e705cf667ad1e5cd3"><td class="memItemLeft" align="right" valign="top">int64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#aea9f97397c57da8e705cf667ad1e5cd3">nut_compute_mertens_range</a> (uint64_t max, const uint8_t mobius[static max/4+1])</td></tr>
<tr class="memdesc:aea9f97397c57da8e705cf667ad1e5cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Mertens function (sum of Mobius function) for every number from 0 to max.  <a href="sieves_8h.html#aea9f97397c57da8e705cf667ad1e5cd3">More...</a><br /></td></tr>
<tr class="separator:aea9f97397c57da8e705cf667ad1e5cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe643cd3f2feb771b2c24ef15fcb190"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#aefe643cd3f2feb771b2c24ef15fcb190">nut_sieve_is_composite</a> (uint64_t max)</td></tr>
<tr class="memdesc:aefe643cd3f2feb771b2c24ef15fcb190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bitarray of whether or not each number from 0 to max is composite.  <a href="sieves_8h.html#aefe643cd3f2feb771b2c24ef15fcb190">More...</a><br /></td></tr>
<tr class="separator:aefe643cd3f2feb771b2c24ef15fcb190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fa59181aed2a20a677e4ae846e1ed9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a61fa59181aed2a20a677e4ae846e1ed9">nut_is_composite</a> (uint64_t n, const uint8_t buf[static n/30+1])</td></tr>
<tr class="memdesc:a61fa59181aed2a20a677e4ae846e1ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a number is composite using a packed bitarray from <a class="el" href="sieves_8h.html#aefe643cd3f2feb771b2c24ef15fcb190">nut_sieve_is_composite</a>.  <a href="sieves_8h.html#a61fa59181aed2a20a677e4ae846e1ed9">More...</a><br /></td></tr>
<tr class="separator:a61fa59181aed2a20a677e4ae846e1ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f1a4de55e161c45e93c7d3c63d9f8"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#aac0f1a4de55e161c45e93c7d3c63d9f8">nut_compute_pi_range</a> (uint64_t max, const uint8_t buf[static max/30+1])</td></tr>
<tr class="memdesc:aac0f1a4de55e161c45e93c7d3c63d9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the pi (prime counting) function for every number from 0 to max.  <a href="sieves_8h.html#aac0f1a4de55e161c45e93c7d3c63d9f8">More...</a><br /></td></tr>
<tr class="separator:aac0f1a4de55e161c45e93c7d3c63d9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad711843b7300b037e9404802cac9e361"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#ad711843b7300b037e9404802cac9e361">NUT_ATTR_ACCESS</a> (read_only, 2) NUT_ATTR_ACCESS(read_only</td></tr>
<tr class="memdesc:ad711843b7300b037e9404802cac9e361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value for the pi (prime counting) function for a particular number using precomputed tables.  <a href="sieves_8h.html#ad711843b7300b037e9404802cac9e361">More...</a><br /></td></tr>
<tr class="separator:ad711843b7300b037e9404802cac9e361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae679759c52a6a426e3efb05bfb8c7618"><td class="memItemLeft" align="right" valign="top"><a id="ae679759c52a6a426e3efb05bfb8c7618"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NUT_ATTR_NO_SAN</b> (&quot;vla-bound&quot;) uint64_t nut_compute_pi_from_tables(uint64_t n</td></tr>
<tr class="separator:ae679759c52a6a426e3efb05bfb8c7618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee997477c22920d4d8a3831dd24a8683"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#aee997477c22920d4d8a3831dd24a8683">nut_sieve_primes</a> (uint64_t max, uint64_t *_num_primes)</td></tr>
<tr class="memdesc:aee997477c22920d4d8a3831dd24a8683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an array of all primes from 0 to max.  <a href="sieves_8h.html#aee997477c22920d4d8a3831dd24a8683">More...</a><br /></td></tr>
<tr class="separator:aee997477c22920d4d8a3831dd24a8683"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1307b537f4734411ecbf1cabb5235f9b"><td class="memItemLeft" align="right" valign="top"><a id="a1307b537f4734411ecbf1cabb5235f9b"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>pi_table</b> [restrict static n/30]</td></tr>
<tr class="separator:a1307b537f4734411ecbf1cabb5235f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd3349080730e970ca7b1bd824833ce"><td class="memItemLeft" align="right" valign="top"><a id="a4dd3349080730e970ca7b1bd824833ce"></a>
const uint64_t const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>buf</b> [restrict static n/30+1]</td></tr>
<tr class="separator:a4dd3349080730e970ca7b1bd824833ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab85186e50e24074c1e6c5f437a301a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85186e50e24074c1e6c5f437a301a2f">&#9670;&nbsp;</a></span>nut_max_prime_divs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nut_max_prime_divs </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum number of unique prime divisors a number can have. </p>
<p>This has nothing to do with factoring the number and is just a simple binary decision diagram based on comparing the number to 2, 2*3, 2*3*5, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>number to find max unique prime divisors of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the largest number of unique prime divisors any number not exceeding max can possibly have </dd></dl>

</div>
</div>
<a id="a96915f632c263ea824284611230412cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96915f632c263ea824284611230412cc">&#9670;&nbsp;</a></span>nut_max_primes_le()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nut_max_primes_le </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an upper bound on the number of primes up to max. </p>
<p>This uses an inequality involving log derived from the prime number theorem to always get an upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>number to find the number of primes up to </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">an</td><td>upper bound on the number of primes up to max </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c96f6c0f85946e60c6d5a7ec948fade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c96f6c0f85946e60c6d5a7ec948fade">&#9670;&nbsp;</a></span>nut_u64_make_factorial_tbl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_u64_make_factorial_tbl </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_denom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>factorials</em>[static bits+k], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>inv_factorials</em>[static max_denom+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate factorials and inverse factorials for a given upper bound and modulus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>factorials[bits + k - 1] is the last factorial that will be computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modulus</td><td>modulus to reduce result by. Must be large enough that all inv factorials are actually invertable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits</td><td>used with k to find the last factorial to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_denom</td><td>inv_factorials[max_denom] is the last one that will be computed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">factorials</td><td>output for factorial table </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inv_factorials</td><td>output for inverse factorial table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure (if the inverse of some factorial can't be found) </dd></dl>

</div>
</div>
<a id="a1ae0bf943c49092ebc83d09d95cc2220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae0bf943c49092ebc83d09d95cc2220">&#9670;&nbsp;</a></span>nut_sieve_factorizations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nut_sieve_factorizations </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>_w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the factorization for every number in the range from 0 to max. </p>
<p>The factorizations for 0 and 1 are not actually computed. The factorizations are stored in an array of factors_t structs with capacity w, where w is the maximum number of unique prime divisors of a number not exceeding max. The result is a pitched array. <a class="el" href="">nut_Pitcharr_get</a> should be used to handle the returned value. <a class="el" href="">get_factorizations_pitch</a> should be used to get the pitch from the output parameter w. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to factor all numbers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_w</td><td>store w, the maximum number of unique prime divisors of a number not exceeding max </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an array of factors_t structs containing the factorization of all numbers not exceeding max, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a280efb1221ea2f423d3169c4b1bfff64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280efb1221ea2f423d3169c4b1bfff64">&#9670;&nbsp;</a></span>nut_get_factorizations_pitch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nut_get_factorizations_pitch </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pitch for a pitched array of factorization structs with w unique prime divisors. </p>
<p>This is simply offsetof(factors_t, factors) + w*sizeof(dummy-&gt;factors[0]), where dummy is an expression with type factors_t. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The maximal number of unique prime divisors of any potential index of the pitched array. Should be obtained from <a class="el" href="sieves_8h.html#a1ae0bf943c49092ebc83d09d95cc2220">nut_sieve_factorizations</a>, <a class="el" href="">max_prime_divisors</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pitch of a pitched array of factorization structs whose flexible length members all have w elements. </dd></dl>

</div>
</div>
<a id="a67740f0cc15969487c93537cf52038d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67740f0cc15969487c93537cf52038d9">&#9670;&nbsp;</a></span>nut_sieve_factors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nut_sieve_factors </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>_w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the unique prime factors of every number in the range from 0 to max. </p>
<p>The factors for 0 and 1 are not actually computed. The result is stored in an array of <a class="el" href="structnut__u64__Pitcharr.html" title="A fixed capacity array.">nut_u64_Pitcharr</a> structs with capacity w, where w is the maximum number of unique prime divisors of a number not exceeding max. The pitch of the result may be obtained with <a class="el" href="">get_factors_pitch</a>. <a class="el" href="">nut_Pitcharr_get</a> should be used to handle the returned value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find unique prime factors of all numbers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_w</td><td>maximum numer of unique prime divisors of a number not exceeding max </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an array of <a class="el" href="structnut__u64__Pitcharr.html" title="A fixed capacity array.">nut_u64_Pitcharr</a> structs containing lists of unique prime factors for all numbers not exceeding max, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a8a65ee088513d19d5a014d3126c7d526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a65ee088513d19d5a014d3126c7d526">&#9670;&nbsp;</a></span>nut_sieve_largest_factors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* nut_sieve_largest_factors </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the largest prime factor of every number in the range from 0 to max. </p>
<p>Compared to <a class="el" href="sieves_8h.html#a67740f0cc15969487c93537cf52038d9">nut_sieve_factors</a>, this uses up to 30 times less memory, so if the range is very large, most numbers will never actually have their factorizations accessed, or the factorizations will only be accessed about once, this function should be preferred. The factors of 0 and 1 are not actually computed, their entries in the returned array will be 0. You can use the resulting table as it is, or convert it to a factorization using <a class="el" href="">nut_fill_factors_from_largest</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find largest prime factors of all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an array of largest prime factors for all numbers not exceeding max, or NULL on allocation failure. </dd></dl>

</div>
</div>
<a id="ad23dcc7562e209acadb64a6e4fa8414f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23dcc7562e209acadb64a6e4fa8414f">&#9670;&nbsp;</a></span>NUT_ATTR_ACCESS() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NUT_ATTR_ACCESS </td>
          <td>(</td>
          <td class="paramtype">read_write&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a table of largest prime factors to get the factorization of a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Factors struct to store result in. MUST be allocated already, use <a class="el" href="">init_factors_t_ub</a> or <a class="el" href="sieves_8h.html#ab85186e50e24074c1e6c5f437a301a2f">nut_max_prime_divs</a> and <a class="el" href="factorization_8h.html#a2cc9af2019214dbca0a96c10863c45c3">nut_make_Factors_w</a> if needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to get the factorization of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">largest_factors</td><td>table of largest factors, from <a class="el" href="sieves_8h.html#a8a65ee088513d19d5a014d3126c7d526">nut_sieve_largest_factors</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68b227ca1422f01350c384254de63530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b227ca1422f01350c384254de63530">&#9670;&nbsp;</a></span>nut_get_factors_pitch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nut_get_factors_pitch </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pitch for a pitched array of <a class="el" href="structnut__u64__Pitcharr.html">nut_u64_Pitcharr</a> factor lists. </p>
<p>This is simply offsetof(nut_u64_Pitcharr, elems) + *_w*sizeof(uint64_t). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The maximal number of unique prime divisors of any potential index of the pitched array. Should be obtained from <a class="el" href="sieves_8h.html#a67740f0cc15969487c93537cf52038d9">nut_sieve_factors</a>, <a class="el" href="">max_prime_divisors</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pitch of a pitched array of factor list structs whose flexible length members all have w elements. </dd></dl>

</div>
</div>
<a id="a3b3bf51e510e831251cf83c53f63ef50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3bf51e510e831251cf83c53f63ef50">&#9670;&nbsp;</a></span>nut_sieve_sigma_0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* nut_sieve_sigma_0 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of divisors (including 1 and n) for every number n from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="">divisor_count</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find divisor counts for all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of divisor counts for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a0a923b3664a1ff3dd55c5ddccc716953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a923b3664a1ff3dd55c5ddccc716953">&#9670;&nbsp;</a></span>nut_sieve_sigma_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* nut_sieve_sigma_1 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the sum of divisors (including 1 and n) for every number n from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="">divisor_sum</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find divisor sums for all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of divisor sums for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a03de6de6ddfb26ac7ac9a867dd7d30e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03de6de6ddfb26ac7ac9a867dd7d30e2">&#9670;&nbsp;</a></span>nut_sieve_sigma_e()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* nut_sieve_sigma_e </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the sum of some power of divisors (including 1 and n) for every number n from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="">divisor_power_sum</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find divisor power sums for all numbers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>power of divisors for summing, eg 0 would produce divisor counts, 1 divisor sums, 2 sums of squares of divisors, etc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of divisor power sums for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a7cdace58bcbe68f4fc52b38a9bf6855f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdace58bcbe68f4fc52b38a9bf6855f">&#9670;&nbsp;</a></span>nut_sieve_dk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* nut_sieve_dk </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the generalized divisor function dk(n) (number of k-tuples with product n) for every number n from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="">divisor_tuple_count</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately. Note that dk is multiplicative so dk(mn) = dk(m)dk(n) when m and n are coprime, and dk(p^a) = binom(a + k, k) for prime powers. In other words, dk is exponential in k and this function will overflow if max^k is too large. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to compute generalized divisor function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of factors per factorization, eg for a prime power p^a we get binom(a + k, k). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modulus</td><td>modulus to reduce results by, or zero to skip reducing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of dk results, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="af071928bf5a2b6ea12d5a5ccda164780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af071928bf5a2b6ea12d5a5ccda164780">&#9670;&nbsp;</a></span>nut_sieve_phi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* nut_sieve_phi </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Euler's totient function for every number from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="">euler_phi</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find totients for all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of totients for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a80312f8b853eeb8a9df48ff15078c2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80312f8b853eeb8a9df48ff15078c2f0">&#9670;&nbsp;</a></span>nut_sieve_carmichael()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* nut_sieve_carmichael </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Carmichael function for every number from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="">carmichael_lambda</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to compute Carmichael for all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of Carmichael function outputs for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="ac1184e4b679ee165bb5e6ae0179f2d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1184e4b679ee165bb5e6ae0179f2d4b">&#9670;&nbsp;</a></span>nut_sieve_mobius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* nut_sieve_mobius </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Mobius function for every number from 0 to max. </p>
<p>The result is stored in an array of 2 bit integers, which should be accessed by <a class="el" href="">nut_Bitfield2_arr_get</a>. That function will return 0 for 0, 1 for 1, and 3 for -1. 2 will not be stored anywhere in bounds in the resulting array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to compute Mobius for all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a bitfield array of Mobius function outputs for all numbers in the range, with 3 instead of -1, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="aea9f97397c57da8e705cf667ad1e5cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9f97397c57da8e705cf667ad1e5cd3">&#9670;&nbsp;</a></span>nut_compute_mertens_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t* nut_compute_mertens_range </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mobius</em>[static max/4+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Mertens function (sum of Mobius function) for every number from 0 to max. </p>
<p>Note that this function is signed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of range in which to compute Mertens for all numbers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mobius</td><td>bitfield array of Mobius function outputs (from <a class="el" href="sieves_8h.html#ac1184e4b679ee165bb5e6ae0179f2d4b">nut_sieve_mobius</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of Mertens function outputs for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="aefe643cd3f2feb771b2c24ef15fcb190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe643cd3f2feb771b2c24ef15fcb190">&#9670;&nbsp;</a></span>nut_sieve_is_composite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* nut_sieve_is_composite </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a bitarray of whether or not each number from 0 to max is composite. </p>
<p>1 is composite, and 0 is considered composite here. The result should be used with <a class="el" href="sieves_8h.html#a61fa59181aed2a20a677e4ae846e1ed9">nut_is_composite</a> since it is packed (only stores bitflags for numbers coprime to 30). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to check compositeness for all numbers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_num_primes</td><td>the number of primes in the range will be stored here. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a bitarray of whether or not each number in the range is composite, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a61fa59181aed2a20a677e4ae846e1ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fa59181aed2a20a677e4ae846e1ed9">&#9670;&nbsp;</a></span>nut_is_composite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_is_composite </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>buf</em>[static n/30+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a number is composite using a packed bitarray from <a class="el" href="sieves_8h.html#aefe643cd3f2feb771b2c24ef15fcb190">nut_sieve_is_composite</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to check if composite </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>packed bitarray from <a class="el" href="sieves_8h.html#aefe643cd3f2feb771b2c24ef15fcb190">nut_sieve_is_composite</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if n is composite, false if n is prime </dd></dl>

</div>
</div>
<a id="aac0f1a4de55e161c45e93c7d3c63d9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0f1a4de55e161c45e93c7d3c63d9f8">&#9670;&nbsp;</a></span>nut_compute_pi_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* nut_compute_pi_range </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>buf</em>[static max/30+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the pi (prime counting) function for every number from 0 to max. </p>
<p>The result should be used with <a class="el" href="">nut_compute_pi_from_tables</a> since pi is only actually calculated at every 240th number since intermediate results can be computed with a single popcount on the packed buf bitarray. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of range to compute pi function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>packed bitarray from <a class="el" href="sieves_8h.html#aefe643cd3f2feb771b2c24ef15fcb190">nut_sieve_is_composite</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of pi values at every 240th number (use <a class="el" href="">nut_compute_pi_from_tables</a>) </dd></dl>

</div>
</div>
<a id="ad711843b7300b037e9404802cac9e361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad711843b7300b037e9404802cac9e361">&#9670;&nbsp;</a></span>NUT_ATTR_ACCESS() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NUT_ATTR_ACCESS </td>
          <td>(</td>
          <td class="paramtype">read_only&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value for the pi (prime counting) function for a particular number using precomputed tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to calculate pi for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pi_table</td><td>array of partial pi values from <a class="el" href="sieves_8h.html#aac0f1a4de55e161c45e93c7d3c63d9f8">nut_compute_pi_range</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>packed bitarray from <a class="el" href="sieves_8h.html#aefe643cd3f2feb771b2c24ef15fcb190">nut_sieve_is_composite</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of primes &lt;= n </dd></dl>

</div>
</div>
<a id="aee997477c22920d4d8a3831dd24a8683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee997477c22920d4d8a3831dd24a8683">&#9670;&nbsp;</a></span>nut_sieve_primes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* nut_sieve_primes </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>_num_primes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an array of all primes from 0 to max. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_num_primes</td><td>how many primes were found in the range (this pointer cannot be null) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of all primes from 0 to max, or NULL on allocation failure </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_073faa820624379b5730e5b4f5cb1c42.html">nut</a></li><li class="navelem"><a class="el" href="sieves_8h.html">sieves.h</a></li>
    <li class="footer">Generated on Mon Oct 30 2023 20:16:38 for Number Theory Utils by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
