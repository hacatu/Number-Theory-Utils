<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Number Theory Utils: include/nut/sieves.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_awesome_sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="/Number-Theory-Utils/index.html">Number Theory Utils</a><span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('sieves_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sieves.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.2.0 </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Sieve based functions for computing primes in a range or divisor counts/ power sums/Euler's totient function/Carmichael's function on all numbers in a range. Arrays returned from sieve functions should be freed when no longer needed. </p>

<p class="definition">Definition in file <a class="el" href="sieves_8h_source.html">sieves.h</a>.</p>
</div>
<p><a href="sieves_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaa5df5504d790281d05a032095e002a0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#aaa5df5504d790281d05a032095e002a0">max_prime_divs</a> (uint64_t max) __attribute__((const))</td></tr>
<tr class="memdesc:aaa5df5504d790281d05a032095e002a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum number of unique prime divisors a number can have.  <a href="sieves_8h.html#aaa5df5504d790281d05a032095e002a0">More...</a><br /></td></tr>
<tr class="separator:aaa5df5504d790281d05a032095e002a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8902a25584ef66364b5d24193a08923a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a8902a25584ef66364b5d24193a08923a">max_primes_le</a> (uint64_t max) __attribute__((const))</td></tr>
<tr class="memdesc:a8902a25584ef66364b5d24193a08923a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an upper bound on the number of primes up to max.  <a href="sieves_8h.html#a8902a25584ef66364b5d24193a08923a">More...</a><br /></td></tr>
<tr class="separator:a8902a25584ef66364b5d24193a08923a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b7ec1e3f2ac442b0f098861f758cff"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a55b7ec1e3f2ac442b0f098861f758cff">sieve_factorizations</a> (uint64_t max, uint64_t *_w)</td></tr>
<tr class="memdesc:a55b7ec1e3f2ac442b0f098861f758cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the factorization for every number in the range from 0 to max.  <a href="sieves_8h.html#a55b7ec1e3f2ac442b0f098861f758cff">More...</a><br /></td></tr>
<tr class="separator:a55b7ec1e3f2ac442b0f098861f758cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725ae2ebd048749b792cd92c23e815e8"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a725ae2ebd048749b792cd92c23e815e8">get_factorizations_pitch</a> (uint64_t w) __attribute__((const))</td></tr>
<tr class="memdesc:a725ae2ebd048749b792cd92c23e815e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pitch for a pitched array of factorization structs with w unique prime divisors.  <a href="sieves_8h.html#a725ae2ebd048749b792cd92c23e815e8">More...</a><br /></td></tr>
<tr class="separator:a725ae2ebd048749b792cd92c23e815e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bca79bd17302449e4a95f833e2990c8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a1bca79bd17302449e4a95f833e2990c8">sieve_factors</a> (uint64_t max, uint64_t *_w)</td></tr>
<tr class="memdesc:a1bca79bd17302449e4a95f833e2990c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the unique prime factors of every number in the range from 0 to max.  <a href="sieves_8h.html#a1bca79bd17302449e4a95f833e2990c8">More...</a><br /></td></tr>
<tr class="separator:a1bca79bd17302449e4a95f833e2990c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576d8ab23202853f3542828de64cdf90"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a576d8ab23202853f3542828de64cdf90">sieve_largest_factors</a> (uint64_t max)</td></tr>
<tr class="memdesc:a576d8ab23202853f3542828de64cdf90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the largest prime factor of every number in the range from 0 to max.  <a href="sieves_8h.html#a576d8ab23202853f3542828de64cdf90">More...</a><br /></td></tr>
<tr class="separator:a576d8ab23202853f3542828de64cdf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819489e812b58ce7b80fd2fea3e76c70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a819489e812b58ce7b80fd2fea3e76c70">fill_factors_from_largest</a> (<a class="el" href="structfactors__t.html">factors_t</a> *out, uint64_t n, const uint64_t largest_factors[static n+1])</td></tr>
<tr class="memdesc:a819489e812b58ce7b80fd2fea3e76c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a table of largest prime factors to get the factorization of a number.  <a href="sieves_8h.html#a819489e812b58ce7b80fd2fea3e76c70">More...</a><br /></td></tr>
<tr class="separator:a819489e812b58ce7b80fd2fea3e76c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7907ef204356e0be1a802cf5167992"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#acd7907ef204356e0be1a802cf5167992">get_factors_pitch</a> (uint64_t w) __attribute__((const))</td></tr>
<tr class="memdesc:acd7907ef204356e0be1a802cf5167992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pitch for a pitched array of <a class="el" href="structfw__u64arr__t.html">fw_u64arr_t</a> factor lists.  <a href="sieves_8h.html#acd7907ef204356e0be1a802cf5167992">More...</a><br /></td></tr>
<tr class="separator:acd7907ef204356e0be1a802cf5167992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2b3d5f592ca1a883b1f5d6292bfea6"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a4d2b3d5f592ca1a883b1f5d6292bfea6">sieve_sigma_0</a> (uint64_t max)</td></tr>
<tr class="memdesc:a4d2b3d5f592ca1a883b1f5d6292bfea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of divisors (including 1 and n) for every number n from 0 to max.  <a href="sieves_8h.html#a4d2b3d5f592ca1a883b1f5d6292bfea6">More...</a><br /></td></tr>
<tr class="separator:a4d2b3d5f592ca1a883b1f5d6292bfea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5e2e2afaef3dd04fa1721a4543c3bf"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a1e5e2e2afaef3dd04fa1721a4543c3bf">sieve_sigma_1</a> (uint64_t max)</td></tr>
<tr class="memdesc:a1e5e2e2afaef3dd04fa1721a4543c3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of divisors (including 1 and n) for every number n from 0 to max.  <a href="sieves_8h.html#a1e5e2e2afaef3dd04fa1721a4543c3bf">More...</a><br /></td></tr>
<tr class="separator:a1e5e2e2afaef3dd04fa1721a4543c3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cf98fd1eedb76b4c337a0b6d5cb88c"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a47cf98fd1eedb76b4c337a0b6d5cb88c">sieve_sigma_e</a> (uint64_t max, uint64_t e)</td></tr>
<tr class="memdesc:a47cf98fd1eedb76b4c337a0b6d5cb88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of some power of divisors (including 1 and n) for every number n from 0 to max.  <a href="sieves_8h.html#a47cf98fd1eedb76b4c337a0b6d5cb88c">More...</a><br /></td></tr>
<tr class="separator:a47cf98fd1eedb76b4c337a0b6d5cb88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd78cb343ce5afd768c28aacde7b99d"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a0fd78cb343ce5afd768c28aacde7b99d">sieve_phi</a> (uint64_t max)</td></tr>
<tr class="memdesc:a0fd78cb343ce5afd768c28aacde7b99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Euler's totient function for every number from 0 to max.  <a href="sieves_8h.html#a0fd78cb343ce5afd768c28aacde7b99d">More...</a><br /></td></tr>
<tr class="separator:a0fd78cb343ce5afd768c28aacde7b99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19a3c1887d6cdc9375c32f0abfd2ab3"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#ae19a3c1887d6cdc9375c32f0abfd2ab3">sieve_carmichael</a> (uint64_t max)</td></tr>
<tr class="memdesc:ae19a3c1887d6cdc9375c32f0abfd2ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Carmichael function for every number from 0 to max.  <a href="sieves_8h.html#ae19a3c1887d6cdc9375c32f0abfd2ab3">More...</a><br /></td></tr>
<tr class="separator:ae19a3c1887d6cdc9375c32f0abfd2ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc6cda6e2a6ad9fa55e34267560af3a"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#abdc6cda6e2a6ad9fa55e34267560af3a">sieve_mobius</a> (uint64_t max)</td></tr>
<tr class="memdesc:abdc6cda6e2a6ad9fa55e34267560af3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Mobius function for every number from 0 to max.  <a href="sieves_8h.html#abdc6cda6e2a6ad9fa55e34267560af3a">More...</a><br /></td></tr>
<tr class="separator:abdc6cda6e2a6ad9fa55e34267560af3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bfef1504f10261d7bbb2b343477d09"><td class="memItemLeft" align="right" valign="top">int64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a30bfef1504f10261d7bbb2b343477d09">compute_mertens_range</a> (uint64_t max, const uint64_t mobius[static max/32+1])</td></tr>
<tr class="memdesc:a30bfef1504f10261d7bbb2b343477d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Mertens function (sum of Mobius function) for every number from 0 to max.  <a href="sieves_8h.html#a30bfef1504f10261d7bbb2b343477d09">More...</a><br /></td></tr>
<tr class="separator:a30bfef1504f10261d7bbb2b343477d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff23d64417b86ac7b22c7ccbbc54e820"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#aff23d64417b86ac7b22c7ccbbc54e820">sieve_is_composite</a> (uint64_t max)</td></tr>
<tr class="memdesc:aff23d64417b86ac7b22c7ccbbc54e820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bitarray of whether or not each number from 0 to max is composite.  <a href="sieves_8h.html#aff23d64417b86ac7b22c7ccbbc54e820">More...</a><br /></td></tr>
<tr class="separator:aff23d64417b86ac7b22c7ccbbc54e820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e3f8fe2bf00fa39f40fb7468a134e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a65e3f8fe2bf00fa39f40fb7468a134e3">is_composite</a> (uint64_t n, const uint8_t buf[static n/30+1])</td></tr>
<tr class="memdesc:a65e3f8fe2bf00fa39f40fb7468a134e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a number is composite using a packed bitarray from <a class="el" href="sieves_8h.html#aff23d64417b86ac7b22c7ccbbc54e820">sieve_is_composite</a>.  <a href="sieves_8h.html#a65e3f8fe2bf00fa39f40fb7468a134e3">More...</a><br /></td></tr>
<tr class="separator:a65e3f8fe2bf00fa39f40fb7468a134e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a8da8730b149433ac438cb106479e4"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#ae6a8da8730b149433ac438cb106479e4">sieve_primes</a> (uint64_t max, uint64_t *_num_primes)</td></tr>
<tr class="memdesc:ae6a8da8730b149433ac438cb106479e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an array of all primes from 0 to max.  <a href="sieves_8h.html#ae6a8da8730b149433ac438cb106479e4">More...</a><br /></td></tr>
<tr class="separator:ae6a8da8730b149433ac438cb106479e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaa5df5504d790281d05a032095e002a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5df5504d790281d05a032095e002a0">&#9670;&nbsp;</a></span>max_prime_divs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t max_prime_divs </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum number of unique prime divisors a number can have. </p>
<p>This has nothing to do with factoring the number and is just a simple binary decision diagram based on comparing the number to 2, 2*3, 2*3*5, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>number to find max unique prime divisors of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the largest number of unique prime divisors any number not exceeding max can possibly have </dd></dl>

</div>
</div>
<a id="a8902a25584ef66364b5d24193a08923a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8902a25584ef66364b5d24193a08923a">&#9670;&nbsp;</a></span>max_primes_le()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t max_primes_le </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an upper bound on the number of primes up to max. </p>
<p>This uses an inequality involving log derived from the prime number theorem to always get an upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>number to find the number of primes up to </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">an</td><td>upper bound on the number of primes up to max </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55b7ec1e3f2ac442b0f098861f758cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b7ec1e3f2ac442b0f098861f758cff">&#9670;&nbsp;</a></span>sieve_factorizations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sieve_factorizations </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>_w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the factorization for every number in the range from 0 to max. </p>
<p>The factorizations for 0 and 1 are not actually computed. The factorizations are stored in an array of <a class="el" href="structfactors__t.html" title="A prime factorization.">factors_t</a> structs with capacity w, where w is the maximum number of unique prime divisors of a number not exceeding max. The result is a pitched array. <a class="el" href="">pitch_arr_get</a> should be used to handle the returned value. <a class="el" href="sieves_8h.html#a725ae2ebd048749b792cd92c23e815e8">get_factorizations_pitch</a> should be used to get the pitch from the output parameter w. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to factor all numbers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_w</td><td>store w, the maximum number of unique prime divisors of a number not exceeding max </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an array of <a class="el" href="structfactors__t.html" title="A prime factorization.">factors_t</a> structs containing the factorization of all numbers not exceeding max, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a725ae2ebd048749b792cd92c23e815e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725ae2ebd048749b792cd92c23e815e8">&#9670;&nbsp;</a></span>get_factorizations_pitch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t get_factorizations_pitch </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pitch for a pitched array of factorization structs with w unique prime divisors. </p>
<p>This is simply offsetof(factors_t, factors) + w*sizeof(dummy-&gt;factors[0]), where dummy is an expression with type <a class="el" href="structfactors__t.html" title="A prime factorization.">factors_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The maximal number of unique prime divisors of any potential index of the pitched array. Should be obtained from <a class="el" href="sieves_8h.html#a55b7ec1e3f2ac442b0f098861f758cff">sieve_factorizations</a>, <a class="el" href="">max_prime_divisors</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pitch of a pitched array of factorization structs whose flexible length members all have w elements. </dd></dl>

</div>
</div>
<a id="a1bca79bd17302449e4a95f833e2990c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bca79bd17302449e4a95f833e2990c8">&#9670;&nbsp;</a></span>sieve_factors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sieve_factors </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>_w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the unique prime factors of every number in the range from 0 to max. </p>
<p>The factors for 0 and 1 are not actually computed. The result is stored in an array of <a class="el" href="structfw__u64arr__t.html" title="A fixed capacity array.">fw_u64arr_t</a> structs with capacity w, where w is the maximum number of unique prime divisors of a number not exceeding max. The pitch of the result may be obtained with <a class="el" href="sieves_8h.html#acd7907ef204356e0be1a802cf5167992">get_factors_pitch</a>. <a class="el" href="">pitch_arr_get</a> should be used to handle the returned value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find unique prime factors of all numbers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_w</td><td>maximum numer of unique prime divisors of a number not exceeding max </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an array of <a class="el" href="structfw__u64arr__t.html" title="A fixed capacity array.">fw_u64arr_t</a> structs containing lists of unique prime factors for all numbers not exceeding max, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a576d8ab23202853f3542828de64cdf90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576d8ab23202853f3542828de64cdf90">&#9670;&nbsp;</a></span>sieve_largest_factors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_largest_factors </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the largest prime factor of every number in the range from 0 to max. </p>
<p>Compared to <a class="el" href="sieves_8h.html#a1bca79bd17302449e4a95f833e2990c8">sieve_factors</a>, this uses up to 30 times less memory, so if the range is very large, most numbers will never actually have their factorizations accessed, or the factorizations will only be accessed about once, this function should be preferred. The factors of 0 and 1 are not actually computed, their entries in the returned array will be 0. You can use the resulting table as it is, or convert it to a factorization using <a class="el" href="sieves_8h.html#a819489e812b58ce7b80fd2fea3e76c70">fill_factors_from_largest</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find largest prime factors of all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an array of largest prime factors for all numbers not exceeding max, or NULL on allocation failure. </dd></dl>

</div>
</div>
<a id="a819489e812b58ce7b80fd2fea3e76c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819489e812b58ce7b80fd2fea3e76c70">&#9670;&nbsp;</a></span>fill_factors_from_largest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fill_factors_from_largest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>largest_factors</em>[static n+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a table of largest prime factors to get the factorization of a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Factors struct to store result in. MUST be allocated already, use <a class="el" href="factorization_8h.html#a945694d2072205fb97e92a362f82b2cb">init_factors_t_ub</a> or <a class="el" href="sieves_8h.html#aaa5df5504d790281d05a032095e002a0">max_prime_divs</a> and <a class="el" href="factorization_8h.html#ae82106291453a286003dcd7117253f63">init_factors_t_w</a> if needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to get the factorization of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">largest_factors</td><td>table of largest factors, from <a class="el" href="sieves_8h.html#a576d8ab23202853f3542828de64cdf90">sieve_largest_factors</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd7907ef204356e0be1a802cf5167992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7907ef204356e0be1a802cf5167992">&#9670;&nbsp;</a></span>get_factors_pitch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t get_factors_pitch </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pitch for a pitched array of <a class="el" href="structfw__u64arr__t.html">fw_u64arr_t</a> factor lists. </p>
<p>This is simply offsetof(fw_u64arr_t, elems) + *_w*sizeof(uint64_t). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The maximal number of unique prime divisors of any potential index of the pitched array. Should be obtained from <a class="el" href="sieves_8h.html#a1bca79bd17302449e4a95f833e2990c8">sieve_factors</a>, <a class="el" href="">max_prime_divisors</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pitch of a pitched array of factor list structs whose flexible length members all have w elements. </dd></dl>

</div>
</div>
<a id="a4d2b3d5f592ca1a883b1f5d6292bfea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2b3d5f592ca1a883b1f5d6292bfea6">&#9670;&nbsp;</a></span>sieve_sigma_0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_sigma_0 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of divisors (including 1 and n) for every number n from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="factorization_8h.html#a4659632fb46916482ba089ea5eb215b6">divisor_count</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find divisor counts for all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of divisor counts for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a1e5e2e2afaef3dd04fa1721a4543c3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5e2e2afaef3dd04fa1721a4543c3bf">&#9670;&nbsp;</a></span>sieve_sigma_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_sigma_1 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the sum of divisors (including 1 and n) for every number n from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="factorization_8h.html#a22edae250ec16a4ae6936969335029e8">divisor_sum</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find divisor sums for all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of divisor sums for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a47cf98fd1eedb76b4c337a0b6d5cb88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cf98fd1eedb76b4c337a0b6d5cb88c">&#9670;&nbsp;</a></span>sieve_sigma_e()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_sigma_e </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the sum of some power of divisors (including 1 and n) for every number n from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="factorization_8h.html#a0cdf3ad88357fd8c9995bb110cb6d808">divisor_power_sum</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find divisor power sums for all numbers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>power of divisors for summing, eg 0 would produce divisor counts, 1 divisor sums, 2 sums of squares of divisors, etc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of divisor power sums for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a0fd78cb343ce5afd768c28aacde7b99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd78cb343ce5afd768c28aacde7b99d">&#9670;&nbsp;</a></span>sieve_phi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_phi </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Euler's totient function for every number from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="factorization_8h.html#af21b39861e3bd04966862277f45dbb8e">euler_phi</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find totients for all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of totients for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="ae19a3c1887d6cdc9375c32f0abfd2ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19a3c1887d6cdc9375c32f0abfd2ab3">&#9670;&nbsp;</a></span>sieve_carmichael()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_carmichael </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Carmichael function for every number from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="factorization_8h.html#a25a68da474286694c8abd6c37e26425f">carmichael_lambda</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to compute Carmichael for all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of Carmichael function outputs for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="abdc6cda6e2a6ad9fa55e34267560af3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc6cda6e2a6ad9fa55e34267560af3a">&#9670;&nbsp;</a></span>sieve_mobius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_mobius </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Mobius function for every number from 0 to max. </p>
<p>The result is stored in an array of 2 bit integers, which should be accessed by <a class="el" href="">bitfield2_arr_get</a>. That function will return 0 for 0, 1 for 1, and 3 for -1. 2 will not be stored anywhere in bounds in the resulting array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to compute Mobius for all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a bitfield array of Mobius function outputs for all numbers in the range, with 3 instead of -1, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a30bfef1504f10261d7bbb2b343477d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30bfef1504f10261d7bbb2b343477d09">&#9670;&nbsp;</a></span>compute_mertens_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t* compute_mertens_range </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>mobius</em>[static max/32+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Mertens function (sum of Mobius function) for every number from 0 to max. </p>
<p>Note that this function is signed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of range in which to compute Mertens for all numbers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mobius</td><td>bitfield array of Mobius function outputs (from <a class="el" href="sieves_8h.html#abdc6cda6e2a6ad9fa55e34267560af3a">sieve_mobius</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of Mertens function outputs for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="aff23d64417b86ac7b22c7ccbbc54e820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff23d64417b86ac7b22c7ccbbc54e820">&#9670;&nbsp;</a></span>sieve_is_composite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* sieve_is_composite </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a bitarray of whether or not each number from 0 to max is composite. </p>
<p>1 is composite, and 0 is considered composite here. The result should be used with <a class="el" href="sieves_8h.html#a65e3f8fe2bf00fa39f40fb7468a134e3">is_composite</a> since it is packed (only stores bitflags for numbers coprime to 30). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to check compositeness for all numbers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_num_primes</td><td>the number of primes in the range will be stored here. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a bitarray of whether or not each number in the range is composite, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a65e3f8fe2bf00fa39f40fb7468a134e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e3f8fe2bf00fa39f40fb7468a134e3">&#9670;&nbsp;</a></span>is_composite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_composite </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>buf</em>[static n/30+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a number is composite using a packed bitarray from <a class="el" href="sieves_8h.html#aff23d64417b86ac7b22c7ccbbc54e820">sieve_is_composite</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to check if composite </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>packed bitarray from <a class="el" href="sieves_8h.html#aff23d64417b86ac7b22c7ccbbc54e820">sieve_is_composite</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if n is composite, false if n is prime </dd></dl>

</div>
</div>
<a id="ae6a8da8730b149433ac438cb106479e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a8da8730b149433ac438cb106479e4">&#9670;&nbsp;</a></span>sieve_primes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_primes </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>_num_primes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an array of all primes from 0 to max. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_num_primes</td><td>how many primes were found in the range (this pointer cannot be null) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of all primes from 0 to max, or NULL on allocation failure </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_073faa820624379b5730e5b4f5cb1c42.html">nut</a></li><li class="navelem"><a class="el" href="sieves_8h.html">sieves.h</a></li>
    <li class="footer">Generated on Sat Apr 15 2023 07:58:00 for Number Theory Utils by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
