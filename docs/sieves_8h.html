<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Number Theory Utils: include/nut/sieves.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_awesome_sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="/Number-Theory-Utils/index.html">Number Theory Utils</a><span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('sieves_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sieves.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.2.0 </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Sieve based functions for computing primes in a range or divisor counts/ power sums/Euler's totient function/Carmichael's function on all numbers in a range. Arrays returned from sieve functions should be freed when no longer needed. </p>

<p class="definition">Definition in file <a class="el" href="sieves_8h_source.html">sieves.h</a>.</p>
</div>
<p><a href="sieves_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afa15dcb7788004e5e535f13abeefd29c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#afa15dcb7788004e5e535f13abeefd29c">__attribute__</a> ((const)) uint64_t max_prime_divs(uint64_t max)</td></tr>
<tr class="memdesc:afa15dcb7788004e5e535f13abeefd29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum number of unique prime divisors a number can have.  <a href="sieves_8h.html#afa15dcb7788004e5e535f13abeefd29c">More...</a><br /></td></tr>
<tr class="separator:afa15dcb7788004e5e535f13abeefd29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c6fdffba3e00f27b3e16f544272a64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a05c6fdffba3e00f27b3e16f544272a64">__attribute__</a> ((pure)) static inline void *pitch_arr_get(void *buf</td></tr>
<tr class="memdesc:a05c6fdffba3e00f27b3e16f544272a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an entry from a variable pitch array.  <a href="sieves_8h.html#a05c6fdffba3e00f27b3e16f544272a64">More...</a><br /></td></tr>
<tr class="separator:a05c6fdffba3e00f27b3e16f544272a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b7ec1e3f2ac442b0f098861f758cff"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a55b7ec1e3f2ac442b0f098861f758cff">sieve_factorizations</a> (uint64_t max, uint64_t *_w)</td></tr>
<tr class="memdesc:a55b7ec1e3f2ac442b0f098861f758cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the factorization for every number in the range from 0 to max.  <a href="sieves_8h.html#a55b7ec1e3f2ac442b0f098861f758cff">More...</a><br /></td></tr>
<tr class="separator:a55b7ec1e3f2ac442b0f098861f758cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bca79bd17302449e4a95f833e2990c8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a1bca79bd17302449e4a95f833e2990c8">sieve_factors</a> (uint64_t max, uint64_t *_w)</td></tr>
<tr class="memdesc:a1bca79bd17302449e4a95f833e2990c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the unique prime factors of every number in the range from 0 to max.  <a href="sieves_8h.html#a1bca79bd17302449e4a95f833e2990c8">More...</a><br /></td></tr>
<tr class="separator:a1bca79bd17302449e4a95f833e2990c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576d8ab23202853f3542828de64cdf90"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a576d8ab23202853f3542828de64cdf90">sieve_largest_factors</a> (uint64_t max)</td></tr>
<tr class="memdesc:a576d8ab23202853f3542828de64cdf90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the largest prime factor of every number in the range from 0 to max.  <a href="sieves_8h.html#a576d8ab23202853f3542828de64cdf90">More...</a><br /></td></tr>
<tr class="separator:a576d8ab23202853f3542828de64cdf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819489e812b58ce7b80fd2fea3e76c70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a819489e812b58ce7b80fd2fea3e76c70">fill_factors_from_largest</a> (<a class="el" href="structfactors__t.html">factors_t</a> *out, uint64_t n, const uint64_t largest_factors[static n+1])</td></tr>
<tr class="memdesc:a819489e812b58ce7b80fd2fea3e76c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a table of largest prime factors to get the factorization of a number.  <a href="sieves_8h.html#a819489e812b58ce7b80fd2fea3e76c70">More...</a><br /></td></tr>
<tr class="separator:a819489e812b58ce7b80fd2fea3e76c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2b3d5f592ca1a883b1f5d6292bfea6"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a4d2b3d5f592ca1a883b1f5d6292bfea6">sieve_sigma_0</a> (uint64_t max)</td></tr>
<tr class="memdesc:a4d2b3d5f592ca1a883b1f5d6292bfea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of divisors (including 1 and n) for every number n from 0 to max.  <a href="sieves_8h.html#a4d2b3d5f592ca1a883b1f5d6292bfea6">More...</a><br /></td></tr>
<tr class="separator:a4d2b3d5f592ca1a883b1f5d6292bfea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5e2e2afaef3dd04fa1721a4543c3bf"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a1e5e2e2afaef3dd04fa1721a4543c3bf">sieve_sigma_1</a> (uint64_t max)</td></tr>
<tr class="memdesc:a1e5e2e2afaef3dd04fa1721a4543c3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of divisors (including 1 and n) for every number n from 0 to max.  <a href="sieves_8h.html#a1e5e2e2afaef3dd04fa1721a4543c3bf">More...</a><br /></td></tr>
<tr class="separator:a1e5e2e2afaef3dd04fa1721a4543c3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cf98fd1eedb76b4c337a0b6d5cb88c"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a47cf98fd1eedb76b4c337a0b6d5cb88c">sieve_sigma_e</a> (uint64_t max, uint64_t e)</td></tr>
<tr class="memdesc:a47cf98fd1eedb76b4c337a0b6d5cb88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of some power of divisors (including 1 and n) for every number n from 0 to max.  <a href="sieves_8h.html#a47cf98fd1eedb76b4c337a0b6d5cb88c">More...</a><br /></td></tr>
<tr class="separator:a47cf98fd1eedb76b4c337a0b6d5cb88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed770659cc6a2bf375294b20efefd4a"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a0ed770659cc6a2bf375294b20efefd4a">sieve_dk</a> (uint64_t max, uint64_t k)</td></tr>
<tr class="memdesc:a0ed770659cc6a2bf375294b20efefd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the generalized divisor function dk(n) (number of k-tuples with product n) for every number n from 0 to max.  <a href="sieves_8h.html#a0ed770659cc6a2bf375294b20efefd4a">More...</a><br /></td></tr>
<tr class="separator:a0ed770659cc6a2bf375294b20efefd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd78cb343ce5afd768c28aacde7b99d"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a0fd78cb343ce5afd768c28aacde7b99d">sieve_phi</a> (uint64_t max)</td></tr>
<tr class="memdesc:a0fd78cb343ce5afd768c28aacde7b99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Euler's totient function for every number from 0 to max.  <a href="sieves_8h.html#a0fd78cb343ce5afd768c28aacde7b99d">More...</a><br /></td></tr>
<tr class="separator:a0fd78cb343ce5afd768c28aacde7b99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19a3c1887d6cdc9375c32f0abfd2ab3"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#ae19a3c1887d6cdc9375c32f0abfd2ab3">sieve_carmichael</a> (uint64_t max)</td></tr>
<tr class="memdesc:ae19a3c1887d6cdc9375c32f0abfd2ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Carmichael function for every number from 0 to max.  <a href="sieves_8h.html#ae19a3c1887d6cdc9375c32f0abfd2ab3">More...</a><br /></td></tr>
<tr class="separator:ae19a3c1887d6cdc9375c32f0abfd2ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18155611a81e12f7f810d4cdf6bccb36"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a18155611a81e12f7f810d4cdf6bccb36">sieve_mobius</a> (uint64_t max)</td></tr>
<tr class="memdesc:a18155611a81e12f7f810d4cdf6bccb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Mobius function for every number from 0 to max.  <a href="sieves_8h.html#a18155611a81e12f7f810d4cdf6bccb36">More...</a><br /></td></tr>
<tr class="separator:a18155611a81e12f7f810d4cdf6bccb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c821be2ce97e14345bbf6430b76fc5c"><td class="memItemLeft" align="right" valign="top">int64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a1c821be2ce97e14345bbf6430b76fc5c">compute_mertens_range</a> (uint64_t max, const uint8_t mobius[static max/4+1])</td></tr>
<tr class="memdesc:a1c821be2ce97e14345bbf6430b76fc5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Mertens function (sum of Mobius function) for every number from 0 to max.  <a href="sieves_8h.html#a1c821be2ce97e14345bbf6430b76fc5c">More...</a><br /></td></tr>
<tr class="separator:a1c821be2ce97e14345bbf6430b76fc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff23d64417b86ac7b22c7ccbbc54e820"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#aff23d64417b86ac7b22c7ccbbc54e820">sieve_is_composite</a> (uint64_t max)</td></tr>
<tr class="memdesc:aff23d64417b86ac7b22c7ccbbc54e820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bitarray of whether or not each number from 0 to max is composite.  <a href="sieves_8h.html#aff23d64417b86ac7b22c7ccbbc54e820">More...</a><br /></td></tr>
<tr class="separator:aff23d64417b86ac7b22c7ccbbc54e820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e3f8fe2bf00fa39f40fb7468a134e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a65e3f8fe2bf00fa39f40fb7468a134e3">is_composite</a> (uint64_t n, const uint8_t buf[static n/30+1])</td></tr>
<tr class="memdesc:a65e3f8fe2bf00fa39f40fb7468a134e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a number is composite using a packed bitarray from <a class="el" href="sieves_8h.html#aff23d64417b86ac7b22c7ccbbc54e820">sieve_is_composite</a>.  <a href="sieves_8h.html#a65e3f8fe2bf00fa39f40fb7468a134e3">More...</a><br /></td></tr>
<tr class="separator:a65e3f8fe2bf00fa39f40fb7468a134e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a885035538c90202cc90bf1283ae0f1"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#a3a885035538c90202cc90bf1283ae0f1">compute_pi_range</a> (uint64_t max, const uint8_t buf[static max/30+1])</td></tr>
<tr class="memdesc:a3a885035538c90202cc90bf1283ae0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the pi (prime counting) function for every number from 0 to max.  <a href="sieves_8h.html#a3a885035538c90202cc90bf1283ae0f1">More...</a><br /></td></tr>
<tr class="separator:a3a885035538c90202cc90bf1283ae0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e642f16b95823b059f52132a7dffa6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#af4e642f16b95823b059f52132a7dffa6">__attribute__</a> ((no_sanitize(&quot;vla-bound&quot;))) uint64_t compute_pi_from_tables(uint64_t n</td></tr>
<tr class="memdesc:af4e642f16b95823b059f52132a7dffa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value for the pi (prime counting) function for a particular number using precomputed tables.  <a href="sieves_8h.html#af4e642f16b95823b059f52132a7dffa6">More...</a><br /></td></tr>
<tr class="separator:af4e642f16b95823b059f52132a7dffa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a8da8730b149433ac438cb106479e4"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sieves_8h.html#ae6a8da8730b149433ac438cb106479e4">sieve_primes</a> (uint64_t max, uint64_t *_num_primes)</td></tr>
<tr class="memdesc:ae6a8da8730b149433ac438cb106479e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an array of all primes from 0 to max.  <a href="sieves_8h.html#ae6a8da8730b149433ac438cb106479e4">More...</a><br /></td></tr>
<tr class="separator:ae6a8da8730b149433ac438cb106479e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afd6e633d4e5b0b4e8ce8b5054cc50d71"><td class="memItemLeft" align="right" valign="top"><a id="afd6e633d4e5b0b4e8ce8b5054cc50d71"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>pitch</b></td></tr>
<tr class="separator:afd6e633d4e5b0b4e8ce8b5054cc50d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717c50cfde3924051c279a89096afd3d"><td class="memItemLeft" align="right" valign="top">size_t uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>i</b></td></tr>
<tr class="separator:a717c50cfde3924051c279a89096afd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f84db08c85d7a78c13217dbdee3cd3"><td class="memItemLeft" align="right" valign="top"><a id="ae4f84db08c85d7a78c13217dbdee3cd3"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>pi_table</b> [static n/30]</td></tr>
<tr class="separator:ae4f84db08c85d7a78c13217dbdee3cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086e270b5e2620ab49f50bdd9eb88364"><td class="memItemLeft" align="right" valign="top"><a id="a086e270b5e2620ab49f50bdd9eb88364"></a>
const uint64_t const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>buf</b> [static n/30+1]</td></tr>
<tr class="separator:a086e270b5e2620ab49f50bdd9eb88364"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="afa15dcb7788004e5e535f13abeefd29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa15dcb7788004e5e535f13abeefd29c">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(const)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum number of unique prime divisors a number can have. </p>
<p>Get the pitch for a pitched array of <a class="el" href="structfw__u64arr__t.html">fw_u64arr_t</a> factor lists.</p>
<p>Get the pitch for a pitched array of factorization structs with w unique prime divisors.</p>
<p>Compute an upper bound on the number of primes up to max.</p>
<p>This has nothing to do with factoring the number and is just a simple binary decision diagram based on comparing the number to 2, 2*3, 2*3*5, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>number to find max unique prime divisors of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the largest number of unique prime divisors any number not exceeding max can possibly have</dd></dl>
<p>This uses an inequality involving log derived from the prime number theorem to always get an upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>number to find the number of primes up to </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">an</td><td>upper bound on the number of primes up to max</td></tr>
  </table>
  </dd>
</dl>
<p>This is simply offsetof(factors_t, factors) + w*sizeof(dummy-&gt;factors[0]), where dummy is an expression with type <a class="el" href="structfactors__t.html" title="A prime factorization.">factors_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The maximal number of unique prime divisors of any potential index of the pitched array. Should be obtained from <a class="el" href="sieves_8h.html#a55b7ec1e3f2ac442b0f098861f758cff">sieve_factorizations</a>, <a class="el" href="">max_prime_divisors</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pitch of a pitched array of factorization structs whose flexible length members all have w elements.</dd></dl>
<p>This is simply offsetof(fw_u64arr_t, elems) + *_w*sizeof(uint64_t). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The maximal number of unique prime divisors of any potential index of the pitched array. Should be obtained from <a class="el" href="sieves_8h.html#a1bca79bd17302449e4a95f833e2990c8">sieve_factors</a>, <a class="el" href="">max_prime_divisors</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pitch of a pitched array of factor list structs whose flexible length members all have w elements.</dd></dl>
<p>Compute the maximum number of unique prime divisors a number can have.</p>
<p>Get the pitch for a pitched array of <a class="el" href="structfw__u64arr__t.html">fw_u64arr_t</a> factor lists.</p>
<p>Get the pitch for a pitched array of factorization structs with w unique prime divisors.</p>
<p>Compute an upper bound on the number of primes up to max.</p>
<p>Compute the square root of a quadratic residue mod a prime.</p>
<p>Compute the Jacobi symbol of n mod k.</p>
<p>Compute the least common multiple of a and b Divides the product by the gcd so can overflow for large arguments.</p>
<p>Compute n mod pq st n = a mod p and n = b mod q, where p and q are coprime.</p>
<p>Compute the Euclidean remainder r = a mod n for positive n so that 0 &lt;= r &lt; n.</p>
<p>Compute nonnegative integral power of a number modulo another using binary exponentiation.</p>
<p>Same as <a class="el" href="">factor1_lenstra</a> but using a projective Montgomery curve and Montgomery ladder.</p>
<p>Try to find a factor of a number using Lenstra ecf.</p>
<p>Try to find a factor of a number using Pollard's Rho algorithm with Brent cycle finding and gcd coalescing.</p>
<p>Try to find a factor of a number using Pollard's Rho algorithm with Floyd cycle finding.</p>
<p>Get the floor of the nth root of a.</p>
<p>7 partictular bases are used so that no composite number will falsely be reported as prime for the entire 64-bit range </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to check for primality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if n is prime, false otherwise</dd></dl>
<p>Uses bitscan to estimate the base 2 log and in turn nth root of a, then uses Newton's method </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the number to take the nth root of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>root to take </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>floor(a**(1/n)), ie the largest integer x such that x**n &lt;= a</dd></dl>
<p>Note that this will not find factors of 4 or 25 no matter what x is. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>random value mod n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise</dd></dl>
<p>Note that his will not find factors of 4 or 25 no matter what x is. m does not affect whether x will lead to a factor of n, it just means each iteration will be cheaper but up to 2m extraneous iterations could be performed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>random value mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of iterations per gcd check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise</dd></dl>
<p>In particular, an affine wierstrass representation is used internally and scalar multiplication is done using a binary "double and add" algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y,a</td><td>random values mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>number of trials before giving up (we compute kP for k from 2 to B) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise</dd></dl>
<p>Instead of an affine Wierstrass curve and binary multiplication. This is supposed to be faster but seems to be about the same. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y,a</td><td>random numbers mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>number of trials before giving up (we compute kP for k from 2 to B) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b,e,n</td><td>base, exponent, and modulus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>b^e mod n, computed via binary exponentiation</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,n</td><td>dividend and divisor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mod n</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,p,b,q</td><td>Chinese Remainder Theorem parameters. The residues a and b should not be negative. The moduli p and q should be coprime. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 &lt;= 0 &lt; pq so that n = a mod p and n = b mod q</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>numbers to find lcm of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lcm(a, b)</dd></dl>
<p>Uses modified euclidean algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n,k</td><td>Jacobi symbol parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jacobi symbol (0 if k | n, +1 if n is a quadratic residue mod an odd number of prime divisors of k (with multiplicity), -1 otherwise)</dd></dl>
<p>If n is not a residue or p is not a prime, the value returned may not be useful but the function will terminate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>a quadratic residue mod p </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a prime </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>r so that r^2 = n mod p</dd></dl>
<p>This uses an inequality involving log derived from the prime number theorem to always get an upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>number to find the number of primes up to </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">an</td><td>upper bound on the number of primes up to max</td></tr>
  </table>
  </dd>
</dl>
<p>This is simply offsetof(factors_t, factors) + w*sizeof(dummy-&gt;factors[0]), where dummy is an expression with type <a class="el" href="structfactors__t.html" title="A prime factorization.">factors_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The maximal number of unique prime divisors of any potential index of the pitched array. Should be obtained from <a class="el" href="sieves_8h.html#a55b7ec1e3f2ac442b0f098861f758cff">sieve_factorizations</a>, <a class="el" href="">max_prime_divisors</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pitch of a pitched array of factorization structs whose flexible length members all have w elements.</dd></dl>
<p>This is simply offsetof(fw_u64arr_t, elems) + *_w*sizeof(uint64_t). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The maximal number of unique prime divisors of any potential index of the pitched array. Should be obtained from <a class="el" href="sieves_8h.html#a1bca79bd17302449e4a95f833e2990c8">sieve_factors</a>, <a class="el" href="">max_prime_divisors</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pitch of a pitched array of factor list structs whose flexible length members all have w elements.</dd></dl>
<p>Compute the maximum number of unique prime divisors a number can have.</p>
<p>Compute the square root of a quadratic residue mod a prime.</p>
<p>Compute the Jacobi symbol of n mod k.</p>
<p>Compute the least common multiple of a and b Divides the product by the gcd so can overflow for large arguments.</p>
<p>Compute n mod pq st n = a mod p and n = b mod q, where p and q are coprime.</p>
<p>Compute the Euclidean remainder r = a mod n for positive n so that 0 &lt;= r &lt; n.</p>
<p>Compute nonnegative integral power of a number modulo another using binary exponentiation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b,e</td><td>base and exponent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>b^e, not checked for overflow</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b,e,n</td><td>base, exponent, and modulus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>b^e mod n, computed via binary exponentiation</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,n</td><td>dividend and divisor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mod n</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,p,b,q</td><td>Chinese Remainder Theorem parameters. The residues a and b should not be negative. The moduli p and q should be coprime. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 &lt;= 0 &lt; pq so that n = a mod p and n = b mod q</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>numbers to find lcm of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lcm(a, b)</dd></dl>
<p>Uses modified euclidean algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n,k</td><td>Jacobi symbol parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jacobi symbol (0 if k | n, +1 if n is a quadratic residue mod an odd number of prime divisors of k (with multiplicity), -1 otherwise)</dd></dl>
<p>If n is not a residue or p is not a prime, the value returned may not be useful but the function will terminate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>a quadratic residue mod p </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a prime </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>r so that r^2 = n mod p </dd></dl>

</div>
</div>
<a id="a05c6fdffba3e00f27b3e16f544272a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c6fdffba3e00f27b3e16f544272a64">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(pure)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an entry from a variable pitch array. </p>
<p>Get an element from an array of bitfields of length 2, aka uint2's.</p>
<p>Get a bit from a bitarray.</p>
<p>In a normal array, the element type is a complete type with size known at compile time, or even a variably modified type for which sizeof and ordinary array operations will work as desired. However, it is sometimes useful to have arrays whose elements are structs with flexible length array members, and because flexible length arrays do not have their lengths automatically tracked like static or variable length arrays, we can't use sizeof or ordinary array operations. In particular, sizeof returns the padded size assuming the flexible length array has zero length, and array operations work as if we had an array of structs where the flexible length array has zero length. This function instead takes the base pointer of the array, the pitch, and the index, and returns a pointer to a member without bounds checking. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to the start of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitch</td><td>offset from start of one element to start of next element (currently should be computed as offsetof(type, fla_member) + w*fla_element_size, but a more complex computation should be used if alignment is critically important) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of element to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the i-th member of an array with given base and pitch</dd></dl>
<p>Simply does buf[i/64] &amp; (1ull &lt;&lt; (i%64)). Only the truthiness of the result should be considered, all nonzero values should be treated as equivalent </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to bitarray </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of element to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if i-th element is false, nonzero otherwise</dd></dl>
<p>The result will be shifted to the least significant position, that is, only 0, 1, 2, and 3 are possible results. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to array of bitfields </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of element to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>i-th element (0, 1, 2, or 3) </dd></dl>

</div>
</div>
<a id="a55b7ec1e3f2ac442b0f098861f758cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b7ec1e3f2ac442b0f098861f758cff">&#9670;&nbsp;</a></span>sieve_factorizations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sieve_factorizations </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>_w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the factorization for every number in the range from 0 to max. </p>
<p>The factorizations for 0 and 1 are not actually computed. The factorizations are stored in an array of <a class="el" href="structfactors__t.html" title="A prime factorization.">factors_t</a> structs with capacity w, where w is the maximum number of unique prime divisors of a number not exceeding max. The result is a pitched array. <a class="el" href="">pitch_arr_get</a> should be used to handle the returned value. <a class="el" href="">get_factorizations_pitch</a> should be used to get the pitch from the output parameter w. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to factor all numbers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_w</td><td>store w, the maximum number of unique prime divisors of a number not exceeding max </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an array of <a class="el" href="structfactors__t.html" title="A prime factorization.">factors_t</a> structs containing the factorization of all numbers not exceeding max, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a1bca79bd17302449e4a95f833e2990c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bca79bd17302449e4a95f833e2990c8">&#9670;&nbsp;</a></span>sieve_factors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sieve_factors </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>_w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the unique prime factors of every number in the range from 0 to max. </p>
<p>The factors for 0 and 1 are not actually computed. The result is stored in an array of <a class="el" href="structfw__u64arr__t.html" title="A fixed capacity array.">fw_u64arr_t</a> structs with capacity w, where w is the maximum number of unique prime divisors of a number not exceeding max. The pitch of the result may be obtained with <a class="el" href="">get_factors_pitch</a>. <a class="el" href="">pitch_arr_get</a> should be used to handle the returned value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find unique prime factors of all numbers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_w</td><td>maximum numer of unique prime divisors of a number not exceeding max </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an array of <a class="el" href="structfw__u64arr__t.html" title="A fixed capacity array.">fw_u64arr_t</a> structs containing lists of unique prime factors for all numbers not exceeding max, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a576d8ab23202853f3542828de64cdf90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576d8ab23202853f3542828de64cdf90">&#9670;&nbsp;</a></span>sieve_largest_factors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_largest_factors </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the largest prime factor of every number in the range from 0 to max. </p>
<p>Compared to <a class="el" href="sieves_8h.html#a1bca79bd17302449e4a95f833e2990c8">sieve_factors</a>, this uses up to 30 times less memory, so if the range is very large, most numbers will never actually have their factorizations accessed, or the factorizations will only be accessed about once, this function should be preferred. The factors of 0 and 1 are not actually computed, their entries in the returned array will be 0. You can use the resulting table as it is, or convert it to a factorization using <a class="el" href="sieves_8h.html#a819489e812b58ce7b80fd2fea3e76c70">fill_factors_from_largest</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find largest prime factors of all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an array of largest prime factors for all numbers not exceeding max, or NULL on allocation failure. </dd></dl>

</div>
</div>
<a id="a819489e812b58ce7b80fd2fea3e76c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819489e812b58ce7b80fd2fea3e76c70">&#9670;&nbsp;</a></span>fill_factors_from_largest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fill_factors_from_largest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>largest_factors</em>[static n+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a table of largest prime factors to get the factorization of a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Factors struct to store result in. MUST be allocated already, use <a class="el" href="">init_factors_t_ub</a> or <a class="el" href="">max_prime_divs</a> and <a class="el" href="">init_factors_t_w</a> if needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to get the factorization of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">largest_factors</td><td>table of largest factors, from <a class="el" href="sieves_8h.html#a576d8ab23202853f3542828de64cdf90">sieve_largest_factors</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d2b3d5f592ca1a883b1f5d6292bfea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2b3d5f592ca1a883b1f5d6292bfea6">&#9670;&nbsp;</a></span>sieve_sigma_0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_sigma_0 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of divisors (including 1 and n) for every number n from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="">divisor_count</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find divisor counts for all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of divisor counts for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a1e5e2e2afaef3dd04fa1721a4543c3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5e2e2afaef3dd04fa1721a4543c3bf">&#9670;&nbsp;</a></span>sieve_sigma_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_sigma_1 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the sum of divisors (including 1 and n) for every number n from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="">divisor_sum</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find divisor sums for all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of divisor sums for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a47cf98fd1eedb76b4c337a0b6d5cb88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cf98fd1eedb76b4c337a0b6d5cb88c">&#9670;&nbsp;</a></span>sieve_sigma_e()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_sigma_e </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the sum of some power of divisors (including 1 and n) for every number n from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="">divisor_power_sum</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find divisor power sums for all numbers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>power of divisors for summing, eg 0 would produce divisor counts, 1 divisor sums, 2 sums of squares of divisors, etc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of divisor power sums for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a0ed770659cc6a2bf375294b20efefd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed770659cc6a2bf375294b20efefd4a">&#9670;&nbsp;</a></span>sieve_dk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_dk </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the generalized divisor function dk(n) (number of k-tuples with product n) for every number n from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="">divisor_tuple_count</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately. Note that dk is multiplicative so dk(mn) = dk(m)dk(n) when m and n are coprime, and dk(p^a) = binom(a + k, k) for prime powers. In other words, dk is exponential in k and this function will overflow if max^k is too large. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to compute generalized divisor function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of factors per factorization, eg for a prime power p^a we get binom(a + k, k). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of dk results, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a0fd78cb343ce5afd768c28aacde7b99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd78cb343ce5afd768c28aacde7b99d">&#9670;&nbsp;</a></span>sieve_phi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_phi </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Euler's totient function for every number from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="">euler_phi</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to find totients for all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of totients for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="ae19a3c1887d6cdc9375c32f0abfd2ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19a3c1887d6cdc9375c32f0abfd2ab3">&#9670;&nbsp;</a></span>sieve_carmichael()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_carmichael </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Carmichael function for every number from 0 to max. </p>
<p>The results for 0 and 1 are not actually computed. This effectively computes <a class="el" href="">carmichael_lambda</a> for all numbers in the range, but without needing to compute or store the factorizations intermediately </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to compute Carmichael for all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of Carmichael function outputs for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a18155611a81e12f7f810d4cdf6bccb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18155611a81e12f7f810d4cdf6bccb36">&#9670;&nbsp;</a></span>sieve_mobius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* sieve_mobius </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Mobius function for every number from 0 to max. </p>
<p>The result is stored in an array of 2 bit integers, which should be accessed by <a class="el" href="">bitfield2_arr_get</a>. That function will return 0 for 0, 1 for 1, and 3 for -1. 2 will not be stored anywhere in bounds in the resulting array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to compute Mobius for all numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a bitfield array of Mobius function outputs for all numbers in the range, with 3 instead of -1, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a1c821be2ce97e14345bbf6430b76fc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c821be2ce97e14345bbf6430b76fc5c">&#9670;&nbsp;</a></span>compute_mertens_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t* compute_mertens_range </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mobius</em>[static max/4+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Mertens function (sum of Mobius function) for every number from 0 to max. </p>
<p>Note that this function is signed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of range in which to compute Mertens for all numbers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mobius</td><td>bitfield array of Mobius function outputs (from <a class="el" href="sieves_8h.html#a18155611a81e12f7f810d4cdf6bccb36">sieve_mobius</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of Mertens function outputs for all numbers in the range, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="aff23d64417b86ac7b22c7ccbbc54e820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff23d64417b86ac7b22c7ccbbc54e820">&#9670;&nbsp;</a></span>sieve_is_composite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* sieve_is_composite </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a bitarray of whether or not each number from 0 to max is composite. </p>
<p>1 is composite, and 0 is considered composite here. The result should be used with <a class="el" href="sieves_8h.html#a65e3f8fe2bf00fa39f40fb7468a134e3">is_composite</a> since it is packed (only stores bitflags for numbers coprime to 30). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range in which to check compositeness for all numbers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_num_primes</td><td>the number of primes in the range will be stored here. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a bitarray of whether or not each number in the range is composite, or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a65e3f8fe2bf00fa39f40fb7468a134e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e3f8fe2bf00fa39f40fb7468a134e3">&#9670;&nbsp;</a></span>is_composite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_composite </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>buf</em>[static n/30+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a number is composite using a packed bitarray from <a class="el" href="sieves_8h.html#aff23d64417b86ac7b22c7ccbbc54e820">sieve_is_composite</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to check if composite </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>packed bitarray from <a class="el" href="sieves_8h.html#aff23d64417b86ac7b22c7ccbbc54e820">sieve_is_composite</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if n is composite, false if n is prime </dd></dl>

</div>
</div>
<a id="a3a885035538c90202cc90bf1283ae0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a885035538c90202cc90bf1283ae0f1">&#9670;&nbsp;</a></span>compute_pi_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* compute_pi_range </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>buf</em>[static max/30+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the pi (prime counting) function for every number from 0 to max. </p>
<p>The result should be used with <a class="el" href="">compute_pi_from_tables</a> since pi is only actually calculated at every 240th number since intermediate results can be computed with a single popcount on the packed buf bitarray. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of range to compute pi function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>packed bitarray from <a class="el" href="sieves_8h.html#aff23d64417b86ac7b22c7ccbbc54e820">sieve_is_composite</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of pi values at every 240th number (use <a class="el" href="">compute_pi_from_tables</a>) </dd></dl>

</div>
</div>
<a id="af4e642f16b95823b059f52132a7dffa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e642f16b95823b059f52132a7dffa6">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(no_sanitize(&quot;vla-bound&quot;))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value for the pi (prime counting) function for a particular number using precomputed tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to calculate pi for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pi_table</td><td>array of partial pi values from <a class="el" href="sieves_8h.html#a3a885035538c90202cc90bf1283ae0f1">compute_pi_range</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>packed bitarray from <a class="el" href="sieves_8h.html#aff23d64417b86ac7b22c7ccbbc54e820">sieve_is_composite</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of primes &lt;= n </dd></dl>

</div>
</div>
<a id="ae6a8da8730b149433ac438cb106479e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a8da8730b149433ac438cb106479e4">&#9670;&nbsp;</a></span>sieve_primes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* sieve_primes </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>_num_primes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an array of all primes from 0 to max. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>inclusive upper bound of sieving range </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_num_primes</td><td>how many primes were found in the range (this pointer cannot be null) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of all primes from 0 to max, or NULL on allocation failure </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a717c50cfde3924051c279a89096afd3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717c50cfde3924051c279a89096afd3d">&#9670;&nbsp;</a></span>i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t i</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> buf + i*pitch</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="sieves_8h_source.html#l00051">51</a> of file <a class="el" href="sieves_8h_source.html">sieves.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_073faa820624379b5730e5b4f5cb1c42.html">nut</a></li><li class="navelem"><a class="el" href="sieves_8h.html">sieves.h</a></li>
    <li class="footer">Generated on Wed May 10 2023 08:55:10 for Number Theory Utils by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
