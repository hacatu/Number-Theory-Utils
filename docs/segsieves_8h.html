<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Number Theory Utils: include/nut/segsieves.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_awesome_sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="/Number-Theory-Utils/index.html">Number Theory Utils</a><span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('segsieves_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">segsieves.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.2.0 </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Sieve based functions that work on segments, so that you can use all the cores your little heart desires </p>

<p class="definition">Definition in file <a class="el" href="segsieves_8h_source.html">segsieves.h</a>.</p>
</div>
<p><a href="segsieves_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnut__Segsieve.html">nut_Segsieve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aea1131cb90084877a4790ef07db28722" id="r_aea1131cb90084877a4790ef07db28722"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segsieves_8h.html#aea1131cb90084877a4790ef07db28722">nut_Segsieve_init</a> (<a class="el" href="structnut__Segsieve.html">nut_Segsieve</a> *self, uint64_t max, uint64_t preferred_bucket_size)</td></tr>
<tr class="memdesc:aea1131cb90084877a4790ef07db28722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the sieving primes header for a segmented sieve.  <br /></td></tr>
<tr class="separator:aea1131cb90084877a4790ef07db28722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e0d78f34393f3e40d8fa5845d13936" id="r_a78e0d78f34393f3e40d8fa5845d13936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segsieves_8h.html#a78e0d78f34393f3e40d8fa5845d13936">nut_Segsieve_destroy</a> (<a class="el" href="structnut__Segsieve.html">nut_Segsieve</a> *self)</td></tr>
<tr class="memdesc:a78e0d78f34393f3e40d8fa5845d13936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the resources held by a segmented sieve header.  <br /></td></tr>
<tr class="separator:a78e0d78f34393f3e40d8fa5845d13936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d982dae9f7f9d0e2b8c676ef3ab18b" id="r_ac2d982dae9f7f9d0e2b8c676ef3ab18b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segsieves_8h.html#ac2d982dae9f7f9d0e2b8c676ef3ab18b">nut_Segsieve_factorizations</a> (const <a class="el" href="structnut__Segsieve.html">nut_Segsieve</a> *restrict self, uint64_t a, uint64_t b, size_t pitch, void *buffer)</td></tr>
<tr class="memdesc:ac2d982dae9f7f9d0e2b8c676ef3ab18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sieve all factorizations in the range [a, b) using a modified, in place largest factor sieve This uses a pitched array of factorization structs <code><a class="el" href="structnut__Factors.html">nut_Factors</a></code>, so it uses a lot of memory per element in the segment, and the segment size should be lowered accordingly.  <br /></td></tr>
<tr class="separator:ac2d982dae9f7f9d0e2b8c676ef3ab18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9de793862541e4297214febac185349" id="r_ab9de793862541e4297214febac185349"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segsieves_8h.html#ab9de793862541e4297214febac185349">nut_Segsieve_factorizations_mkbuffer</a> (const <a class="el" href="structnut__Segsieve.html">nut_Segsieve</a> *self, size_t *pitch)</td></tr>
<tr class="memdesc:ab9de793862541e4297214febac185349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a buffer for a thread to pass to <code><a class="el" href="segsieves_8h.html#ac2d982dae9f7f9d0e2b8c676ef3ab18b">nut_Segsieve_factorizations</a></code> on its intervals.  <br /></td></tr>
<tr class="separator:ab9de793862541e4297214febac185349"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aea1131cb90084877a4790ef07db28722" name="aea1131cb90084877a4790ef07db28722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1131cb90084877a4790ef07db28722">&#9670;&#160;</a></span>nut_Segsieve_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_Segsieve_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Segsieve.html">nut_Segsieve</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>preferred_bucket_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up the sieving primes header for a segmented sieve. </p>
<p>The user can then divide the range into segments as desired and process them in multiple threads, by calling <code>nut_Segsieve_*</code> functions with <code>[a, b)</code> intervals that partition the range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">self</td><td>the segsieve header to initialize. Must be freed with <code><a class="el" href="segsieves_8h.html#a78e0d78f34393f3e40d8fa5845d13936">nut_Segsieve_destroy</a></code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>the inclusive upper bound of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preferred_bucket_size</td><td>designed to tell algorithms how big buckets should be for optimal cache use etc. Currently not really used. If 0, we just pick sqrt_max, and if nonzero, we forward it to self </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, in which case self contains a list of sieving primes and other information, or false on (allocation) failure </dd></dl>

</div>
</div>
<a id="a78e0d78f34393f3e40d8fa5845d13936" name="a78e0d78f34393f3e40d8fa5845d13936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e0d78f34393f3e40d8fa5845d13936">&#9670;&#160;</a></span>nut_Segsieve_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nut_Segsieve_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Segsieve.html">nut_Segsieve</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the resources held by a segmented sieve header. </p>
<p>Note that this does not free per-thread work buffers or other resources not directly managed by self. </p>

</div>
</div>
<a id="ac2d982dae9f7f9d0e2b8c676ef3ab18b" name="ac2d982dae9f7f9d0e2b8c676ef3ab18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d982dae9f7f9d0e2b8c676ef3ab18b">&#9670;&#160;</a></span>nut_Segsieve_factorizations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nut_Segsieve_factorizations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnut__Segsieve.html">nut_Segsieve</a> *restrict&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sieve all factorizations in the range [a, b) using a modified, in place largest factor sieve This uses a pitched array of factorization structs <code><a class="el" href="structnut__Factors.html">nut_Factors</a></code>, so it uses a lot of memory per element in the segment, and the segment size should be lowered accordingly. </p>
<p>In particular, we use 8 + 16*(omega+1) bytes PER segment entry, where omega is the max number of distinct prime divisors, which can be up to 15, ie up to 264 bytes per entry. So for example, if using a CPU with 512k L1d cache per core and smt, and sieving numbers over 614889782588491410, omega can be 15 so we would use a preferred bucket size of 992. If the upper bound were 10^12 instead, then omega is at most 11, so we use a preferred bucket size of 1310, Or you can just try a larger bucket size, since ~1k buckets are insanely small. My computer also has 16m L2 cache per core, which would lead to a bucket size of 41943 for omega 11 or 31775 for omega 15.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>the factorizations are stored here, but for performance reasons, their first prime power will have the form p^1, where p is either the LARGEST prime divisor OR 1, so code consuming this data must be aware of that. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9de793862541e4297214febac185349" name="ab9de793862541e4297214febac185349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9de793862541e4297214febac185349">&#9670;&#160;</a></span>nut_Segsieve_factorizations_mkbuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * nut_Segsieve_factorizations_mkbuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnut__Segsieve.html">nut_Segsieve</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pitch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a buffer for a thread to pass to <code><a class="el" href="segsieves_8h.html#ac2d982dae9f7f9d0e2b8c676ef3ab18b">nut_Segsieve_factorizations</a></code> on its intervals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pitch</td><td>if 0, compute max omega for self-&gt;max and compute the related pitch, then store it here. if nonzero, we assume you are passing the pitch calculated from a previous call. This pointer must not be null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_073faa820624379b5730e5b4f5cb1c42.html">nut</a></li><li class="navelem"><a class="el" href="segsieves_8h.html">segsieves.h</a></li>
    <li class="footer">Generated on Sun Aug 10 2025 23:27:42 for Number Theory Utils by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
