<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Number Theory Utils: include/nut/factorization.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_awesome_sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="/Number-Theory-Utils/index.html">Number Theory Utils</a><span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('factorization_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">factorization.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.2.0 </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Functions for dealing with factorization and modular arithmetic on 64 bit integers (not suitable for large integers which may overflow, around 2^31. a bignum-enabled version may be created to handle this) </p>

<p class="definition">Definition in file <a class="el" href="factorization_8h_source.html">factorization.h</a>.</p>
</div>
<p><a href="factorization_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnut__Factors.html">nut_Factors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A prime factorization.  <a href="structnut__Factors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnut__FactorConf.html">nut_FactorConf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration/tuning for heuristic factorization.  <a href="structnut__FactorConf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a20e843786a31323687940ee6768a882a"><td class="memItemLeft" align="right" valign="top"><a id="a20e843786a31323687940ee6768a882a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a20e843786a31323687940ee6768a882a">NUT_MAX_PRIMES_32</a>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a20e843786a31323687940ee6768a882a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most distinct prime divisors a uint32_t can have. <br /></td></tr>
<tr class="separator:a20e843786a31323687940ee6768a882a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978817b226b29e568d014886c6d82ee8"><td class="memItemLeft" align="right" valign="top"><a id="a978817b226b29e568d014886c6d82ee8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a978817b226b29e568d014886c6d82ee8">NUT_MAX_PRIMES_64</a>&#160;&#160;&#160;15</td></tr>
<tr class="memdesc:a978817b226b29e568d014886c6d82ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most distinct prime divisors a uint64_t can have. <br /></td></tr>
<tr class="separator:a978817b226b29e568d014886c6d82ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b95f5d79313e77dff307d5b7856b1d"><td class="memItemLeft" align="right" valign="top"><a id="aa4b95f5d79313e77dff307d5b7856b1d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#aa4b95f5d79313e77dff307d5b7856b1d">NUT_MAX_PRIMES_128</a>&#160;&#160;&#160;25</td></tr>
<tr class="memdesc:aa4b95f5d79313e77dff307d5b7856b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most distinct prime divisors a uint128_t can have. <br /></td></tr>
<tr class="separator:aa4b95f5d79313e77dff307d5b7856b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37007210bdaed85795ad6a44f9ce4efd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a37007210bdaed85795ad6a44f9ce4efd">NUT_DIVS_BEFORE_PRIME_CHECK</a>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a37007210bdaed85795ad6a44f9ce4efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently unused.  <a href="factorization_8h.html#a37007210bdaed85795ad6a44f9ce4efd">More...</a><br /></td></tr>
<tr class="separator:a37007210bdaed85795ad6a44f9ce4efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a68ae1e577404fdf655e577a3886dcd3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#ac5dad36b30fdd76ddce141ee49748d98">NUT_ATTR_MALLOC</a> <a class="el" href="structnut__Factors.html">nut_Factors</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a68ae1e577404fdf655e577a3886dcd3f">nut_make_Factors_w</a> (uint64_t max_primes)</td></tr>
<tr class="memdesc:a68ae1e577404fdf655e577a3886dcd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a factors structure that can hold a given number of distinct primes.  <a href="factorization_8h.html#a68ae1e577404fdf655e577a3886dcd3f">More...</a><br /></td></tr>
<tr class="separator:a68ae1e577404fdf655e577a3886dcd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486374f04085863d94317b23445d8f7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#ac5dad36b30fdd76ddce141ee49748d98">NUT_ATTR_MALLOC</a> <a class="el" href="structnut__Factors.html">nut_Factors</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a486374f04085863d94317b23445d8f7e">nut_make_Factors_ub</a> (uint64_t n, uint64_t num_primes, const uint64_t primes[static num_primes])</td></tr>
<tr class="memdesc:a486374f04085863d94317b23445d8f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a factors structure that can hold all factors of n, even if it has as many prime factors as possible.  <a href="factorization_8h.html#a486374f04085863d94317b23445d8f7e">More...</a><br /></td></tr>
<tr class="separator:a486374f04085863d94317b23445d8f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbd6f1b89d78911f4d773481812efcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#ac5dad36b30fdd76ddce141ee49748d98">NUT_ATTR_MALLOC</a> <a class="el" href="structnut__Factors.html">nut_Factors</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a0fbd6f1b89d78911f4d773481812efcc">nut_Factors_copy</a> (const <a class="el" href="structnut__Factors.html">nut_Factors</a> *factors)</td></tr>
<tr class="memdesc:a0fbd6f1b89d78911f4d773481812efcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a copy of a factors struct, but with only enough memory to store its current factors and not its max capacity if higher.  <a href="factorization_8h.html#a0fbd6f1b89d78911f4d773481812efcc">More...</a><br /></td></tr>
<tr class="separator:a0fbd6f1b89d78911f4d773481812efcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36decdbb615f72803d65bbffcc7bc3f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#ab14d56052242c417a7a8ee522570da9d">NUT_ATTR_PURE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a36decdbb615f72803d65bbffcc7bc3f6">nut_Factors_prod</a> (const <a class="el" href="structnut__Factors.html">nut_Factors</a> *factors)</td></tr>
<tr class="memdesc:a36decdbb615f72803d65bbffcc7bc3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a factorization into a number.  <a href="factorization_8h.html#a36decdbb615f72803d65bbffcc7bc3f6">More...</a><br /></td></tr>
<tr class="separator:a36decdbb615f72803d65bbffcc7bc3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fbbcd12b9fc33a8e832633a58496a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#ab14d56052242c417a7a8ee522570da9d">NUT_ATTR_PURE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a64fbbcd12b9fc33a8e832633a58496a6">nut_Factor_divcount</a> (const <a class="el" href="structnut__Factors.html">nut_Factors</a> *factors)</td></tr>
<tr class="memdesc:a64fbbcd12b9fc33a8e832633a58496a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the number of divisors of a number given its prime factorization, including itself and 1.  <a href="factorization_8h.html#a64fbbcd12b9fc33a8e832633a58496a6">More...</a><br /></td></tr>
<tr class="separator:a64fbbcd12b9fc33a8e832633a58496a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc45f8dffe0fdb32ebbcb7510b700bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#ab14d56052242c417a7a8ee522570da9d">NUT_ATTR_PURE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#addc45f8dffe0fdb32ebbcb7510b700bd">nut_Factor_divsum</a> (const <a class="el" href="structnut__Factors.html">nut_Factors</a> *factors)</td></tr>
<tr class="memdesc:addc45f8dffe0fdb32ebbcb7510b700bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the sum of divisors of a number given its prime factorization, including itself and 1.  <a href="factorization_8h.html#addc45f8dffe0fdb32ebbcb7510b700bd">More...</a><br /></td></tr>
<tr class="separator:addc45f8dffe0fdb32ebbcb7510b700bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb9a53990f1ee3ca4ce9e430d93826f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#ab14d56052242c417a7a8ee522570da9d">NUT_ATTR_PURE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#abbb9a53990f1ee3ca4ce9e430d93826f">nut_Factor_divpowsum</a> (const <a class="el" href="structnut__Factors.html">nut_Factors</a> *factors, uint64_t power)</td></tr>
<tr class="memdesc:abbb9a53990f1ee3ca4ce9e430d93826f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the sum of powers of divisors of a number given its prime factorization, including itself and 1.  <a href="factorization_8h.html#abbb9a53990f1ee3ca4ce9e430d93826f">More...</a><br /></td></tr>
<tr class="separator:abbb9a53990f1ee3ca4ce9e430d93826f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7099c574cebc270affcc2fef5cab6b80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#ab14d56052242c417a7a8ee522570da9d">NUT_ATTR_PURE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a7099c574cebc270affcc2fef5cab6b80">nut_Factor_divtupcount</a> (const <a class="el" href="structnut__Factors.html">nut_Factors</a> *factors, uint64_t k, uint64_t modulus)</td></tr>
<tr class="memdesc:a7099c574cebc270affcc2fef5cab6b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the number of k-tuples with product n.  <a href="factorization_8h.html#a7099c574cebc270affcc2fef5cab6b80">More...</a><br /></td></tr>
<tr class="separator:a7099c574cebc270affcc2fef5cab6b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a1f32d8d7197c9f60113616f10a5c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a19a1f32d8d7197c9f60113616f10a5c2">nut_Factor_ipow</a> (<a class="el" href="structnut__Factors.html">nut_Factors</a> *factors, uint64_t power)</td></tr>
<tr class="memdesc:a19a1f32d8d7197c9f60113616f10a5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise a factorization to a power, ie multiply all exponents by a constant.  <a href="factorization_8h.html#a19a1f32d8d7197c9f60113616f10a5c2">More...</a><br /></td></tr>
<tr class="separator:a19a1f32d8d7197c9f60113616f10a5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abda9091fb2fcf758f069bf8a674412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#ab14d56052242c417a7a8ee522570da9d">NUT_ATTR_PURE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a9abda9091fb2fcf758f069bf8a674412">nut_Factor_phi</a> (const <a class="el" href="structnut__Factors.html">nut_Factors</a> *factors)</td></tr>
<tr class="memdesc:a9abda9091fb2fcf758f069bf8a674412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Euler's Phi function, the number of coprime numbers less than n.  <a href="factorization_8h.html#a9abda9091fb2fcf758f069bf8a674412">More...</a><br /></td></tr>
<tr class="separator:a9abda9091fb2fcf758f069bf8a674412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac931c6a62bec58d63ee6043878315d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#ab14d56052242c417a7a8ee522570da9d">NUT_ATTR_PURE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a0ac931c6a62bec58d63ee6043878315d">nut_Factor_carmichael</a> (const <a class="el" href="structnut__Factors.html">nut_Factors</a> *factors)</td></tr>
<tr class="memdesc:a0ac931c6a62bec58d63ee6043878315d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Carmichael's Lambda function, the smallest exponent m so a^m = 1 for all 0 &lt; a &lt; n.  <a href="factorization_8h.html#a0ac931c6a62bec58d63ee6043878315d">More...</a><br /></td></tr>
<tr class="separator:a0ac931c6a62bec58d63ee6043878315d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8e843ae366d9d94ce0bff300657199"><td class="memItemLeft" align="right" valign="top"><a id="a0c8e843ae366d9d94ce0bff300657199"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a0c8e843ae366d9d94ce0bff300657199">nut_Factor_forall_divs_tmptmp</a> (const <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict factors, int(*f)(const <a class="el" href="structnut__Factors.html">nut_Factors</a> *, uint64_t, void *), void *restrict data)</td></tr>
<tr class="memdesc:a0c8e843ae366d9d94ce0bff300657199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <a class="el" href="">forall_divisors</a> with temporarily allocated dfactors and pfactors structs. <br /></td></tr>
<tr class="separator:a0c8e843ae366d9d94ce0bff300657199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92121419128c9016b2c012ec6fdf4aec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a92121419128c9016b2c012ec6fdf4aec">nut_Factor_forall_divs</a> (const <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict factors, int(*f)(const <a class="el" href="structnut__Factors.html">nut_Factors</a> *, uint64_t, void *), void *data, <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict dfactors, <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict pfactors)</td></tr>
<tr class="memdesc:a92121419128c9016b2c012ec6fdf4aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a given function on each divisor of a number, given its factorization.  <a href="factorization_8h.html#a92121419128c9016b2c012ec6fdf4aec">More...</a><br /></td></tr>
<tr class="separator:a92121419128c9016b2c012ec6fdf4aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcaa51dc194ca6075de84c5b5de29be"><td class="memItemLeft" align="right" valign="top"><a id="a8bcaa51dc194ca6075de84c5b5de29be"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a8bcaa51dc194ca6075de84c5b5de29be">nut_Factor_forall_divs_le_tmptmp</a> (const <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict factors, uint64_t d_max, int(*f)(const <a class="el" href="structnut__Factors.html">nut_Factors</a> *, uint64_t, void *), void *restrict data)</td></tr>
<tr class="memdesc:a8bcaa51dc194ca6075de84c5b5de29be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <a class="el" href="">forall_divisors_le</a> with temporarily allocated dfactors and pfactors structs. <br /></td></tr>
<tr class="separator:a8bcaa51dc194ca6075de84c5b5de29be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b424ebab8bf8de4e2d8a6bcb5a588b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a57b424ebab8bf8de4e2d8a6bcb5a588b">nut_Factor_forall_divs_le</a> (const <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict factors, uint64_t d_max, int(*f)(const <a class="el" href="structnut__Factors.html">nut_Factors</a> *, uint64_t, void *), void *restrict data, <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict dfactors, <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict pfactors)</td></tr>
<tr class="memdesc:a57b424ebab8bf8de4e2d8a6bcb5a588b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a given function on each divisor of a number, given its factorization, skipping divisors over a given bound.  <a href="factorization_8h.html#a57b424ebab8bf8de4e2d8a6bcb5a588b">More...</a><br /></td></tr>
<tr class="separator:a57b424ebab8bf8de4e2d8a6bcb5a588b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9fc3c6bf989efd453ac7453d8342a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a6c9fc3c6bf989efd453ac7453d8342a1">nut_Factor_fprint</a> (FILE *restrict file, const <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict factors)</td></tr>
<tr class="memdesc:a6c9fc3c6bf989efd453ac7453d8342a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a factorization of a number.  <a href="factorization_8h.html#a6c9fc3c6bf989efd453ac7453d8342a1">More...</a><br /></td></tr>
<tr class="separator:a6c9fc3c6bf989efd453ac7453d8342a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830a7ccc32e3e054804091b4ce8187cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a830a7ccc32e3e054804091b4ce8187cb">nut_Factor_append</a> (<a class="el" href="structnut__Factors.html">nut_Factors</a> *factors, uint64_t m, uint64_t k)</td></tr>
<tr class="memdesc:a830a7ccc32e3e054804091b4ce8187cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a power of some prime to an existing factorization struct.  <a href="factorization_8h.html#a830a7ccc32e3e054804091b4ce8187cb">More...</a><br /></td></tr>
<tr class="separator:a830a7ccc32e3e054804091b4ce8187cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab072eac902961986de4d94138ea73cf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#ab072eac902961986de4d94138ea73cf1">nut_Factor_combine</a> (<a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict factors, const <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict factors2, uint64_t k)</td></tr>
<tr class="memdesc:ab072eac902961986de4d94138ea73cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all prime/power pairs in one factorization to another.  <a href="factorization_8h.html#ab072eac902961986de4d94138ea73cf1">More...</a><br /></td></tr>
<tr class="separator:ab072eac902961986de4d94138ea73cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e4f1425cdf116059ee5e0f84348bd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a48e4f1425cdf116059ee5e0f84348bd5">nut_u64_is_prime_dmr</a> (uint64_t n)</td></tr>
<tr class="memdesc:a48e4f1425cdf116059ee5e0f84348bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if n is prime using a deterministic Miller-Rabin test.  <a href="factorization_8h.html#a48e4f1425cdf116059ee5e0f84348bd5">More...</a><br /></td></tr>
<tr class="separator:a48e4f1425cdf116059ee5e0f84348bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af100b74caf393425a7070f2acc1a1ec2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#af100b74caf393425a7070f2acc1a1ec2">nut_u64_next_prime_ge</a> (uint64_t n)</td></tr>
<tr class="memdesc:af100b74caf393425a7070f2acc1a1ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next prime &gt;= n.  <a href="factorization_8h.html#af100b74caf393425a7070f2acc1a1ec2">More...</a><br /></td></tr>
<tr class="separator:af100b74caf393425a7070f2acc1a1ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81b28e5571235af292694f0f878eed1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#aae158eaae70da54bc82bfe48f0428eb7">NUT_ATTR_NODISCARD</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#ad81b28e5571235af292694f0f878eed1">nut_u64_factor_trial_div</a> (uint64_t n, uint64_t num_primes, const uint64_t primes[restrict static num_primes], <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict factors)</td></tr>
<tr class="memdesc:ad81b28e5571235af292694f0f878eed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor out all powers of a given array of primes.  <a href="factorization_8h.html#ad81b28e5571235af292694f0f878eed1">More...</a><br /></td></tr>
<tr class="separator:ad81b28e5571235af292694f0f878eed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d2d8452d2f53bfe6be95d2d8cd21bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#aae158eaae70da54bc82bfe48f0428eb7">NUT_ATTR_NODISCARD</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a17d2d8452d2f53bfe6be95d2d8cd21bb">nut_u64_factor_heuristic</a> (uint64_t n, uint64_t num_primes, const uint64_t primes[restrict static num_primes], const <a class="el" href="structnut__FactorConf.html">nut_FactorConf</a> *restrict conf, <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict factors)</td></tr>
<tr class="memdesc:a17d2d8452d2f53bfe6be95d2d8cd21bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor a number using a variety of approaches based on its size.  <a href="factorization_8h.html#a17d2d8452d2f53bfe6be95d2d8cd21bb">More...</a><br /></td></tr>
<tr class="separator:a17d2d8452d2f53bfe6be95d2d8cd21bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b70a4d4fb8c7f9fa524c70a67afc38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a83b70a4d4fb8c7f9fa524c70a67afc38">nut_u64_nth_root</a> (uint64_t a, uint64_t n)</td></tr>
<tr class="memdesc:a83b70a4d4fb8c7f9fa524c70a67afc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the floor of the nth root of a.  <a href="factorization_8h.html#a83b70a4d4fb8c7f9fa524c70a67afc38">More...</a><br /></td></tr>
<tr class="separator:a83b70a4d4fb8c7f9fa524c70a67afc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2783bcbef71c9084463093b7cb55fb76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a2783bcbef71c9084463093b7cb55fb76">nut_u64_is_perfect_power</a> (uint64_t a, uint64_t max, uint64_t *restrict _base, uint64_t *restrict _exp)</td></tr>
<tr class="memdesc:a2783bcbef71c9084463093b7cb55fb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a is a perfect power of some integer.  <a href="factorization_8h.html#a2783bcbef71c9084463093b7cb55fb76">More...</a><br /></td></tr>
<tr class="separator:a2783bcbef71c9084463093b7cb55fb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca18db901b14c771139a2b199e92c2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#aaca18db901b14c771139a2b199e92c2e">nut_u64_factor1_pollard_rho</a> (uint64_t n, uint64_t x)</td></tr>
<tr class="memdesc:aaca18db901b14c771139a2b199e92c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a factor of a number using Pollard's Rho algorithm with Floyd cycle finding.  <a href="factorization_8h.html#aaca18db901b14c771139a2b199e92c2e">More...</a><br /></td></tr>
<tr class="separator:aaca18db901b14c771139a2b199e92c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8795bf097ec71353cdd3e39b234761f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#ad8795bf097ec71353cdd3e39b234761f">nut_u64_factor1_pollard_rho_brent</a> (uint64_t n, uint64_t x, uint64_t m)</td></tr>
<tr class="memdesc:ad8795bf097ec71353cdd3e39b234761f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a factor of a number using Pollard's Rho algorithm with Brent cycle finding and gcd coalescing.  <a href="factorization_8h.html#ad8795bf097ec71353cdd3e39b234761f">More...</a><br /></td></tr>
<tr class="separator:ad8795bf097ec71353cdd3e39b234761f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2f3e9578e5cb8925ecae35bbe71410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a4c2f3e9578e5cb8925ecae35bbe71410">nut_u64_factor1_lenstra</a> (int64_t n, int64_t x, int64_t y, int64_t a, int64_t B)</td></tr>
<tr class="memdesc:a4c2f3e9578e5cb8925ecae35bbe71410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a factor of a number using Lenstra ecf.  <a href="factorization_8h.html#a4c2f3e9578e5cb8925ecae35bbe71410">More...</a><br /></td></tr>
<tr class="separator:a4c2f3e9578e5cb8925ecae35bbe71410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a6429f597edf2c64d5e19bf12d0423"><td class="memItemLeft" align="right" valign="top"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a28a6429f597edf2c64d5e19bf12d0423">nut_u64_factor1_lenstra_montgomery</a> (int64_t n, int64_t x, int64_t y, int64_t a, int64_t B)</td></tr>
<tr class="memdesc:a28a6429f597edf2c64d5e19bf12d0423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="factorization_8h.html#a4c2f3e9578e5cb8925ecae35bbe71410">nut_u64_factor1_lenstra</a> but using a projective Montgomery curve and Montgomery ladder.  <a href="factorization_8h.html#a28a6429f597edf2c64d5e19bf12d0423">More...</a><br /></td></tr>
<tr class="separator:a28a6429f597edf2c64d5e19bf12d0423"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3629c7b068fca6d74cc56e33283a8b2e"><td class="memItemLeft" align="right" valign="top">const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a3629c7b068fca6d74cc56e33283a8b2e">nut_small_primes</a> [25]</td></tr>
<tr class="memdesc:a3629c7b068fca6d74cc56e33283a8b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array containing the 25 primes up to 100.  <a href="factorization_8h.html#a3629c7b068fca6d74cc56e33283a8b2e">More...</a><br /></td></tr>
<tr class="separator:a3629c7b068fca6d74cc56e33283a8b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435a05668997a808999bf713833f41dc"><td class="memItemLeft" align="right" valign="top"><a id="a435a05668997a808999bf713833f41dc"></a>
const <a class="el" href="structnut__FactorConf.html">nut_FactorConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a435a05668997a808999bf713833f41dc">nut_default_factor_conf</a></td></tr>
<tr class="memdesc:a435a05668997a808999bf713833f41dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for <a class="el" href="factorization_8h.html#a17d2d8452d2f53bfe6be95d2d8cd21bb">nut_u64_factor_heuristic</a> Use if you don't want to tune the parameters or don't care. <br /></td></tr>
<tr class="separator:a435a05668997a808999bf713833f41dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a37007210bdaed85795ad6a44f9ce4efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37007210bdaed85795ad6a44f9ce4efd">&#9670;&nbsp;</a></span>NUT_DIVS_BEFORE_PRIME_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUT_DIVS_BEFORE_PRIME_CHECK&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Currently unused. </p>
<p>How many trial divisions to do before performing randomized prime tests (Miller Rabin). For 64 bit numbers, we can easily make Miller Rabin deterministic in 7 tests, whereas up to 40 would be used to check a large number. BSW and ECPP are also important for checking large primes, because BSW and Miller Rabin together can provide a higher primality confidence faster, whereas ECPP is much slower but provides an easily verifiable proof. </p>

<p class="definition">Definition at line <a class="el" href="factorization_8h_source.html#l00034">34</a> of file <a class="el" href="factorization_8h_source.html">factorization.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a68ae1e577404fdf655e577a3886dcd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ae1e577404fdf655e577a3886dcd3f">&#9670;&nbsp;</a></span>nut_make_Factors_w()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#ac5dad36b30fdd76ddce141ee49748d98">NUT_ATTR_MALLOC</a> <a class="el" href="structnut__Factors.html">nut_Factors</a>* nut_make_Factors_w </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_primes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a factors structure that can hold a given number of distinct primes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_primes</td><td>the number of distinct primes that should be storable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to factors structure that can hold max_primes. pointer needs to be free'd </dd></dl>

</div>
</div>
<a id="a486374f04085863d94317b23445d8f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486374f04085863d94317b23445d8f7e">&#9670;&nbsp;</a></span>nut_make_Factors_ub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#ac5dad36b30fdd76ddce141ee49748d98">NUT_ATTR_MALLOC</a> <a class="el" href="structnut__Factors.html">nut_Factors</a>* nut_make_Factors_ub </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_primes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>primes</em>[static num_primes]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a factors structure that can hold all factors of n, even if it has as many prime factors as possible. </p>
<p>E.g. 210=2*3*5*7 and 2310=2*3*5*7*11 so 210-2309 can have up to 4 distinct prime factors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number up to which the distinct prime factors of any number should be storable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_primes</td><td>number of primes in array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primes</td><td>array of primes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to factors structure that can hold enough distinct primes to factor any number up through n. pointer needs to be free'd </dd></dl>

</div>
</div>
<a id="a0fbd6f1b89d78911f4d773481812efcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbd6f1b89d78911f4d773481812efcc">&#9670;&nbsp;</a></span>nut_Factors_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#ac5dad36b30fdd76ddce141ee49748d98">NUT_ATTR_MALLOC</a> <a class="el" href="structnut__Factors.html">nut_Factors</a>* nut_Factors_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnut__Factors.html">nut_Factors</a> *&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a copy of a factors struct, but with only enough memory to store its current factors and not its max capacity if higher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>the struct to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the input or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a36decdbb615f72803d65bbffcc7bc3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36decdbb615f72803d65bbffcc7bc3f6">&#9670;&nbsp;</a></span>nut_Factors_prod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#ab14d56052242c417a7a8ee522570da9d">NUT_ATTR_PURE</a> uint64_t nut_Factors_prod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnut__Factors.html">nut_Factors</a> *&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a factorization into a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factors struct, as obtained from <a class="el" href="factorization_8h.html#ad81b28e5571235af292694f0f878eed1">nut_u64_factor_trial_div</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>product of prime powers described by factors </dd></dl>

</div>
</div>
<a id="a64fbbcd12b9fc33a8e832633a58496a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fbbcd12b9fc33a8e832633a58496a6">&#9670;&nbsp;</a></span>nut_Factor_divcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#ab14d56052242c417a7a8ee522570da9d">NUT_ATTR_PURE</a> uint64_t nut_Factor_divcount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnut__Factors.html">nut_Factors</a> *&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the number of divisors of a number given its prime factorization, including itself and 1. </p>
<p>Works by multiplying power + 1 for all prime factors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factors struct, as obtained from <a class="el" href="factorization_8h.html#ad81b28e5571235af292694f0f878eed1">nut_u64_factor_trial_div</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of divisors </dd></dl>

</div>
</div>
<a id="addc45f8dffe0fdb32ebbcb7510b700bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc45f8dffe0fdb32ebbcb7510b700bd">&#9670;&nbsp;</a></span>nut_Factor_divsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#ab14d56052242c417a7a8ee522570da9d">NUT_ATTR_PURE</a> uint64_t nut_Factor_divsum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnut__Factors.html">nut_Factors</a> *&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the sum of divisors of a number given its prime factorization, including itself and 1. </p>
<p>Works by multiplying (prime**(power+1)-1)/(prime-1) for all prime factors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factors struct, as obtained from <a class="el" href="factorization_8h.html#ad81b28e5571235af292694f0f878eed1">nut_u64_factor_trial_div</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of divisors </dd></dl>

</div>
</div>
<a id="abbb9a53990f1ee3ca4ce9e430d93826f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb9a53990f1ee3ca4ce9e430d93826f">&#9670;&nbsp;</a></span>nut_Factor_divpowsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#ab14d56052242c417a7a8ee522570da9d">NUT_ATTR_PURE</a> uint64_t nut_Factor_divpowsum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnut__Factors.html">nut_Factors</a> *&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the sum of powers of divisors of a number given its prime factorization, including itself and 1. </p>
<p>Note this is NOT the same as the sum of divisors of a number. Works by multiplying (prime**((power+1)*e)-1)/(prime**e-1) for all prime factors, where power is the power of each prime and e is the power of divisors to sum </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factors struct, as obtained from <a class="el" href="factorization_8h.html#ad81b28e5571235af292694f0f878eed1">nut_u64_factor_trial_div</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">power</td><td>power of divisors to sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of divisor powers </dd></dl>

</div>
</div>
<a id="a7099c574cebc270affcc2fef5cab6b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7099c574cebc270affcc2fef5cab6b80">&#9670;&nbsp;</a></span>nut_Factor_divtupcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#ab14d56052242c417a7a8ee522570da9d">NUT_ATTR_PURE</a> uint64_t nut_Factor_divtupcount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnut__Factors.html">nut_Factors</a> *&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the number of k-tuples with product n. </p>
<p>given the factorization of n. Works by multiplying binom(power + k, k) for all prime factors, where power is the power of eaach prime </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factors struct, as obtained from <a class="el" href="factorization_8h.html#ad81b28e5571235af292694f0f878eed1">nut_u64_factor_trial_div</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>tuple length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modulus</td><td>modulus to reduce answer by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of factorizations into k numbers, allowing repeats and considering order </dd></dl>

</div>
</div>
<a id="a19a1f32d8d7197c9f60113616f10a5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a1f32d8d7197c9f60113616f10a5c2">&#9670;&nbsp;</a></span>nut_Factor_ipow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nut_Factor_ipow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Factors.html">nut_Factors</a> *&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raise a factorization to a power, ie multiply all exponents by a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factors</td><td>factorization to raise to a power </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">power</td><td>power to raise the factorization to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9abda9091fb2fcf758f069bf8a674412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abda9091fb2fcf758f069bf8a674412">&#9670;&nbsp;</a></span>nut_Factor_phi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#ab14d56052242c417a7a8ee522570da9d">NUT_ATTR_PURE</a> uint64_t nut_Factor_phi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnut__Factors.html">nut_Factors</a> *&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find Euler's Phi function, the number of coprime numbers less than n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>the factorization of n for which to compute phi </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>phi(n) </dd></dl>

</div>
</div>
<a id="a0ac931c6a62bec58d63ee6043878315d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac931c6a62bec58d63ee6043878315d">&#9670;&nbsp;</a></span>nut_Factor_carmichael()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#ab14d56052242c417a7a8ee522570da9d">NUT_ATTR_PURE</a> uint64_t nut_Factor_carmichael </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnut__Factors.html">nut_Factors</a> *&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find Carmichael's Lambda function, the smallest exponent m so a^m = 1 for all 0 &lt; a &lt; n. </p>
<p>Always divides phi(n). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>the factorization of n for which to compute the carmichael function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lambda(n) </dd></dl>

</div>
</div>
<a id="a92121419128c9016b2c012ec6fdf4aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92121419128c9016b2c012ec6fdf4aec">&#9670;&nbsp;</a></span>nut_Factor_forall_divs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nut_Factor_forall_divs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const <a class="el" href="structnut__Factors.html">nut_Factors</a> *, uint64_t, void *)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict&#160;</td>
          <td class="paramname"><em>dfactors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict&#160;</td>
          <td class="paramname"><em>pfactors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a given function on each divisor of a number, given its factorization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>the factorization of n for which to compute all divisors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>callback function. Arguments are factorization of divisor, divisor, user data (respectively). Should return 0 to continue, or 1 to break. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>user data (allows arbitrary data to be passed in and out of the callback) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dfactors</td><td>buffer to store internal work. Should be allocated to hold at least factors-&gt;num_primes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfactors</td><td>buffer to store internal work. Should be allocated to hlod at least factors-&gt;num_primes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the callback never returned 1 and all divisors were visited, or 1 if the callback ever returned nonzero. </dd></dl>

</div>
</div>
<a id="a57b424ebab8bf8de4e2d8a6bcb5a588b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b424ebab8bf8de4e2d8a6bcb5a588b">&#9670;&nbsp;</a></span>nut_Factor_forall_divs_le()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nut_Factor_forall_divs_le </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const <a class="el" href="structnut__Factors.html">nut_Factors</a> *, uint64_t, void *)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *restrict&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict&#160;</td>
          <td class="paramname"><em>dfactors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict&#160;</td>
          <td class="paramname"><em>pfactors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a given function on each divisor of a number, given its factorization, skipping divisors over a given bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>the factorization of n for which to compute all divisors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_max</td><td>max divisor to visit. This should be less than the product of factors, otherwise just use forall_divisors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>callback function. Arguments are factorization of divisor, divisor, user data (respectively). Should return 0 to continue, or 1 to break. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>user data (allows arbitrary data to be passed in and out of the callback) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dfactors</td><td>buffer to store internal work. Should be allocated to hold at least factors-&gt;num_primes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfactors</td><td>buffer to store internal work. Should be allocated to hlod at least factors-&gt;num_primes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the callback never returned 1 and all divisors were visited, or 1 if the callback ever returned nonzero. </dd></dl>

</div>
</div>
<a id="a6c9fc3c6bf989efd453ac7453d8342a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9fc3c6bf989efd453ac7453d8342a1">&#9670;&nbsp;</a></span>nut_Factor_fprint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nut_Factor_fprint </td>
          <td>(</td>
          <td class="paramtype">FILE *restrict&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a factorization of a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td>pointer to file to print to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factorization struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of characters printed </dd></dl>

</div>
</div>
<a id="a830a7ccc32e3e054804091b4ce8187cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830a7ccc32e3e054804091b4ce8187cb">&#9670;&nbsp;</a></span>nut_Factor_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nut_Factor_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Factors.html">nut_Factors</a> *&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a power of some prime to an existing factorization struct. </p>
<p>If the input factorization is sorted before this function is called, it will still be sorted after, and if the factor to be added is already present its power will be increased rather than creating a separate entry. The factorization struct must have enough space if an additional entry is needed. Composite numbers or zero powers should not be supplied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factors</td><td>pointer to factorization struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>prime </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>power </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab072eac902961986de4d94138ea73cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab072eac902961986de4d94138ea73cf1">&#9670;&nbsp;</a></span>nut_Factor_combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nut_Factor_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict&#160;</td>
          <td class="paramname"><em>factors2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add all prime/power pairs in one factorization to another. </p>
<p>If both inputs are sorted, the result will be sorted and no dupliate entries will be created. Acts as if <a class="el" href="">factors_append</a> were called repeatedly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factors</td><td>pointer to factorization struct which should be extended </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors2</td><td>pointer to factorization struct whose entries will be added to the other struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>power to multiply entries of factors2 by, for if some composite number m was discovered where m^k divides n and we have factored m </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48e4f1425cdf116059ee5e0f84348bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e4f1425cdf116059ee5e0f84348bd5">&#9670;&nbsp;</a></span>nut_u64_is_prime_dmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> bool nut_u64_is_prime_dmr </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if n is prime using a deterministic Miller-Rabin test. </p>
<p>7 partictular bases are used so that no composite number will falsely be reported as prime for the entire 64-bit range </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to check for primality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if n is prime, false otherwise </dd></dl>

</div>
</div>
<a id="af100b74caf393425a7070f2acc1a1ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af100b74caf393425a7070f2acc1a1ec2">&#9670;&nbsp;</a></span>nut_u64_next_prime_ge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> uint64_t nut_u64_next_prime_ge </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the next prime &gt;= n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>inclusive lower bound for prime </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the smallest prime &gt;= n </dd></dl>

</div>
</div>
<a id="ad81b28e5571235af292694f0f878eed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81b28e5571235af292694f0f878eed1">&#9670;&nbsp;</a></span>nut_u64_factor_trial_div()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#aae158eaae70da54bc82bfe48f0428eb7">NUT_ATTR_NODISCARD</a> uint64_t nut_u64_factor_trial_div </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_primes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>primes</em>[restrict static num_primes], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factor out all powers of a given array of primes. </p>
<p>Primesieve is a good general source for primes, but the api for this function is designed to allow giving a specialized list of primes like only primes equal to 1 mod 6 if it is known that all factors have some form, or to provide an empty list when this function is used in a more generic context like <a class="el" href="factorization_8h.html#a17d2d8452d2f53bfe6be95d2d8cd21bb">nut_u64_factor_heuristic</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_primes</td><td>the number of primes in the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primes</td><td>the array of primes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">factors</td><td>pointer to struct where factors will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n with all factors found and stored in factors divided out. Thus if n factors completely over the given primes, 1 is returned. </dd></dl>

</div>
</div>
<a id="a17d2d8452d2f53bfe6be95d2d8cd21bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d2d8452d2f53bfe6be95d2d8cd21bb">&#9670;&nbsp;</a></span>nut_u64_factor_heuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#aae158eaae70da54bc82bfe48f0428eb7">NUT_ATTR_NODISCARD</a> uint64_t nut_u64_factor_heuristic </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_primes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>primes</em>[restrict static num_primes], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnut__FactorConf.html">nut_FactorConf</a> *restrict&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnut__Factors.html">nut_Factors</a> *restrict&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factor a number using a variety of approaches based on its size. </p>
<p>If conf-&gt;pollard_max is greater than 3, the primes array should include at least 2 and 5 to avoid an infinite loop since <a class="el" href="factorization_8h.html#aaca18db901b14c771139a2b199e92c2e">nut_u64_factor1_pollard_rho</a> can't factor 4 or 25. Currently a configuration struct must be passed. Kraitcheck methods (quadratic sieve and number field sieve) are not implemented because they are useless on 64 bit integers. Parameters to Pollard-Rho-Brent with gcd aggregation and Lenstra ecf are not tuned by this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_primes</td><td>the number of primes in the array to try trial division on (use 25 if using <a class="el" href="factorization_8h.html#a3629c7b068fca6d74cc56e33283a8b2e">nut_small_primes</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primes</td><td>array of primes (can use <a class="el" href="factorization_8h.html#a3629c7b068fca6d74cc56e33283a8b2e">nut_small_primes</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>limits for different algorithms (can use <a class="el" href="factorization_8h.html#a435a05668997a808999bf713833f41dc">nut_default_factor_conf</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">factors</td><td>output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n with all factors found and stored in factors divided out. Thus if n factors completely, 1 is returned. </dd></dl>

</div>
</div>
<a id="a83b70a4d4fb8c7f9fa524c70a67afc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b70a4d4fb8c7f9fa524c70a67afc38">&#9670;&nbsp;</a></span>nut_u64_nth_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> uint64_t nut_u64_nth_root </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the floor of the nth root of a. </p>
<p>Uses bitscan to estimate the base 2 log and in turn nth root of a, then uses Newton's method </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the number to take the nth root of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>root to take </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>floor(a**(1/n)), ie the largest integer x such that x**n &lt;= a </dd></dl>

</div>
</div>
<a id="a2783bcbef71c9084463093b7cb55fb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2783bcbef71c9084463093b7cb55fb76">&#9670;&nbsp;</a></span>nut_u64_is_perfect_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nut_u64_is_perfect_power </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *restrict&#160;</td>
          <td class="paramname"><em>_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *restrict&#160;</td>
          <td class="paramname"><em>_exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a is a perfect power of some integer. </p>
<p>Used in <a class="el" href="factorization_8h.html#a17d2d8452d2f53bfe6be95d2d8cd21bb">nut_u64_factor_heuristic</a>. max is the max exponent a could possibly be, which is limited because it is a uint64_t. If nothing is known about a, then the max exponent it could be is 63, if it were 2**63. However, if we know that the base of a must be larger than some minimum, such as if we know a is not divisible by any primes up to some point, then we can set a lower limit on the max exponent. For example, if a is 2-rough (not divisible by any primes &lt;= 2), then the minimum possible base is 3, so the maximal exponent is 40 instead. For all primes in the nut_small_primes array, the max exponents are as follows: 2-rough -&gt; min base 3 -&gt; max exponent 40 3 -&gt; 5 -&gt; 27 5 -&gt; 7 -&gt; 22 7 -&gt; 11 -&gt; 18 11 -&gt; 13 -&gt; 17 13 -&gt; 17 -&gt; 15 19 -&gt; 23 -&gt; 14 23 -&gt; 29 -&gt; 13 29 -&gt; 31 -&gt; 12 37 -&gt; 41 -&gt; 11 57 -&gt; 59 -&gt; 10 83 -&gt; 89 -&gt; 9 and going over 100: 137 -&gt; 139 -&gt; 8 251 -&gt; 257 -&gt; 7 563 -&gt; 569 -&gt; 6 1621 -&gt; 1627 -&gt; 5 7129 -&gt; 7151 -&gt; 4 65521 -&gt; 65537 -&gt; 3 2642239 -&gt; 2642257 -&gt; 2 4294967291 -&gt; 4294967311 -&gt; 1 The max exponent can also be brought down if a is known to be small, but depending on context it may or may not be worth computing log(a)/log(p) where p is the largest prime not known to not divide a. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the number to check for being a perfect power </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>the max exponent a could possibly be. Use eg 63 if unknown, 11 if a has had all factors of primes up to 47 removed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_base</td><td>if a is found to be a perfect power, store the base here </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_exp</td><td>if a is found to be a perfect power, store the exponent here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a is a perfect power (with exponent max or lower), false otherwise (could mean a is not a perfect power, or could mean a is a perfect power with exponent max + 1 to 61) </dd></dl>

</div>
</div>
<a id="aaca18db901b14c771139a2b199e92c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca18db901b14c771139a2b199e92c2e">&#9670;&nbsp;</a></span>nut_u64_factor1_pollard_rho()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> uint64_t nut_u64_factor1_pollard_rho </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find a factor of a number using Pollard's Rho algorithm with Floyd cycle finding. </p>
<p>Note that this will not find factors of 4 or 25 no matter what x is. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>random value mod n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise </dd></dl>

</div>
</div>
<a id="ad8795bf097ec71353cdd3e39b234761f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8795bf097ec71353cdd3e39b234761f">&#9670;&nbsp;</a></span>nut_u64_factor1_pollard_rho_brent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> uint64_t nut_u64_factor1_pollard_rho_brent </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find a factor of a number using Pollard's Rho algorithm with Brent cycle finding and gcd coalescing. </p>
<p>Note that his will not find factors of 4 or 25 no matter what x is. m does not affect whether x will lead to a factor of n, it just means each iteration will be cheaper but up to 2m extraneous iterations could be performed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>random value mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of iterations per gcd check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise </dd></dl>

</div>
</div>
<a id="a4c2f3e9578e5cb8925ecae35bbe71410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2f3e9578e5cb8925ecae35bbe71410">&#9670;&nbsp;</a></span>nut_u64_factor1_lenstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> int64_t nut_u64_factor1_lenstra </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find a factor of a number using Lenstra ecf. </p>
<p>In particular, an affine wierstrass representation is used internally and scalar multiplication is done using a binary "double and add" algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y,a</td><td>random values mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>number of trials before giving up (we compute kP for k from 2 to B) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise </dd></dl>

</div>
</div>
<a id="a28a6429f597edf2c64d5e19bf12d0423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a6429f597edf2c64d5e19bf12d0423">&#9670;&nbsp;</a></span>nut_u64_factor1_lenstra_montgomery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="modular__math_8h.html#abe429016b65e7ca254c5d49c178ade29">NUT_ATTR_CONST</a> int64_t nut_u64_factor1_lenstra_montgomery </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="factorization_8h.html#a4c2f3e9578e5cb8925ecae35bbe71410">nut_u64_factor1_lenstra</a> but using a projective Montgomery curve and Montgomery ladder. </p>
<p>Instead of an affine Wierstrass curve and binary multiplication. This is supposed to be faster but seems to be about the same. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y,a</td><td>random numbers mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>number of trials before giving up (we compute kP for k from 2 to B) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3629c7b068fca6d74cc56e33283a8b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3629c7b068fca6d74cc56e33283a8b2e">&#9670;&nbsp;</a></span>nut_small_primes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t nut_small_primes[25]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An array containing the 25 primes up to 100. </p>
<p><a class="el" href="factorization_8h.html#aaca18db901b14c771139a2b199e92c2e">nut_u64_factor1_pollard_rho</a> and <a class="el" href="factorization_8h.html#ad8795bf097ec71353cdd3e39b234761f">nut_u64_factor1_pollard_rho_brent</a> can't find factors of 4 or 25 using the default polynomial, so if using <a class="el" href="factorization_8h.html#a17d2d8452d2f53bfe6be95d2d8cd21bb">nut_u64_factor_heuristic</a> at least these primes should be used for trial division if the configuration allows pollard rho to be called. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_073faa820624379b5730e5b4f5cb1c42.html">nut</a></li><li class="navelem"><a class="el" href="factorization_8h.html">factorization.h</a></li>
    <li class="footer">Generated on Tue Jan 30 2024 01:27:08 for Number Theory Utils by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
