<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Number Theory Utils: include/nut/factorization.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_awesome_sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="/Number-Theory-Utils/index.html">Number Theory Utils</a><span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('factorization_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">factorization.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.2.0 </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Functions for dealing with factorization and modular arithmetic on 64 bit integers (not suitable for large integers which may overflow, around 2^31. a bignum-enabled version may be created to handle this) </p>

<p class="definition">Definition in file <a class="el" href="factorization_8h_source.html">factorization.h</a>.</p>
</div>
<p><a href="factorization_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfactors__t.html">factors_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A prime factorization.  <a href="structfactors__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfactor__conf__t.html">factor_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration/tuning for heuristic factorization.  <a href="structfactor__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a28f056a31fe5cbaa059a0740d3339e5b"><td class="memItemLeft" align="right" valign="top"><a id="a28f056a31fe5cbaa059a0740d3339e5b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a28f056a31fe5cbaa059a0740d3339e5b">MAX_PRIMES_32</a>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a28f056a31fe5cbaa059a0740d3339e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most distinct prime divisors a uint32_t can have. <br /></td></tr>
<tr class="separator:a28f056a31fe5cbaa059a0740d3339e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f29234154854a63ff0f50e0259c1cd6"><td class="memItemLeft" align="right" valign="top"><a id="a9f29234154854a63ff0f50e0259c1cd6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a9f29234154854a63ff0f50e0259c1cd6">MAX_PRIMES_64</a>&#160;&#160;&#160;15</td></tr>
<tr class="memdesc:a9f29234154854a63ff0f50e0259c1cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most distinct prime divisors a uint64_t can have. <br /></td></tr>
<tr class="separator:a9f29234154854a63ff0f50e0259c1cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11bbeaacb214223d9c679b307348a6b"><td class="memItemLeft" align="right" valign="top"><a id="ac11bbeaacb214223d9c679b307348a6b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#ac11bbeaacb214223d9c679b307348a6b">MAX_PRIMES_128</a>&#160;&#160;&#160;25</td></tr>
<tr class="memdesc:ac11bbeaacb214223d9c679b307348a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most distinct prime divisors a uint128_t can have. <br /></td></tr>
<tr class="separator:ac11bbeaacb214223d9c679b307348a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9641e499ad990b5eb66cda6400f55e5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a9641e499ad990b5eb66cda6400f55e5b">DIVS_BEFORE_PRIME_CHECK</a>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a9641e499ad990b5eb66cda6400f55e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently unused.  <a href="factorization_8h.html#a9641e499ad990b5eb66cda6400f55e5b">More...</a><br /></td></tr>
<tr class="separator:a9641e499ad990b5eb66cda6400f55e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adbaa273b8beccd77d082b8af9cef9b8f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#adbaa273b8beccd77d082b8af9cef9b8f">__attribute__</a> ((malloc)) <a class="el" href="structfactors__t.html">factors_t</a> *init_factors_t_w(uint64_t max_primes)</td></tr>
<tr class="memdesc:adbaa273b8beccd77d082b8af9cef9b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a factors structure that can hold a given number of distinct primes.  <a href="factorization_8h.html#adbaa273b8beccd77d082b8af9cef9b8f">More...</a><br /></td></tr>
<tr class="separator:adbaa273b8beccd77d082b8af9cef9b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1b12c52428683f7956dc49abb369b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a3a1b12c52428683f7956dc49abb369b6">__attribute__</a> ((pure)) uint64_t factors_product(const <a class="el" href="structfactors__t.html">factors_t</a> *factors)</td></tr>
<tr class="memdesc:a3a1b12c52428683f7956dc49abb369b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a factorization into a number.  <a href="factorization_8h.html#a3a1b12c52428683f7956dc49abb369b6">More...</a><br /></td></tr>
<tr class="separator:a3a1b12c52428683f7956dc49abb369b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f2dc0bbd50747b33174705ec7d053d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a92f2dc0bbd50747b33174705ec7d053d">factors_power</a> (<a class="el" href="structfactors__t.html">factors_t</a> *factors, uint64_t power)</td></tr>
<tr class="memdesc:a92f2dc0bbd50747b33174705ec7d053d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise a factorization to a power, ie multiply all exponents by a constant.  <a href="factorization_8h.html#a92f2dc0bbd50747b33174705ec7d053d">More...</a><br /></td></tr>
<tr class="separator:a92f2dc0bbd50747b33174705ec7d053d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2afd22c1848d49979647307b8c9d27d"><td class="memItemLeft" align="right" valign="top"><a id="ab2afd22c1848d49979647307b8c9d27d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#ab2afd22c1848d49979647307b8c9d27d">forall_divisors_tmptmp</a> (const <a class="el" href="structfactors__t.html">factors_t</a> *factors, int(*f)(const <a class="el" href="structfactors__t.html">factors_t</a> *, uint64_t, void *), void *data)</td></tr>
<tr class="memdesc:ab2afd22c1848d49979647307b8c9d27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <a class="el" href="factorization_8h.html#a6c85bad7fe6d6cf30066a5f2b7cd48ef">forall_divisors</a> with temporarily allocated dfactors and pfactors structs. <br /></td></tr>
<tr class="separator:ab2afd22c1848d49979647307b8c9d27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c85bad7fe6d6cf30066a5f2b7cd48ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a6c85bad7fe6d6cf30066a5f2b7cd48ef">forall_divisors</a> (const <a class="el" href="structfactors__t.html">factors_t</a> *factors, int(*f)(const <a class="el" href="structfactors__t.html">factors_t</a> *, uint64_t, void *), void *data, <a class="el" href="structfactors__t.html">factors_t</a> *dfactors, <a class="el" href="structfactors__t.html">factors_t</a> *pfactors)</td></tr>
<tr class="memdesc:a6c85bad7fe6d6cf30066a5f2b7cd48ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a given function on each divisor of a number, given its factorization.  <a href="factorization_8h.html#a6c85bad7fe6d6cf30066a5f2b7cd48ef">More...</a><br /></td></tr>
<tr class="separator:a6c85bad7fe6d6cf30066a5f2b7cd48ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e279e13d6d717a98b44ba82a7d6ef66"><td class="memItemLeft" align="right" valign="top"><a id="a1e279e13d6d717a98b44ba82a7d6ef66"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a1e279e13d6d717a98b44ba82a7d6ef66">forall_divisors_le_tmptmp</a> (const <a class="el" href="structfactors__t.html">factors_t</a> *factors, uint64_t d_max, int(*f)(const <a class="el" href="structfactors__t.html">factors_t</a> *, uint64_t, void *), void *data)</td></tr>
<tr class="memdesc:a1e279e13d6d717a98b44ba82a7d6ef66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <a class="el" href="factorization_8h.html#a384cb020a39cf0ccb2d59b659faeff2a">forall_divisors_le</a> with temporarily allocated dfactors and pfactors structs. <br /></td></tr>
<tr class="separator:a1e279e13d6d717a98b44ba82a7d6ef66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384cb020a39cf0ccb2d59b659faeff2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a384cb020a39cf0ccb2d59b659faeff2a">forall_divisors_le</a> (const <a class="el" href="structfactors__t.html">factors_t</a> *factors, uint64_t d_max, int(*f)(const <a class="el" href="structfactors__t.html">factors_t</a> *, uint64_t, void *), void *data, <a class="el" href="structfactors__t.html">factors_t</a> *dfactors, <a class="el" href="structfactors__t.html">factors_t</a> *pfactors)</td></tr>
<tr class="memdesc:a384cb020a39cf0ccb2d59b659faeff2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a given function on each divisor of a number, given its factorization, skipping divisors over a given bound.  <a href="factorization_8h.html#a384cb020a39cf0ccb2d59b659faeff2a">More...</a><br /></td></tr>
<tr class="separator:a384cb020a39cf0ccb2d59b659faeff2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5aa9870e338e6294a78fcf2b4b4d319"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#aa5aa9870e338e6294a78fcf2b4b4d319">factors_fprint</a> (FILE *file, const <a class="el" href="structfactors__t.html">factors_t</a> *factors)</td></tr>
<tr class="memdesc:aa5aa9870e338e6294a78fcf2b4b4d319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a factorization of a number.  <a href="factorization_8h.html#aa5aa9870e338e6294a78fcf2b4b4d319">More...</a><br /></td></tr>
<tr class="separator:aa5aa9870e338e6294a78fcf2b4b4d319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb850a90841e804deafef1b99a7685e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#acb850a90841e804deafef1b99a7685e3">factors_append</a> (<a class="el" href="structfactors__t.html">factors_t</a> *factors, uint64_t m, uint64_t k)</td></tr>
<tr class="memdesc:acb850a90841e804deafef1b99a7685e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a power of some prime to an existing factorization struct.  <a href="factorization_8h.html#acb850a90841e804deafef1b99a7685e3">More...</a><br /></td></tr>
<tr class="separator:acb850a90841e804deafef1b99a7685e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65217fd7242cfdb6692af53fa2d3783a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a65217fd7242cfdb6692af53fa2d3783a">factors_combine</a> (<a class="el" href="structfactors__t.html">factors_t</a> *factors, const <a class="el" href="structfactors__t.html">factors_t</a> *factors2, uint64_t k)</td></tr>
<tr class="memdesc:a65217fd7242cfdb6692af53fa2d3783a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all prime/power pairs in one factorization to another.  <a href="factorization_8h.html#a65217fd7242cfdb6692af53fa2d3783a">More...</a><br /></td></tr>
<tr class="separator:a65217fd7242cfdb6692af53fa2d3783a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f440156b01a0d0b2131c0401fe6e0c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a2f440156b01a0d0b2131c0401fe6e0c7">__attribute__</a> ((const)) int is_prime_dmr(uint64_t n)</td></tr>
<tr class="memdesc:a2f440156b01a0d0b2131c0401fe6e0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if n is prime using a deterministic Miller-Rabin test.  <a href="factorization_8h.html#a2f440156b01a0d0b2131c0401fe6e0c7">More...</a><br /></td></tr>
<tr class="separator:a2f440156b01a0d0b2131c0401fe6e0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0429f4ae877e6068f0cb728ded0576"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#afc0429f4ae877e6068f0cb728ded0576">factor_heuristic</a> (uint64_t n, uint64_t num_primes, const uint64_t primes[static num_primes], const <a class="el" href="structfactor__conf__t.html">factor_conf_t</a> *conf, <a class="el" href="structfactors__t.html">factors_t</a> *factors)</td></tr>
<tr class="memdesc:afc0429f4ae877e6068f0cb728ded0576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor a number using a variety of approaches based on its size.  <a href="factorization_8h.html#afc0429f4ae877e6068f0cb728ded0576">More...</a><br /></td></tr>
<tr class="separator:afc0429f4ae877e6068f0cb728ded0576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461682a31c02f03c4bcdc8f4decc781f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a461682a31c02f03c4bcdc8f4decc781f">__attribute__</a> ((access(write_only, 3), access(write_only, 4))) bool is_perfect_power(uint64_t a</td></tr>
<tr class="memdesc:a461682a31c02f03c4bcdc8f4decc781f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a is a perfect power of some integer.  <a href="factorization_8h.html#a461682a31c02f03c4bcdc8f4decc781f">More...</a><br /></td></tr>
<tr class="separator:a461682a31c02f03c4bcdc8f4decc781f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae8c8ea55d6cfc6e989c02428663c4584"><td class="memItemLeft" align="right" valign="top"><a id="ae8c8ea55d6cfc6e989c02428663c4584"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_primes</b></td></tr>
<tr class="separator:ae8c8ea55d6cfc6e989c02428663c4584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913725673d9d78b083c6b2d5d405cd3c"><td class="memItemLeft" align="right" valign="top"><a id="a913725673d9d78b083c6b2d5d405cd3c"></a>
uint64_t const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>primes</b> [static num_primes]</td></tr>
<tr class="separator:a913725673d9d78b083c6b2d5d405cd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5344e9ad7fc685a375f0cb4b16aea8"><td class="memItemLeft" align="right" valign="top"><a id="a5b5344e9ad7fc685a375f0cb4b16aea8"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>power</b></td></tr>
<tr class="separator:a5b5344e9ad7fc685a375f0cb4b16aea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2c4853383224350c6bbb9a163b8941"><td class="memItemLeft" align="right" valign="top"><a id="a0b2c4853383224350c6bbb9a163b8941"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>k</b></td></tr>
<tr class="separator:a0b2c4853383224350c6bbb9a163b8941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf11c67b90be97418cbce4e0e4e8bc2c"><td class="memItemLeft" align="right" valign="top"><a id="adf11c67b90be97418cbce4e0e4e8bc2c"></a>
uint64_t const uint64_t <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>factors</b></td></tr>
<tr class="separator:adf11c67b90be97418cbce4e0e4e8bc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ce16c7b23bc969f2ee17afc4348f8f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>n</b></td></tr>
<tr class="separator:ac6ce16c7b23bc969f2ee17afc4348f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7135b17ae1ad3039b3d2a45b8b3c354"><td class="memItemLeft" align="right" valign="top"><a id="ad7135b17ae1ad3039b3d2a45b8b3c354"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>max</b></td></tr>
<tr class="separator:ad7135b17ae1ad3039b3d2a45b8b3c354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2425dc8535f3f263e251bec953d61fea"><td class="memItemLeft" align="right" valign="top"><a id="a2425dc8535f3f263e251bec953d61fea"></a>
uint64_t uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><b>_base</b></td></tr>
<tr class="separator:a2425dc8535f3f263e251bec953d61fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab447095c764b4419ec9deee5b715d51a"><td class="memItemLeft" align="right" valign="top"><a id="ab447095c764b4419ec9deee5b715d51a"></a>
uint64_t uint64_t uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><b>_exp</b></td></tr>
<tr class="separator:ab447095c764b4419ec9deee5b715d51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040359f45343ce6667f5c66fda5f50e3"><td class="memItemLeft" align="right" valign="top"><a id="a040359f45343ce6667f5c66fda5f50e3"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>x</b></td></tr>
<tr class="separator:a040359f45343ce6667f5c66fda5f50e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497ec3256307fc12fa5f65de9b7d8190"><td class="memItemLeft" align="right" valign="top"><a id="a497ec3256307fc12fa5f65de9b7d8190"></a>
uint64_t uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>m</b></td></tr>
<tr class="separator:a497ec3256307fc12fa5f65de9b7d8190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c837fc3446c877e4dd3bdcd76d1f92"><td class="memItemLeft" align="right" valign="top"><a id="a01c837fc3446c877e4dd3bdcd76d1f92"></a>
int64_t int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>y</b></td></tr>
<tr class="separator:a01c837fc3446c877e4dd3bdcd76d1f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffa4b3783e5f20b9ec1c403ca3e44bc"><td class="memItemLeft" align="right" valign="top"><a id="a6ffa4b3783e5f20b9ec1c403ca3e44bc"></a>
int64_t int64_t int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>a</b></td></tr>
<tr class="separator:a6ffa4b3783e5f20b9ec1c403ca3e44bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1738c3e2251b82c014717830e8687d"><td class="memItemLeft" align="right" valign="top"><a id="a0e1738c3e2251b82c014717830e8687d"></a>
int64_t int64_t int64_t int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>B</b></td></tr>
<tr class="separator:a0e1738c3e2251b82c014717830e8687d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0d40c587b0eed4c8b21d206009d4f5"><td class="memItemLeft" align="right" valign="top">const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a0b0d40c587b0eed4c8b21d206009d4f5">small_primes</a> [25]</td></tr>
<tr class="memdesc:a0b0d40c587b0eed4c8b21d206009d4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array containing the 25 primes up to 100.  <a href="factorization_8h.html#a0b0d40c587b0eed4c8b21d206009d4f5">More...</a><br /></td></tr>
<tr class="separator:a0b0d40c587b0eed4c8b21d206009d4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401ed81d2bb12d1accea148f09298e94"><td class="memItemLeft" align="right" valign="top"><a id="a401ed81d2bb12d1accea148f09298e94"></a>
const <a class="el" href="structfactor__conf__t.html">factor_conf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a401ed81d2bb12d1accea148f09298e94">default_factor_conf</a></td></tr>
<tr class="memdesc:a401ed81d2bb12d1accea148f09298e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for <a class="el" href="factorization_8h.html#afc0429f4ae877e6068f0cb728ded0576">factor_heuristic</a> Use if you don't want to tune the parameters or don't care. <br /></td></tr>
<tr class="separator:a401ed81d2bb12d1accea148f09298e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9641e499ad990b5eb66cda6400f55e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9641e499ad990b5eb66cda6400f55e5b">&#9670;&nbsp;</a></span>DIVS_BEFORE_PRIME_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DIVS_BEFORE_PRIME_CHECK&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Currently unused. </p>
<p>How many trial divisions to do before performing randomized prime tests (Miller Rabin). For 64 bit numbers, we can easily make Miller Rabin deterministic in 7 tests, whereas up to 40 would be used to check a large number. BSW and ECPP are also important for checking large primes, because BSW and Miller Rabin together can provide a higher primality confidence faster, whereas ECPP is much slower but provides an easily verifiable proof. </p>

<p class="definition">Definition at line <a class="el" href="factorization_8h_source.html#l00035">35</a> of file <a class="el" href="factorization_8h_source.html">factorization.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adbaa273b8beccd77d082b8af9cef9b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbaa273b8beccd77d082b8af9cef9b8f">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(malloc)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a factors structure that can hold a given number of distinct primes. </p>
<p>Allocate a copy of a factors struct, but with only enough memory to store its current factors and not its max capacity if higher.</p>
<p>Allocate a factors structure that can hold all factors of n, even if it has as many prime factors as possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_primes</td><td>the number of distinct primes that should be storable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to factors structure that can hold max_primes. pointer needs to be free'd</dd></dl>
<p>E.g. 210=2*3*5*7 and 2310=2*3*5*7*11 so 210-2309 can have up to 4 distinct prime factors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number up to which the distinct prime factors of any number should be storable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_primes</td><td>number of primes in array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primes</td><td>array of primes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to factors structure that can hold enough distinct primes to factor any number up through n. pointer needs to be free'd</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>the struct to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the input or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a3a1b12c52428683f7956dc49abb369b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1b12c52428683f7956dc49abb369b6">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(pure)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a factorization into a number. </p>
<p>Get an element from an array of bitfields of length 2, aka uint2's.</p>
<p>Get a bit from a bitarray.</p>
<p>Factor out all powers of a given array of primes.</p>
<p>Find Carmichael's Lambda function, the smallest exponent m so a^m = 1 for all 0 &lt; a &lt; n.</p>
<p>Find Euler's Phi function, the number of coprime numbers less than n.</p>
<p>Find the number of k-tuples with product n.</p>
<p>Find the sum of powers of divisors of a number given its prime factorization, including itself and 1.</p>
<p>Find the sum of divisors of a number given its prime factorization, including itself and 1.</p>
<p>Find the number of divisors of a number given its prime factorization, including itself and 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factors struct, as obtained from <a class="el" href="">factor_trial_div</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>product of prime powers described by factors</dd></dl>
<p>Works by multiplying power + 1 for all prime factors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factors struct, as obtained from <a class="el" href="">factor_trial_div</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of divisors</dd></dl>
<p>Works by multiplying (prime**(power+1)-1)/(prime-1) for all prime factors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factors struct, as obtained from <a class="el" href="">factor_trial_div</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of divisors</dd></dl>
<p>Note this is NOT the same as the sum of divisors of a number. Works by multiplying (prime**((power+1)*e)-1)/(prime**e-1) for all prime factors, where power is the power of each prime and e is the power of divisors to sum </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factors struct, as obtained from <a class="el" href="">factor_trial_div</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">power</td><td>power of divisors to sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of divisor powers</dd></dl>
<p>given the factorization of n. Works by multiplying binom(power + k, k) for all prime factors, where power is the power of eaach prime </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factors struct, as obtained from <a class="el" href="">factor_trial_div</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>tuple length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of factorizations into k numbers, allowing repeats and considering order</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>the factorization of n for which to compute phi </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>phi(n)</dd></dl>
<p>Always divides phi(n). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>the factorization of n for which to compute the carmichael function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lambda(n)</dd></dl>
<p>Primesieve is a good general source for primes, but the api for this function is designed to allow giving a specialized list of primes like only primes equal to 1 mod 6 if it is known that all factors have some form, or to provide an empty list when this function is used in a more generic context like <a class="el" href="factorization_8h.html#afc0429f4ae877e6068f0cb728ded0576">factor_heuristic</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_primes</td><td>the number of primes in the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primes</td><td>the array of primes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">factors</td><td>pointer to struct where factors will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n with all factors found and stored in factors divided out. Thus if n factors completely over the given primes, 1 is returned.</dd></dl>
<p>Simply does buf[i/64] &amp; (1ull &lt;&lt; (i%64)). Only the truthiness of the result should be considered, all nonzero values should be treated as equivalent </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to bitarray </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of element to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if i-th element is false, nonzero otherwise</dd></dl>
<p>The result will be shifted to the least significant position, that is, only 0, 1, 2, and 3 are possible results. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to array of bitfields </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of element to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>i-th element (0, 1, 2, or 3) </dd></dl>

</div>
</div>
<a id="a92f2dc0bbd50747b33174705ec7d053d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f2dc0bbd50747b33174705ec7d053d">&#9670;&nbsp;</a></span>factors_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void factors_power </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raise a factorization to a power, ie multiply all exponents by a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factors</td><td>factorization to raise to a power </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">power</td><td>power to raise the factorization to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c85bad7fe6d6cf30066a5f2b7cd48ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c85bad7fe6d6cf30066a5f2b7cd48ef">&#9670;&nbsp;</a></span>forall_divisors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int forall_divisors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const <a class="el" href="structfactors__t.html">factors_t</a> *, uint64_t, void *)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>dfactors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>pfactors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a given function on each divisor of a number, given its factorization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>the factorization of n for which to compute all divisors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>callback function. Arguments are factorization of divisor, divisor, user data (respectively). Should return 0 to continue, or 1 to break. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>user data (allows arbitrary data to be passed in and out of the callback) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dfactors</td><td>buffer to store internal work. Should be allocated to hold at least factors-&gt;num_primes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfactors</td><td>buffer to store internal work. Should be allocated to hlod at least factors-&gt;num_primes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the callback never returned 1 and all divisors were visited, or 1 if the callback ever returned nonzero. </dd></dl>

</div>
</div>
<a id="a384cb020a39cf0ccb2d59b659faeff2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384cb020a39cf0ccb2d59b659faeff2a">&#9670;&nbsp;</a></span>forall_divisors_le()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int forall_divisors_le </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const <a class="el" href="structfactors__t.html">factors_t</a> *, uint64_t, void *)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>dfactors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>pfactors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a given function on each divisor of a number, given its factorization, skipping divisors over a given bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>the factorization of n for which to compute all divisors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_max</td><td>max divisor to visit. This should be less than the product of factors, otherwise just use forall_divisors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>callback function. Arguments are factorization of divisor, divisor, user data (respectively). Should return 0 to continue, or 1 to break. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>user data (allows arbitrary data to be passed in and out of the callback) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dfactors</td><td>buffer to store internal work. Should be allocated to hold at least factors-&gt;num_primes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfactors</td><td>buffer to store internal work. Should be allocated to hlod at least factors-&gt;num_primes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the callback never returned 1 and all divisors were visited, or 1 if the callback ever returned nonzero. </dd></dl>

</div>
</div>
<a id="aa5aa9870e338e6294a78fcf2b4b4d319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5aa9870e338e6294a78fcf2b4b4d319">&#9670;&nbsp;</a></span>factors_fprint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int factors_fprint </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a factorization of a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td>pointer to file to print to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factorization struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of characters printed </dd></dl>

</div>
</div>
<a id="acb850a90841e804deafef1b99a7685e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb850a90841e804deafef1b99a7685e3">&#9670;&nbsp;</a></span>factors_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void factors_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a power of some prime to an existing factorization struct. </p>
<p>If the input factorization is sorted before this function is called, it will still be sorted after, and if the factor to be added is already present its power will be increased rather than creating a separate entry. The factorization struct must have enough space if an additional entry is needed. Composite numbers or zero powers should not be supplied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factors</td><td>pointer to factorization struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>prime </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>power </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65217fd7242cfdb6692af53fa2d3783a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65217fd7242cfdb6692af53fa2d3783a">&#9670;&nbsp;</a></span>factors_combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void factors_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add all prime/power pairs in one factorization to another. </p>
<p>If both inputs are sorted, the result will be sorted and no dupliate entries will be created. Acts as if <a class="el" href="factorization_8h.html#acb850a90841e804deafef1b99a7685e3">factors_append</a> were called repeatedly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factors</td><td>pointer to factorization struct which should be extended </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors2</td><td>pointer to factorization struct whose entries will be added to the other struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>power to multiply entries of factors2 by, for if some composite number m was discovered where m^k divides n and we have factored m </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f440156b01a0d0b2131c0401fe6e0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f440156b01a0d0b2131c0401fe6e0c7">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(const)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if n is prime using a deterministic Miller-Rabin test. </p>
<p>Compute the maximum number of unique prime divisors a number can have.</p>
<p>Get the pitch for a pitched array of <a class="el" href="structfw__u64arr__t.html">fw_u64arr_t</a> factor lists.</p>
<p>Get the pitch for a pitched array of factorization structs with w unique prime divisors.</p>
<p>Compute an upper bound on the number of primes up to max.</p>
<p>Compute the square root of a quadratic residue mod a prime.</p>
<p>Compute the Jacobi symbol of n mod k.</p>
<p>Compute the least common multiple of a and b Divides the product by the gcd so can overflow for large arguments.</p>
<p>Compute n mod pq st n = a mod p and n = b mod q, where p and q are coprime.</p>
<p>Compute the Euclidean remainder r = a mod n for positive n so that 0 &lt;= r &lt; n.</p>
<p>Compute nonnegative integral power of a number modulo another using binary exponentiation.</p>
<p>Same as <a class="el" href="">factor1_lenstra</a> but using a projective Montgomery curve and Montgomery ladder.</p>
<p>Try to find a factor of a number using Lenstra ecf.</p>
<p>Try to find a factor of a number using Pollard's Rho algorithm with Brent cycle finding and gcd coalescing.</p>
<p>Try to find a factor of a number using Pollard's Rho algorithm with Floyd cycle finding.</p>
<p>Get the floor of the nth root of a.</p>
<p>7 partictular bases are used so that no composite number will falsely be reported as prime for the entire 64-bit range </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to check for primality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if n is prime, false otherwise</dd></dl>
<p>Uses bitscan to estimate the base 2 log and in turn nth root of a, then uses Newton's method </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the number to take the nth root of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>root to take </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>floor(a**(1/n)), ie the largest integer x such that x**n &lt;= a</dd></dl>
<p>Note that this will not find factors of 4 or 25 no matter what x is. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>random value mod n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise</dd></dl>
<p>Note that his will not find factors of 4 or 25 no matter what x is. m does not affect whether x will lead to a factor of n, it just means each iteration will be cheaper but up to 2m extraneous iterations could be performed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>random value mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of iterations per gcd check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise</dd></dl>
<p>In particular, an affine wierstrass representation is used internally and scalar multiplication is done using a binary "double and add" algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y,a</td><td>random values mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>number of trials before giving up (we compute kP for k from 2 to B) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise</dd></dl>
<p>Instead of an affine Wierstrass curve and binary multiplication. This is supposed to be faster but seems to be about the same. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y,a</td><td>random numbers mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>number of trials before giving up (we compute kP for k from 2 to B) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b,e,n</td><td>base, exponent, and modulus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>b^e mod n, computed via binary exponentiation</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,n</td><td>dividend and divisor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mod n</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,p,b,q</td><td>Chinese Remainder Theorem parameters. The residues a and b should not be negative. The moduli p and q should be coprime. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 &lt;= 0 &lt; pq so that n = a mod p and n = b mod q</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>numbers to find lcm of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lcm(a, b)</dd></dl>
<p>Uses modified euclidean algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n,k</td><td>Jacobi symbol parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jacobi symbol (0 if k | n, +1 if n is a quadratic residue mod an odd number of prime divisors of k (with multiplicity), -1 otherwise)</dd></dl>
<p>If n is not a residue or p is not a prime, the value returned may not be useful but the function will terminate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>a quadratic residue mod p </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a prime </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>r so that r^2 = n mod p</dd></dl>
<p>This uses an inequality involving log derived from the prime number theorem to always get an upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>number to find the number of primes up to </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">an</td><td>upper bound on the number of primes up to max</td></tr>
  </table>
  </dd>
</dl>
<p>This is simply offsetof(factors_t, factors) + w*sizeof(dummy-&gt;factors[0]), where dummy is an expression with type <a class="el" href="structfactors__t.html" title="A prime factorization.">factors_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The maximal number of unique prime divisors of any potential index of the pitched array. Should be obtained from <a class="el" href="sieves_8h.html#a55b7ec1e3f2ac442b0f098861f758cff">sieve_factorizations</a>, <a class="el" href="">max_prime_divisors</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pitch of a pitched array of factorization structs whose flexible length members all have w elements.</dd></dl>
<p>This is simply offsetof(fw_u64arr_t, elems) + *_w*sizeof(uint64_t). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The maximal number of unique prime divisors of any potential index of the pitched array. Should be obtained from <a class="el" href="sieves_8h.html#a1bca79bd17302449e4a95f833e2990c8">sieve_factors</a>, <a class="el" href="">max_prime_divisors</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pitch of a pitched array of factor list structs whose flexible length members all have w elements. </dd></dl>

</div>
</div>
<a id="afc0429f4ae877e6068f0cb728ded0576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0429f4ae877e6068f0cb728ded0576">&#9670;&nbsp;</a></span>factor_heuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t factor_heuristic </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_primes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>primes</em>[static num_primes], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfactor__conf__t.html">factor_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factor a number using a variety of approaches based on its size. </p>
<p>If conf-&gt;pollard_max is greater than 3, the primes array should include at least 2 and 5 to avoid an infinite loop since <a class="el" href="">factor1_pollard_rho</a> can't factor 4 or 25. Currently a configuration struct must be passed. Kraitcheck methods (quadratic sieve and number field sieve) are not implemented because they are useless on 64 bit integers. Parameters to Pollard-Rho-Brent with gcd aggregation and Lenstra ecf are not tuned by this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_primes</td><td>the number of primes in the array to try trial division on (use 25 if using <a class="el" href="factorization_8h.html#a0b0d40c587b0eed4c8b21d206009d4f5">small_primes</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primes</td><td>array of primes (can use <a class="el" href="factorization_8h.html#a0b0d40c587b0eed4c8b21d206009d4f5">small_primes</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>limits for different algorithms (can use <a class="el" href="factorization_8h.html#a401ed81d2bb12d1accea148f09298e94">default_factor_conf</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">factors</td><td>output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n with all factors found and stored in factors divided out. Thus if n factors completely, 1 is returned. </dd></dl>

</div>
</div>
<a id="a461682a31c02f03c4bcdc8f4decc781f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461682a31c02f03c4bcdc8f4decc781f">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(access(write_only, 3), access(write_only, 4))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a is a perfect power of some integer. </p>
<p>Used in <a class="el" href="factorization_8h.html#afc0429f4ae877e6068f0cb728ded0576">factor_heuristic</a>. max is the max exponent a could possibly be, which is limited because it is a uint64_t. If nothing is known about a, then the max exponent it could be is 63, if it were 2**63. However, if we know that the base of a must be larger than some minimum, such as if we know a is not divisible by any primes up to some point, then we can set a lower limit on the max exponent. For example, if a is 2-rough (not divisible by any primes &lt;= 2), then the minimum possible base is 3, so the maximal exponent is 40 instead. For all primes in the small_primes array, the max exponents are as follows: 2-rough -&gt; min base 3 -&gt; max exponent 40 3 -&gt; 5 -&gt; 27 5 -&gt; 7 -&gt; 22 7 -&gt; 11 -&gt; 18 11 -&gt; 13 -&gt; 17 13 -&gt; 17 -&gt; 15 19 -&gt; 23 -&gt; 14 23 -&gt; 29 -&gt; 13 29 -&gt; 31 -&gt; 12 37 -&gt; 41 -&gt; 11 57 -&gt; 59 -&gt; 10 83 -&gt; 89 -&gt; 9 and going over 100: 137 -&gt; 139 -&gt; 8 251 -&gt; 257 -&gt; 7 563 -&gt; 569 -&gt; 6 1621 -&gt; 1627 -&gt; 5 7129 -&gt; 7151 -&gt; 4 65521 -&gt; 65537 -&gt; 3 2642239 -&gt; 2642257 -&gt; 2 4294967291 -&gt; 4294967311 -&gt; 1 The max exponent can also be brought down if a is known to be small, but depending on context it may or may not be worth computing log(a)/log(p) where p is the largest prime not known to not divide a. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the number to check for being a perfect power </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>the max exponent a could possibly be. Use eg 63 if unknown, 11 if a has had all factors of primes up to 47 removed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_base</td><td>if a is found to be a perfect power, store the base here </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_exp</td><td>if a is found to be a perfect power, store the exponent here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a is a perfect power (with exponent max or lower), false otherwise (could mean a is not a perfect power, or could mean a is a perfect power with exponent max + 1 to 61) </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac6ce16c7b23bc969f2ee17afc4348f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ce16c7b23bc969f2ee17afc4348f8f">&#9670;&nbsp;</a></span>n</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t n</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    int64_t r = a%n</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="factorization_8h_source.html#l00234">234</a> of file <a class="el" href="factorization_8h_source.html">factorization.h</a>.</p>

</div>
</div>
<a id="a0b0d40c587b0eed4c8b21d206009d4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0d40c587b0eed4c8b21d206009d4f5">&#9670;&nbsp;</a></span>small_primes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t small_primes[25]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An array containing the 25 primes up to 100. </p>
<p><a class="el" href="">factor1_pollard_rho</a> and <a class="el" href="">factor1_pollard_rho_brent</a> can't find factors of 4 or 25 using the default polynomial, so if using <a class="el" href="factorization_8h.html#afc0429f4ae877e6068f0cb728ded0576">factor_heuristic</a> at least these primes should be used for trial division if the configuration allows pollard rho to be called. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_073faa820624379b5730e5b4f5cb1c42.html">nut</a></li><li class="navelem"><a class="el" href="factorization_8h.html">factorization.h</a></li>
    <li class="footer">Generated on Tue May 9 2023 08:06:58 for Number Theory Utils by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
