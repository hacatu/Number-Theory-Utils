<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Number Theory Utils: include/factorization.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Number Theory Utils
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">factorization.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
</div>
<p><a href="factorization_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfactors__t.html">factors_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A prime factorization.  <a href="structfactors__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfactor__conf__t.html">factor_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration/tuning for heuristic factorization.  <a href="structfactor__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a28f056a31fe5cbaa059a0740d3339e5b"><td class="memItemLeft" align="right" valign="top"><a id="a28f056a31fe5cbaa059a0740d3339e5b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a28f056a31fe5cbaa059a0740d3339e5b">MAX_PRIMES_32</a>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a28f056a31fe5cbaa059a0740d3339e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most distinct prime divisors a uint32_t can have. <br /></td></tr>
<tr class="separator:a28f056a31fe5cbaa059a0740d3339e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f29234154854a63ff0f50e0259c1cd6"><td class="memItemLeft" align="right" valign="top"><a id="a9f29234154854a63ff0f50e0259c1cd6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a9f29234154854a63ff0f50e0259c1cd6">MAX_PRIMES_64</a>&#160;&#160;&#160;15</td></tr>
<tr class="memdesc:a9f29234154854a63ff0f50e0259c1cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most distinct prime divisors a uint64_t can have. <br /></td></tr>
<tr class="separator:a9f29234154854a63ff0f50e0259c1cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11bbeaacb214223d9c679b307348a6b"><td class="memItemLeft" align="right" valign="top"><a id="ac11bbeaacb214223d9c679b307348a6b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#ac11bbeaacb214223d9c679b307348a6b">MAX_PRIMES_128</a>&#160;&#160;&#160;25</td></tr>
<tr class="memdesc:ac11bbeaacb214223d9c679b307348a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most distinct prime divisors a uint128_t can have. <br /></td></tr>
<tr class="separator:ac11bbeaacb214223d9c679b307348a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9641e499ad990b5eb66cda6400f55e5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a9641e499ad990b5eb66cda6400f55e5b">DIVS_BEFORE_PRIME_CHECK</a>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a9641e499ad990b5eb66cda6400f55e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently unused.  <a href="factorization_8h.html#a9641e499ad990b5eb66cda6400f55e5b">More...</a><br /></td></tr>
<tr class="separator:a9641e499ad990b5eb66cda6400f55e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a46c4371d5a6429f33f04d01da5b166ec"><td class="memItemLeft" align="right" valign="top">typedef signed __int128&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a46c4371d5a6429f33f04d01da5b166ec">int128_t</a></td></tr>
<tr class="memdesc:a46c4371d5a6429f33f04d01da5b166ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty name for signed 128 bit integer.  <a href="factorization_8h.html#a46c4371d5a6429f33f04d01da5b166ec">More...</a><br /></td></tr>
<tr class="separator:a46c4371d5a6429f33f04d01da5b166ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396787e5ec029b1205bd3e4cd9763e7d"><td class="memItemLeft" align="right" valign="top">typedef unsigned __int128&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a396787e5ec029b1205bd3e4cd9763e7d">uint128_t</a></td></tr>
<tr class="memdesc:a396787e5ec029b1205bd3e4cd9763e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty name for unsigned 128 bit integer.  <a href="factorization_8h.html#a396787e5ec029b1205bd3e4cd9763e7d">More...</a><br /></td></tr>
<tr class="separator:a396787e5ec029b1205bd3e4cd9763e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a487385b324e0d39124f186234ec9aec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a487385b324e0d39124f186234ec9aec3">init_factors_t_w</a> (uint64_t max_primes)</td></tr>
<tr class="memdesc:a487385b324e0d39124f186234ec9aec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a factors structure that can hold a given number of distinct primes.  <a href="factorization_8h.html#a487385b324e0d39124f186234ec9aec3">More...</a><br /></td></tr>
<tr class="separator:a487385b324e0d39124f186234ec9aec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74c0b074b6830e1ad08f51d1c166583"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#ad74c0b074b6830e1ad08f51d1c166583">init_factors_t_ub</a> (uint64_t n, uint64_t num_primes, const uint64_t *primes)</td></tr>
<tr class="memdesc:ad74c0b074b6830e1ad08f51d1c166583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a factors structure that can hold all factors of n, even if it has as many prime factors as possible.  <a href="factorization_8h.html#ad74c0b074b6830e1ad08f51d1c166583">More...</a><br /></td></tr>
<tr class="separator:ad74c0b074b6830e1ad08f51d1c166583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dc8ed9447f6b0039ce7a002608b57b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a78dc8ed9447f6b0039ce7a002608b57b">factors_product</a> (const <a class="el" href="structfactors__t.html">factors_t</a> *factors) __attribute__((pure))</td></tr>
<tr class="memdesc:a78dc8ed9447f6b0039ce7a002608b57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a factorization into a number.  <a href="factorization_8h.html#a78dc8ed9447f6b0039ce7a002608b57b">More...</a><br /></td></tr>
<tr class="separator:a78dc8ed9447f6b0039ce7a002608b57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5aa9870e338e6294a78fcf2b4b4d319"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#aa5aa9870e338e6294a78fcf2b4b4d319">factors_fprint</a> (FILE *file, const <a class="el" href="structfactors__t.html">factors_t</a> *factors)</td></tr>
<tr class="memdesc:aa5aa9870e338e6294a78fcf2b4b4d319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a factorization of a number.  <a href="factorization_8h.html#aa5aa9870e338e6294a78fcf2b4b4d319">More...</a><br /></td></tr>
<tr class="separator:aa5aa9870e338e6294a78fcf2b4b4d319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb850a90841e804deafef1b99a7685e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#acb850a90841e804deafef1b99a7685e3">factors_append</a> (<a class="el" href="structfactors__t.html">factors_t</a> *factors, uint64_t m, uint64_t k)</td></tr>
<tr class="memdesc:acb850a90841e804deafef1b99a7685e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a power of some prime to an existing factorization struct.  <a href="factorization_8h.html#acb850a90841e804deafef1b99a7685e3">More...</a><br /></td></tr>
<tr class="separator:acb850a90841e804deafef1b99a7685e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65217fd7242cfdb6692af53fa2d3783a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a65217fd7242cfdb6692af53fa2d3783a">factors_combine</a> (<a class="el" href="structfactors__t.html">factors_t</a> *factors, const <a class="el" href="structfactors__t.html">factors_t</a> *factors2, uint64_t k)</td></tr>
<tr class="memdesc:a65217fd7242cfdb6692af53fa2d3783a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all prime/power pairs in one factorization to another.  <a href="factorization_8h.html#a65217fd7242cfdb6692af53fa2d3783a">More...</a><br /></td></tr>
<tr class="separator:a65217fd7242cfdb6692af53fa2d3783a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f80cb613e766907b6072fb751ff114c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a7f80cb613e766907b6072fb751ff114c">powmod</a> (uint64_t b, uint64_t e, uint64_t n) __attribute__((const))</td></tr>
<tr class="memdesc:a7f80cb613e766907b6072fb751ff114c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute nonnegative integral power of a number modulo another using binary exponentiation.  <a href="factorization_8h.html#a7f80cb613e766907b6072fb751ff114c">More...</a><br /></td></tr>
<tr class="separator:a7f80cb613e766907b6072fb751ff114c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8507a5fce6ddc90582e7072c9830bd24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a8507a5fce6ddc90582e7072c9830bd24">is_prime_dmr</a> (uint64_t n) __attribute__((const))</td></tr>
<tr class="memdesc:a8507a5fce6ddc90582e7072c9830bd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if n is prime using a deterministic Miller-Rabin test.  <a href="factorization_8h.html#a8507a5fce6ddc90582e7072c9830bd24">More...</a><br /></td></tr>
<tr class="separator:a8507a5fce6ddc90582e7072c9830bd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd9a1d3ee84a620aa47ce552002c1bb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#addd9a1d3ee84a620aa47ce552002c1bb">prand_u64</a> (uint64_t a, uint64_t b)</td></tr>
<tr class="memdesc:addd9a1d3ee84a620aa47ce552002c1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a (pseudo)random integer uniformly from [a, b).  <a href="factorization_8h.html#addd9a1d3ee84a620aa47ce552002c1bb">More...</a><br /></td></tr>
<tr class="separator:addd9a1d3ee84a620aa47ce552002c1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2abe4608c6ea4d6d292d776ce29cbfb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#ae2abe4608c6ea4d6d292d776ce29cbfb">rand_u64</a> (uint64_t a, uint64_t b)</td></tr>
<tr class="memdesc:ae2abe4608c6ea4d6d292d776ce29cbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a (strong) random integer uniformly from [a, b).  <a href="factorization_8h.html#ae2abe4608c6ea4d6d292d776ce29cbfb">More...</a><br /></td></tr>
<tr class="separator:ae2abe4608c6ea4d6d292d776ce29cbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9199063b7563cfe3731689da1ff48b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a3f9199063b7563cfe3731689da1ff48b">factor_trial_div</a> (uint64_t n, uint64_t num_primes, const uint64_t primes[static num_primes], <a class="el" href="structfactors__t.html">factors_t</a> *factors) __attribute__((pure))</td></tr>
<tr class="memdesc:a3f9199063b7563cfe3731689da1ff48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor out all powers of a given array of primes.  <a href="factorization_8h.html#a3f9199063b7563cfe3731689da1ff48b">More...</a><br /></td></tr>
<tr class="separator:a3f9199063b7563cfe3731689da1ff48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0429f4ae877e6068f0cb728ded0576"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#afc0429f4ae877e6068f0cb728ded0576">factor_heuristic</a> (uint64_t n, uint64_t num_primes, const uint64_t primes[static num_primes], const <a class="el" href="structfactor__conf__t.html">factor_conf_t</a> *conf, <a class="el" href="structfactors__t.html">factors_t</a> *factors)</td></tr>
<tr class="memdesc:afc0429f4ae877e6068f0cb728ded0576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor a number using a variety of approaches based on its size.  <a href="factorization_8h.html#afc0429f4ae877e6068f0cb728ded0576">More...</a><br /></td></tr>
<tr class="separator:afc0429f4ae877e6068f0cb728ded0576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af372c8a01b9d6b52314e0291e8082775"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#af372c8a01b9d6b52314e0291e8082775">factor1_pollard_rho</a> (uint64_t n, uint64_t x) __attribute__((const))</td></tr>
<tr class="memdesc:af372c8a01b9d6b52314e0291e8082775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a factor of a number using Pollard's Rho algorithm with Floyd cycle finding.  <a href="factorization_8h.html#af372c8a01b9d6b52314e0291e8082775">More...</a><br /></td></tr>
<tr class="separator:af372c8a01b9d6b52314e0291e8082775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c27a9bb8e04dc1ee7762d80609bd397"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a2c27a9bb8e04dc1ee7762d80609bd397">factor1_pollard_rho_brent</a> (uint64_t n, uint64_t x, uint64_t m) __attribute__((const))</td></tr>
<tr class="memdesc:a2c27a9bb8e04dc1ee7762d80609bd397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a factor of a number using Pollard's Rho algorithm with Brent cycle finding and gcd coalescing.  <a href="factorization_8h.html#a2c27a9bb8e04dc1ee7762d80609bd397">More...</a><br /></td></tr>
<tr class="separator:a2c27a9bb8e04dc1ee7762d80609bd397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579ecfd7ea5828099ccca38d8544c5a9"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a579ecfd7ea5828099ccca38d8544c5a9">factor1_lenstra</a> (int64_t n, int64_t x, int64_t y, int64_t a, int64_t B) __attribute__((const))</td></tr>
<tr class="memdesc:a579ecfd7ea5828099ccca38d8544c5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a factor of a number using Lenstra ecf.  <a href="factorization_8h.html#a579ecfd7ea5828099ccca38d8544c5a9">More...</a><br /></td></tr>
<tr class="separator:a579ecfd7ea5828099ccca38d8544c5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060384c42a77493f90148d011ad42a29"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a060384c42a77493f90148d011ad42a29">factor1_lenstra_montgomery</a> (int64_t n, int64_t x, int64_t y, int64_t a, int64_t B) __attribute__((const))</td></tr>
<tr class="memdesc:a060384c42a77493f90148d011ad42a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="factorization_8h.html#a579ecfd7ea5828099ccca38d8544c5a9">factor1_lenstra</a> but using a projective Montgomery curve and Montgomery ladder.  <a href="factorization_8h.html#a060384c42a77493f90148d011ad42a29">More...</a><br /></td></tr>
<tr class="separator:a060384c42a77493f90148d011ad42a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e0aa84d98c5b9a6e6dfe7a84e90a9a"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#ae9e0aa84d98c5b9a6e6dfe7a84e90a9a">jacobi</a> (int64_t n, int64_t k) __attribute__((const))</td></tr>
<tr class="memdesc:ae9e0aa84d98c5b9a6e6dfe7a84e90a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jacobi symbol of n mod k.  <a href="factorization_8h.html#ae9e0aa84d98c5b9a6e6dfe7a84e90a9a">More...</a><br /></td></tr>
<tr class="separator:ae9e0aa84d98c5b9a6e6dfe7a84e90a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680572674cab27e7ae541fe1fe663042"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a680572674cab27e7ae541fe1fe663042">rand_nr_u64</a> (int64_t p)</td></tr>
<tr class="memdesc:a680572674cab27e7ae541fe1fe663042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a random number mod a prime that is not a quadratic residue.  <a href="factorization_8h.html#a680572674cab27e7ae541fe1fe663042">More...</a><br /></td></tr>
<tr class="separator:a680572674cab27e7ae541fe1fe663042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3971aec9be84e37469c2953fe0a7bbc0"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a3971aec9be84e37469c2953fe0a7bbc0">sqrt_shanks</a> (int64_t n, int64_t p)</td></tr>
<tr class="memdesc:a3971aec9be84e37469c2953fe0a7bbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a quadratic residue mod a prime.  <a href="factorization_8h.html#a3971aec9be84e37469c2953fe0a7bbc0">More...</a><br /></td></tr>
<tr class="separator:a3971aec9be84e37469c2953fe0a7bbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4871f3a8602cb31a0963dbeeacb86faf"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a4871f3a8602cb31a0963dbeeacb86faf">sqrt_cipolla</a> (int64_t n, int64_t p)</td></tr>
<tr class="memdesc:a4871f3a8602cb31a0963dbeeacb86faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a quadratic residue mod a prime.  <a href="factorization_8h.html#a4871f3a8602cb31a0963dbeeacb86faf">More...</a><br /></td></tr>
<tr class="separator:a4871f3a8602cb31a0963dbeeacb86faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90556023960bf8187aaafd25f9aa536d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a90556023960bf8187aaafd25f9aa536d">sqrt_mod</a> (int64_t n, int64_t p)</td></tr>
<tr class="memdesc:a90556023960bf8187aaafd25f9aa536d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a quadratic residue mod a prime.  <a href="factorization_8h.html#a90556023960bf8187aaafd25f9aa536d">More...</a><br /></td></tr>
<tr class="separator:a90556023960bf8187aaafd25f9aa536d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.2.0 </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Functions for dealing with factorization and modular arithmetic on 64 bit integers (not suitable for large integers which may overflow, around 2^31. a bignum-enabled version may be created to handle this) </p>

<p class="definition">Definition in file <a class="el" href="factorization_8h_source.html">factorization.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9641e499ad990b5eb66cda6400f55e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9641e499ad990b5eb66cda6400f55e5b">&#9670;&nbsp;</a></span>DIVS_BEFORE_PRIME_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DIVS_BEFORE_PRIME_CHECK&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Currently unused. </p>
<p>How many trial divisions to do before performing randomized prime tests (Miller Rabin). For 64 bit numbers, we can easily make Miller Rabin deterministic in 7 tests, whereas up to 40 would be used to check a large number. BSW and ECPP are also important for checking large primes, because BSW and Miller Rabin together can provide a higher primality confidence faster, whereas ECPP is much slower but provides an easily verifiable proof. </p>

<p class="definition">Definition at line <a class="el" href="factorization_8h_source.html#l00032">32</a> of file <a class="el" href="factorization_8h_source.html">factorization.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a46c4371d5a6429f33f04d01da5b166ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c4371d5a6429f33f04d01da5b166ec">&#9670;&nbsp;</a></span>int128_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef signed __int128 <a class="el" href="factorization_8h.html#a46c4371d5a6429f33f04d01da5b166ec">int128_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty name for signed 128 bit integer. </p>
<p>GCC implements 128 bit arithmetic in terms of 64 bit arithmetic. </p>

<p class="definition">Definition at line <a class="el" href="factorization_8h_source.html#l00036">36</a> of file <a class="el" href="factorization_8h_source.html">factorization.h</a>.</p>

</div>
</div>
<a id="a396787e5ec029b1205bd3e4cd9763e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396787e5ec029b1205bd3e4cd9763e7d">&#9670;&nbsp;</a></span>uint128_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned __int128 <a class="el" href="factorization_8h.html#a396787e5ec029b1205bd3e4cd9763e7d">uint128_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty name for unsigned 128 bit integer. </p>
<p>GCC implements 128 bit arithmetic in terms of 64 bit arithmetic. </p>

<p class="definition">Definition at line <a class="el" href="factorization_8h_source.html#l00039">39</a> of file <a class="el" href="factorization_8h_source.html">factorization.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a487385b324e0d39124f186234ec9aec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487385b324e0d39124f186234ec9aec3">&#9670;&nbsp;</a></span>init_factors_t_w()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfactors__t.html">factors_t</a>* init_factors_t_w </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_primes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a factors structure that can hold a given number of distinct primes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_primes</td><td>the number of distinct primes that should be storable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to factors structure that can hold max_primes. pointer needs to be free'd </dd></dl>

</div>
</div>
<a id="ad74c0b074b6830e1ad08f51d1c166583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74c0b074b6830e1ad08f51d1c166583">&#9670;&nbsp;</a></span>init_factors_t_ub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfactors__t.html">factors_t</a>* init_factors_t_ub </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_primes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>primes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a factors structure that can hold all factors of n, even if it has as many prime factors as possible. </p>
<p>E.g. 210=2*3*5*7 and 2310=2*3*5*7*11 so 210-2309 can have up to 4 distinct prime factors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number up to which the distinct prime factors of any number should be storable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_primes</td><td>number of primes in array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primes</td><td>array of primes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to factors structure that can hold enough distinct primes to factor any number up through n. pointer needs to be free'd </dd></dl>

</div>
</div>
<a id="a78dc8ed9447f6b0039ce7a002608b57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78dc8ed9447f6b0039ce7a002608b57b">&#9670;&nbsp;</a></span>factors_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t factors_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a factorization into a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factors struct, as obtained from <a class="el" href="factorization_8h.html#a3f9199063b7563cfe3731689da1ff48b">factor_trial_div</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>product of prime powers described by factors </dd></dl>

</div>
</div>
<a id="aa5aa9870e338e6294a78fcf2b4b4d319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5aa9870e338e6294a78fcf2b4b4d319">&#9670;&nbsp;</a></span>factors_fprint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int factors_fprint </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a factorization of a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td>pointer to file to print to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factorization struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of characters printed </dd></dl>

</div>
</div>
<a id="acb850a90841e804deafef1b99a7685e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb850a90841e804deafef1b99a7685e3">&#9670;&nbsp;</a></span>factors_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void factors_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a power of some prime to an existing factorization struct. </p>
<p>If the input factorization is sorted before this function is called, it will still be sorted after, and if the factor to be added is already present its power will be increased rather than creating a separate entry. The factorization struct must have enough space if an additional entry is needed. Composite numbers or zero powers should not be supplied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factors</td><td>pointer to factorization struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>prime </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>power </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65217fd7242cfdb6692af53fa2d3783a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65217fd7242cfdb6692af53fa2d3783a">&#9670;&nbsp;</a></span>factors_combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void factors_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add all prime/power pairs in one factorization to another. </p>
<p>If both inputs are sorted, the result will be sorted and no dupliate entries will be created. Acts as if <a class="el" href="factorization_8h.html#acb850a90841e804deafef1b99a7685e3">factors_append</a> were called repeatedly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factors</td><td>pointer to factorization struct which should be extended </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors2</td><td>pointer to factorization struct whose entries will be added to the other struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>power to multiply entries of factors2 by, for if some composite number m was discovered where m^k divides n and we have factored m </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f80cb613e766907b6072fb751ff114c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f80cb613e766907b6072fb751ff114c">&#9670;&nbsp;</a></span>powmod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t powmod </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute nonnegative integral power of a number modulo another using binary exponentiation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b,e,n</td><td>base, exponent, and modulus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>b^e mod n, computed via binary exponentiation </dd></dl>

</div>
</div>
<a id="a8507a5fce6ddc90582e7072c9830bd24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8507a5fce6ddc90582e7072c9830bd24">&#9670;&nbsp;</a></span>is_prime_dmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_prime_dmr </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if n is prime using a deterministic Miller-Rabin test. </p>
<p>7 partictular bases are used so that no composite number will falsely be reported as prime for the entire 64-bit range </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to check for primality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if n is prime, false otherwise </dd></dl>

</div>
</div>
<a id="addd9a1d3ee84a620aa47ce552002c1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd9a1d3ee84a620aa47ce552002c1bb">&#9670;&nbsp;</a></span>prand_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t prand_u64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a (pseudo)random integer uniformly from [a, b). </p>
<p>Currently calls <a class="el" href="factorization_8h.html#ae2abe4608c6ea4d6d292d776ce29cbfb">rand_u64</a> so this number is generated from /dev/random but this function exists to provide a weaker, pseudorandom number source if this turns out to be a bottleneck. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>bounds of the interval [a, b) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(pseudo)random integer uniformly chosen from [a, b) </dd></dl>

</div>
</div>
<a id="ae2abe4608c6ea4d6d292d776ce29cbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2abe4608c6ea4d6d292d776ce29cbfb">&#9670;&nbsp;</a></span>rand_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t rand_u64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a (strong) random integer uniformly from [a, b). </p>
<p>Currently uses /dev/random via the getrandom function, but this is a Linux api. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>bounds of the interval [a, b) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(strong) random integer uniformly chosen from [a, b) </dd></dl>

</div>
</div>
<a id="a3f9199063b7563cfe3731689da1ff48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9199063b7563cfe3731689da1ff48b">&#9670;&nbsp;</a></span>factor_trial_div()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t factor_trial_div </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_primes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>primes</em>[static num_primes], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factor out all powers of a given array of primes. </p>
<p>Primesieve is a good general source for primes, but the api for this function is designed to allow giving a specialized list of primes like only primes equal to 1 mod 6 if it is known that all factors have some form, or to provide an empty list when this function is used in a more generic context like <a class="el" href="factorization_8h.html#afc0429f4ae877e6068f0cb728ded0576">factor_heuristic</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_primes</td><td>the number of primes in the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primes</td><td>the array of primes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">factors</td><td>pointer to struct where factors will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n with all factors found and stored in factors divided out. Thus if n factors completely over the given primes, 1 is returned. </dd></dl>

</div>
</div>
<a id="afc0429f4ae877e6068f0cb728ded0576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0429f4ae877e6068f0cb728ded0576">&#9670;&nbsp;</a></span>factor_heuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t factor_heuristic </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_primes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>primes</em>[static num_primes], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfactor__conf__t.html">factor_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factor a number using a variety of approaches based on its size. </p>
<p>Currently a configuration struct must be passed. Kraitcheck methods (quadratic sieve and number field sieve) are not implemented because they are useless on 64 bit integers. Parameters to Pollard-Rho-Brent with gcd aggregation and Lenstra ecf are not tuned by this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_primes</td><td>the number of primes in the array to try trial division on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primes</td><td>array of primes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>limits for different algorithms </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">factors</td><td>output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n with all factors found and stored in factors divided out. Thus if n factors completely, 1 is returned. </dd></dl>

</div>
</div>
<a id="af372c8a01b9d6b52314e0291e8082775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af372c8a01b9d6b52314e0291e8082775">&#9670;&nbsp;</a></span>factor1_pollard_rho()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t factor1_pollard_rho </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find a factor of a number using Pollard's Rho algorithm with Floyd cycle finding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>random value mod n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise </dd></dl>

</div>
</div>
<a id="a2c27a9bb8e04dc1ee7762d80609bd397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c27a9bb8e04dc1ee7762d80609bd397">&#9670;&nbsp;</a></span>factor1_pollard_rho_brent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t factor1_pollard_rho_brent </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find a factor of a number using Pollard's Rho algorithm with Brent cycle finding and gcd coalescing. </p>
<p>m does not affect whether x will lead to a factor of n, it just means each iteration will be cheaper but up to 2m extraneous iterations could be performed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>random value mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of iterations per gcd check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise </dd></dl>

</div>
</div>
<a id="a579ecfd7ea5828099ccca38d8544c5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579ecfd7ea5828099ccca38d8544c5a9">&#9670;&nbsp;</a></span>factor1_lenstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t factor1_lenstra </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find a factor of a number using Lenstra ecf. </p>
<p>In particular, an affine wierstrass representation is used internally and scalar multiplication is done using a binary "double and add" algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y,a</td><td>random values mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>number of trials before giving up (we compute kP for k from 2 to B) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise </dd></dl>

</div>
</div>
<a id="a060384c42a77493f90148d011ad42a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060384c42a77493f90148d011ad42a29">&#9670;&nbsp;</a></span>factor1_lenstra_montgomery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t factor1_lenstra_montgomery </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="factorization_8h.html#a579ecfd7ea5828099ccca38d8544c5a9">factor1_lenstra</a> but using a projective Montgomery curve and Montgomery ladder. </p>
<p>Instead of an affine Wierstrass curve and binary multiplication. This is supposed to be faster but seems to be about the same. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y,a</td><td>random numbers mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>number of trials before giving up (we compute kP for k from 2 to B) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise </dd></dl>

</div>
</div>
<a id="ae9e0aa84d98c5b9a6e6dfe7a84e90a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e0aa84d98c5b9a6e6dfe7a84e90a9a">&#9670;&nbsp;</a></span>jacobi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t jacobi </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Jacobi symbol of n mod k. </p>
<p>Uses modified euclidean algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n,k</td><td>Jacobi symbol parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jacobi symbol (0 if k | n, +1 if n is a quadratic residue mod an odd number of prime divisors of k (with multiplicity), -1 otherwise) </dd></dl>

</div>
</div>
<a id="a680572674cab27e7ae541fe1fe663042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680572674cab27e7ae541fe1fe663042">&#9670;&nbsp;</a></span>rand_nr_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t rand_nr_u64 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a random number mod a prime that is not a quadratic residue. </p>
<p>This is useful in Shanks's algorithm and others. This function works by rejection sampling using the Jacobi symbol as a test, which succeeds in 2(p-2)/(p-1) trials on average. If p is not prime, the Jacobi symbol can be positive for a nonresidue, so not all nonresidues are possible, and the number of trials on average could be larger than the prime p case. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>the modulus for which to generate a nonresidue. Should be prime. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a quadratic nonresidue mod p </dd></dl>

</div>
</div>
<a id="a3971aec9be84e37469c2953fe0a7bbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3971aec9be84e37469c2953fe0a7bbc0">&#9670;&nbsp;</a></span>sqrt_shanks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t sqrt_shanks </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the square root of a quadratic residue mod a prime. </p>
<p>If n is not a residue or p is not a prime, this function is not guaranteed to terminate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>a quadratic residue mod p </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a prime </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>r so that r^2 = n mod p </dd></dl>

</div>
</div>
<a id="a4871f3a8602cb31a0963dbeeacb86faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4871f3a8602cb31a0963dbeeacb86faf">&#9670;&nbsp;</a></span>sqrt_cipolla()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t sqrt_cipolla </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the square root of a quadratic residue mod a prime. </p>
<p>If n is not a residue or p is not a prime, the value returned may not be useful but the function will terminate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>a quadratic residue mod p </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a prime </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>r so that r^2 = n mod p </dd></dl>

</div>
</div>
<a id="a90556023960bf8187aaafd25f9aa536d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90556023960bf8187aaafd25f9aa536d">&#9670;&nbsp;</a></span>sqrt_mod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t sqrt_mod </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the square root of a quadratic residue mod a prime. </p>
<p>If n is not a residue or p is not a prime, this function is not guaranteed to terminate. If your use case does not guarantee this, call <a class="el" href="factorization_8h.html#a8507a5fce6ddc90582e7072c9830bd24">is_prime_dmr</a> and <a class="el" href="factorization_8h.html#ae9e0aa84d98c5b9a6e6dfe7a84e90a9a">jacobi</a> beforehand. uses shortcuts for primes that are 3, 5, or 7 mod 8, otherwise uses Shanks's algorithm unless p-1 is divisible by a sufficiently high power of 2 so Cipolla's algorithm will be faster, in which case it is used. Only the Shank's branch can fail to terminate, although other branches give useless results if the preconditions are not met. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>a quadratic residue mod p </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a prime </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>r so that r^2 = n mod p </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
