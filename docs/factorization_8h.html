<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Number Theory Utils: include/nut/factorization.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_awesome_sidebar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="/Number-Theory-Utils/index.html">Number Theory Utils</a><span id="projectnumber">&#160;0.2.0</span>
   </div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('factorization_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">factorization.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>hacatu </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.2.0 </dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Functions for dealing with factorization and modular arithmetic on 64 bit integers (not suitable for large integers which may overflow, around 2^31. a bignum-enabled version may be created to handle this) </p>

<p class="definition">Definition in file <a class="el" href="factorization_8h_source.html">factorization.h</a>.</p>
</div>
<p><a href="factorization_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfactors__t.html">factors_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A prime factorization.  <a href="structfactors__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfactor__conf__t.html">factor_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration/tuning for heuristic factorization.  <a href="structfactor__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a28f056a31fe5cbaa059a0740d3339e5b"><td class="memItemLeft" align="right" valign="top"><a id="a28f056a31fe5cbaa059a0740d3339e5b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a28f056a31fe5cbaa059a0740d3339e5b">MAX_PRIMES_32</a>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a28f056a31fe5cbaa059a0740d3339e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most distinct prime divisors a uint32_t can have. <br /></td></tr>
<tr class="separator:a28f056a31fe5cbaa059a0740d3339e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f29234154854a63ff0f50e0259c1cd6"><td class="memItemLeft" align="right" valign="top"><a id="a9f29234154854a63ff0f50e0259c1cd6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a9f29234154854a63ff0f50e0259c1cd6">MAX_PRIMES_64</a>&#160;&#160;&#160;15</td></tr>
<tr class="memdesc:a9f29234154854a63ff0f50e0259c1cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most distinct prime divisors a uint64_t can have. <br /></td></tr>
<tr class="separator:a9f29234154854a63ff0f50e0259c1cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11bbeaacb214223d9c679b307348a6b"><td class="memItemLeft" align="right" valign="top"><a id="ac11bbeaacb214223d9c679b307348a6b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#ac11bbeaacb214223d9c679b307348a6b">MAX_PRIMES_128</a>&#160;&#160;&#160;25</td></tr>
<tr class="memdesc:ac11bbeaacb214223d9c679b307348a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most distinct prime divisors a uint128_t can have. <br /></td></tr>
<tr class="separator:ac11bbeaacb214223d9c679b307348a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9641e499ad990b5eb66cda6400f55e5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a9641e499ad990b5eb66cda6400f55e5b">DIVS_BEFORE_PRIME_CHECK</a>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a9641e499ad990b5eb66cda6400f55e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently unused.  <a href="factorization_8h.html#a9641e499ad990b5eb66cda6400f55e5b">More...</a><br /></td></tr>
<tr class="separator:a9641e499ad990b5eb66cda6400f55e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a487385b324e0d39124f186234ec9aec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a487385b324e0d39124f186234ec9aec3">init_factors_t_w</a> (uint64_t max_primes)</td></tr>
<tr class="memdesc:a487385b324e0d39124f186234ec9aec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a factors structure that can hold a given number of distinct primes.  <a href="factorization_8h.html#a487385b324e0d39124f186234ec9aec3">More...</a><br /></td></tr>
<tr class="separator:a487385b324e0d39124f186234ec9aec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74c0b074b6830e1ad08f51d1c166583"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#ad74c0b074b6830e1ad08f51d1c166583">init_factors_t_ub</a> (uint64_t n, uint64_t num_primes, const uint64_t *primes)</td></tr>
<tr class="memdesc:ad74c0b074b6830e1ad08f51d1c166583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a factors structure that can hold all factors of n, even if it has as many prime factors as possible.  <a href="factorization_8h.html#ad74c0b074b6830e1ad08f51d1c166583">More...</a><br /></td></tr>
<tr class="separator:ad74c0b074b6830e1ad08f51d1c166583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35507cdbb4f4954481459716648c74cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a35507cdbb4f4954481459716648c74cd">copy_factors_t</a> (const <a class="el" href="structfactors__t.html">factors_t</a> *factors)</td></tr>
<tr class="memdesc:a35507cdbb4f4954481459716648c74cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a copy of a factors struct, but with only enough memory to store its current factors and not its max capacity if higher.  <a href="factorization_8h.html#a35507cdbb4f4954481459716648c74cd">More...</a><br /></td></tr>
<tr class="separator:a35507cdbb4f4954481459716648c74cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dc8ed9447f6b0039ce7a002608b57b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a78dc8ed9447f6b0039ce7a002608b57b">factors_product</a> (const <a class="el" href="structfactors__t.html">factors_t</a> *factors) __attribute__((pure))</td></tr>
<tr class="memdesc:a78dc8ed9447f6b0039ce7a002608b57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a factorization into a number.  <a href="factorization_8h.html#a78dc8ed9447f6b0039ce7a002608b57b">More...</a><br /></td></tr>
<tr class="separator:a78dc8ed9447f6b0039ce7a002608b57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4659632fb46916482ba089ea5eb215b6"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a4659632fb46916482ba089ea5eb215b6">divisor_count</a> (const <a class="el" href="structfactors__t.html">factors_t</a> *factors) __attribute__((pure))</td></tr>
<tr class="memdesc:a4659632fb46916482ba089ea5eb215b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the number of divisors of a number given its prime factorization, including itself and 1.  <a href="factorization_8h.html#a4659632fb46916482ba089ea5eb215b6">More...</a><br /></td></tr>
<tr class="separator:a4659632fb46916482ba089ea5eb215b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22edae250ec16a4ae6936969335029e8"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a22edae250ec16a4ae6936969335029e8">divisor_sum</a> (const <a class="el" href="structfactors__t.html">factors_t</a> *factors) __attribute__((pure))</td></tr>
<tr class="memdesc:a22edae250ec16a4ae6936969335029e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the sum of divisors of a number given its prime factorization, including itself and 1.  <a href="factorization_8h.html#a22edae250ec16a4ae6936969335029e8">More...</a><br /></td></tr>
<tr class="separator:a22edae250ec16a4ae6936969335029e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdf3ad88357fd8c9995bb110cb6d808"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a0cdf3ad88357fd8c9995bb110cb6d808">divisor_power_sum</a> (const <a class="el" href="structfactors__t.html">factors_t</a> *factors, uint64_t power) __attribute__((pure))</td></tr>
<tr class="memdesc:a0cdf3ad88357fd8c9995bb110cb6d808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the sum of powers of divisors of a number given its prime factorization, including itself and 1.  <a href="factorization_8h.html#a0cdf3ad88357fd8c9995bb110cb6d808">More...</a><br /></td></tr>
<tr class="separator:a0cdf3ad88357fd8c9995bb110cb6d808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f2dc0bbd50747b33174705ec7d053d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a92f2dc0bbd50747b33174705ec7d053d">factors_power</a> (<a class="el" href="structfactors__t.html">factors_t</a> *factors, uint64_t power)</td></tr>
<tr class="memdesc:a92f2dc0bbd50747b33174705ec7d053d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise a factorization to a power, ie multiply all exponents by a constant.  <a href="factorization_8h.html#a92f2dc0bbd50747b33174705ec7d053d">More...</a><br /></td></tr>
<tr class="separator:a92f2dc0bbd50747b33174705ec7d053d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21b39861e3bd04966862277f45dbb8e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#af21b39861e3bd04966862277f45dbb8e">euler_phi</a> (const <a class="el" href="structfactors__t.html">factors_t</a> *factors) __attribute__((pure))</td></tr>
<tr class="memdesc:af21b39861e3bd04966862277f45dbb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Euler's Phi function, the number of coprime numbers less than n.  <a href="factorization_8h.html#af21b39861e3bd04966862277f45dbb8e">More...</a><br /></td></tr>
<tr class="separator:af21b39861e3bd04966862277f45dbb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a68da474286694c8abd6c37e26425f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a25a68da474286694c8abd6c37e26425f">carmichael_lambda</a> (const <a class="el" href="structfactors__t.html">factors_t</a> *factors) __attribute__((pure))</td></tr>
<tr class="memdesc:a25a68da474286694c8abd6c37e26425f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Carmichael's Lambda function, the smallest exponent m so a^m = 1 for all 0 &lt; a &lt; n.  <a href="factorization_8h.html#a25a68da474286694c8abd6c37e26425f">More...</a><br /></td></tr>
<tr class="separator:a25a68da474286694c8abd6c37e26425f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5aa9870e338e6294a78fcf2b4b4d319"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#aa5aa9870e338e6294a78fcf2b4b4d319">factors_fprint</a> (FILE *file, const <a class="el" href="structfactors__t.html">factors_t</a> *factors)</td></tr>
<tr class="memdesc:aa5aa9870e338e6294a78fcf2b4b4d319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a factorization of a number.  <a href="factorization_8h.html#aa5aa9870e338e6294a78fcf2b4b4d319">More...</a><br /></td></tr>
<tr class="separator:aa5aa9870e338e6294a78fcf2b4b4d319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb850a90841e804deafef1b99a7685e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#acb850a90841e804deafef1b99a7685e3">factors_append</a> (<a class="el" href="structfactors__t.html">factors_t</a> *factors, uint64_t m, uint64_t k)</td></tr>
<tr class="memdesc:acb850a90841e804deafef1b99a7685e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a power of some prime to an existing factorization struct.  <a href="factorization_8h.html#acb850a90841e804deafef1b99a7685e3">More...</a><br /></td></tr>
<tr class="separator:acb850a90841e804deafef1b99a7685e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65217fd7242cfdb6692af53fa2d3783a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a65217fd7242cfdb6692af53fa2d3783a">factors_combine</a> (<a class="el" href="structfactors__t.html">factors_t</a> *factors, const <a class="el" href="structfactors__t.html">factors_t</a> *factors2, uint64_t k)</td></tr>
<tr class="memdesc:a65217fd7242cfdb6692af53fa2d3783a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all prime/power pairs in one factorization to another.  <a href="factorization_8h.html#a65217fd7242cfdb6692af53fa2d3783a">More...</a><br /></td></tr>
<tr class="separator:a65217fd7242cfdb6692af53fa2d3783a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8507a5fce6ddc90582e7072c9830bd24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a8507a5fce6ddc90582e7072c9830bd24">is_prime_dmr</a> (uint64_t n) __attribute__((const))</td></tr>
<tr class="memdesc:a8507a5fce6ddc90582e7072c9830bd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if n is prime using a deterministic Miller-Rabin test.  <a href="factorization_8h.html#a8507a5fce6ddc90582e7072c9830bd24">More...</a><br /></td></tr>
<tr class="separator:a8507a5fce6ddc90582e7072c9830bd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9199063b7563cfe3731689da1ff48b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a3f9199063b7563cfe3731689da1ff48b">factor_trial_div</a> (uint64_t n, uint64_t num_primes, const uint64_t primes[static num_primes], <a class="el" href="structfactors__t.html">factors_t</a> *factors) __attribute__((pure))</td></tr>
<tr class="memdesc:a3f9199063b7563cfe3731689da1ff48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor out all powers of a given array of primes.  <a href="factorization_8h.html#a3f9199063b7563cfe3731689da1ff48b">More...</a><br /></td></tr>
<tr class="separator:a3f9199063b7563cfe3731689da1ff48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0429f4ae877e6068f0cb728ded0576"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#afc0429f4ae877e6068f0cb728ded0576">factor_heuristic</a> (uint64_t n, uint64_t num_primes, const uint64_t primes[static num_primes], const <a class="el" href="structfactor__conf__t.html">factor_conf_t</a> *conf, <a class="el" href="structfactors__t.html">factors_t</a> *factors)</td></tr>
<tr class="memdesc:afc0429f4ae877e6068f0cb728ded0576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor a number using a variety of approaches based on its size.  <a href="factorization_8h.html#afc0429f4ae877e6068f0cb728ded0576">More...</a><br /></td></tr>
<tr class="separator:afc0429f4ae877e6068f0cb728ded0576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af372c8a01b9d6b52314e0291e8082775"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#af372c8a01b9d6b52314e0291e8082775">factor1_pollard_rho</a> (uint64_t n, uint64_t x) __attribute__((const))</td></tr>
<tr class="memdesc:af372c8a01b9d6b52314e0291e8082775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a factor of a number using Pollard's Rho algorithm with Floyd cycle finding.  <a href="factorization_8h.html#af372c8a01b9d6b52314e0291e8082775">More...</a><br /></td></tr>
<tr class="separator:af372c8a01b9d6b52314e0291e8082775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c27a9bb8e04dc1ee7762d80609bd397"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a2c27a9bb8e04dc1ee7762d80609bd397">factor1_pollard_rho_brent</a> (uint64_t n, uint64_t x, uint64_t m) __attribute__((const))</td></tr>
<tr class="memdesc:a2c27a9bb8e04dc1ee7762d80609bd397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a factor of a number using Pollard's Rho algorithm with Brent cycle finding and gcd coalescing.  <a href="factorization_8h.html#a2c27a9bb8e04dc1ee7762d80609bd397">More...</a><br /></td></tr>
<tr class="separator:a2c27a9bb8e04dc1ee7762d80609bd397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579ecfd7ea5828099ccca38d8544c5a9"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a579ecfd7ea5828099ccca38d8544c5a9">factor1_lenstra</a> (int64_t n, int64_t x, int64_t y, int64_t a, int64_t B) __attribute__((const))</td></tr>
<tr class="memdesc:a579ecfd7ea5828099ccca38d8544c5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a factor of a number using Lenstra ecf.  <a href="factorization_8h.html#a579ecfd7ea5828099ccca38d8544c5a9">More...</a><br /></td></tr>
<tr class="separator:a579ecfd7ea5828099ccca38d8544c5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060384c42a77493f90148d011ad42a29"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a060384c42a77493f90148d011ad42a29">factor1_lenstra_montgomery</a> (int64_t n, int64_t x, int64_t y, int64_t a, int64_t B) __attribute__((const))</td></tr>
<tr class="memdesc:a060384c42a77493f90148d011ad42a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="factorization_8h.html#a579ecfd7ea5828099ccca38d8544c5a9">factor1_lenstra</a> but using a projective Montgomery curve and Montgomery ladder.  <a href="factorization_8h.html#a060384c42a77493f90148d011ad42a29">More...</a><br /></td></tr>
<tr class="separator:a060384c42a77493f90148d011ad42a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a833e5eb4b48e7f9aff8b1202ef5c86f9"><td class="memItemLeft" align="right" valign="top">const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="factorization_8h.html#a833e5eb4b48e7f9aff8b1202ef5c86f9">primes_2_5</a> [2]</td></tr>
<tr class="memdesc:a833e5eb4b48e7f9aff8b1202ef5c86f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array containing the primes 2 and 5.  <a href="factorization_8h.html#a833e5eb4b48e7f9aff8b1202ef5c86f9">More...</a><br /></td></tr>
<tr class="separator:a833e5eb4b48e7f9aff8b1202ef5c86f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9641e499ad990b5eb66cda6400f55e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9641e499ad990b5eb66cda6400f55e5b">&#9670;&nbsp;</a></span>DIVS_BEFORE_PRIME_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DIVS_BEFORE_PRIME_CHECK&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Currently unused. </p>
<p>How many trial divisions to do before performing randomized prime tests (Miller Rabin). For 64 bit numbers, we can easily make Miller Rabin deterministic in 7 tests, whereas up to 40 would be used to check a large number. BSW and ECPP are also important for checking large primes, because BSW and Miller Rabin together can provide a higher primality confidence faster, whereas ECPP is much slower but provides an easily verifiable proof. </p>

<p class="definition">Definition at line <a class="el" href="factorization_8h_source.html#l00034">34</a> of file <a class="el" href="factorization_8h_source.html">factorization.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a487385b324e0d39124f186234ec9aec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487385b324e0d39124f186234ec9aec3">&#9670;&nbsp;</a></span>init_factors_t_w()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfactors__t.html">factors_t</a>* init_factors_t_w </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_primes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a factors structure that can hold a given number of distinct primes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_primes</td><td>the number of distinct primes that should be storable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to factors structure that can hold max_primes. pointer needs to be free'd </dd></dl>

</div>
</div>
<a id="ad74c0b074b6830e1ad08f51d1c166583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74c0b074b6830e1ad08f51d1c166583">&#9670;&nbsp;</a></span>init_factors_t_ub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfactors__t.html">factors_t</a>* init_factors_t_ub </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_primes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>primes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a factors structure that can hold all factors of n, even if it has as many prime factors as possible. </p>
<p>E.g. 210=2*3*5*7 and 2310=2*3*5*7*11 so 210-2309 can have up to 4 distinct prime factors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number up to which the distinct prime factors of any number should be storable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_primes</td><td>number of primes in array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primes</td><td>array of primes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to factors structure that can hold enough distinct primes to factor any number up through n. pointer needs to be free'd </dd></dl>

</div>
</div>
<a id="a35507cdbb4f4954481459716648c74cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35507cdbb4f4954481459716648c74cd">&#9670;&nbsp;</a></span>copy_factors_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfactors__t.html">factors_t</a>* copy_factors_t </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a copy of a factors struct, but with only enough memory to store its current factors and not its max capacity if higher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>the struct to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the input or NULL on allocation failure </dd></dl>

</div>
</div>
<a id="a78dc8ed9447f6b0039ce7a002608b57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78dc8ed9447f6b0039ce7a002608b57b">&#9670;&nbsp;</a></span>factors_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t factors_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a factorization into a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factors struct, as obtained from <a class="el" href="factorization_8h.html#a3f9199063b7563cfe3731689da1ff48b">factor_trial_div</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>product of prime powers described by factors </dd></dl>

</div>
</div>
<a id="a4659632fb46916482ba089ea5eb215b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4659632fb46916482ba089ea5eb215b6">&#9670;&nbsp;</a></span>divisor_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t divisor_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the number of divisors of a number given its prime factorization, including itself and 1. </p>
<p>Works by multiplying power + 1 for all prime factors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factors struct, as obtained from <a class="el" href="factorization_8h.html#a3f9199063b7563cfe3731689da1ff48b">factor_trial_div</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of divisors </dd></dl>

</div>
</div>
<a id="a22edae250ec16a4ae6936969335029e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22edae250ec16a4ae6936969335029e8">&#9670;&nbsp;</a></span>divisor_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t divisor_sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the sum of divisors of a number given its prime factorization, including itself and 1. </p>
<p>Works by multiplying (prime**(power+1)-1)/(prime-1) for all prime factors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factors struct, as obtained from <a class="el" href="factorization_8h.html#a3f9199063b7563cfe3731689da1ff48b">factor_trial_div</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of divisors </dd></dl>

</div>
</div>
<a id="a0cdf3ad88357fd8c9995bb110cb6d808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdf3ad88357fd8c9995bb110cb6d808">&#9670;&nbsp;</a></span>divisor_power_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t divisor_power_sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the sum of powers of divisors of a number given its prime factorization, including itself and 1. </p>
<p>Note this is NOT the same as the sum of divisors of a number. Works by multiplying (prime**((power+1)*e)-1)/(prime**e-1) for all prime factors, where power is the power of each prime and e is the power of divisors to sum </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factors struct, as obtained from <a class="el" href="factorization_8h.html#a3f9199063b7563cfe3731689da1ff48b">factor_trial_div</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">power</td><td>power of divisors to sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of divisor powers </dd></dl>

</div>
</div>
<a id="a92f2dc0bbd50747b33174705ec7d053d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f2dc0bbd50747b33174705ec7d053d">&#9670;&nbsp;</a></span>factors_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void factors_power </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raise a factorization to a power, ie multiply all exponents by a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factors</td><td>factorization to raise to a power </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">power</td><td>power to raise the factorization to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af21b39861e3bd04966862277f45dbb8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21b39861e3bd04966862277f45dbb8e">&#9670;&nbsp;</a></span>euler_phi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t euler_phi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find Euler's Phi function, the number of coprime numbers less than n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>the factorization of n for which to compute phi </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>phi(n) </dd></dl>

</div>
</div>
<a id="a25a68da474286694c8abd6c37e26425f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a68da474286694c8abd6c37e26425f">&#9670;&nbsp;</a></span>carmichael_lambda()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t carmichael_lambda </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find Carmichael's Lambda function, the smallest exponent m so a^m = 1 for all 0 &lt; a &lt; n. </p>
<p>Always divides phi(n). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>the factorization of n for which to compute the carmichael function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lambda(n) </dd></dl>

</div>
</div>
<a id="aa5aa9870e338e6294a78fcf2b4b4d319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5aa9870e338e6294a78fcf2b4b4d319">&#9670;&nbsp;</a></span>factors_fprint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int factors_fprint </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a factorization of a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td>pointer to file to print to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>pointer to factorization struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of characters printed </dd></dl>

</div>
</div>
<a id="acb850a90841e804deafef1b99a7685e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb850a90841e804deafef1b99a7685e3">&#9670;&nbsp;</a></span>factors_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void factors_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a power of some prime to an existing factorization struct. </p>
<p>If the input factorization is sorted before this function is called, it will still be sorted after, and if the factor to be added is already present its power will be increased rather than creating a separate entry. The factorization struct must have enough space if an additional entry is needed. Composite numbers or zero powers should not be supplied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factors</td><td>pointer to factorization struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>prime </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>power </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65217fd7242cfdb6692af53fa2d3783a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65217fd7242cfdb6692af53fa2d3783a">&#9670;&nbsp;</a></span>factors_combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void factors_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add all prime/power pairs in one factorization to another. </p>
<p>If both inputs are sorted, the result will be sorted and no dupliate entries will be created. Acts as if <a class="el" href="factorization_8h.html#acb850a90841e804deafef1b99a7685e3">factors_append</a> were called repeatedly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">factors</td><td>pointer to factorization struct which should be extended </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors2</td><td>pointer to factorization struct whose entries will be added to the other struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>power to multiply entries of factors2 by, for if some composite number m was discovered where m^k divides n and we have factored m </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8507a5fce6ddc90582e7072c9830bd24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8507a5fce6ddc90582e7072c9830bd24">&#9670;&nbsp;</a></span>is_prime_dmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_prime_dmr </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if n is prime using a deterministic Miller-Rabin test. </p>
<p>7 partictular bases are used so that no composite number will falsely be reported as prime for the entire 64-bit range </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to check for primality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if n is prime, false otherwise </dd></dl>

</div>
</div>
<a id="a3f9199063b7563cfe3731689da1ff48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9199063b7563cfe3731689da1ff48b">&#9670;&nbsp;</a></span>factor_trial_div()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t factor_trial_div </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_primes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>primes</em>[static num_primes], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factor out all powers of a given array of primes. </p>
<p>Primesieve is a good general source for primes, but the api for this function is designed to allow giving a specialized list of primes like only primes equal to 1 mod 6 if it is known that all factors have some form, or to provide an empty list when this function is used in a more generic context like <a class="el" href="factorization_8h.html#afc0429f4ae877e6068f0cb728ded0576">factor_heuristic</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_primes</td><td>the number of primes in the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primes</td><td>the array of primes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">factors</td><td>pointer to struct where factors will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n with all factors found and stored in factors divided out. Thus if n factors completely over the given primes, 1 is returned. </dd></dl>

</div>
</div>
<a id="afc0429f4ae877e6068f0cb728ded0576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0429f4ae877e6068f0cb728ded0576">&#9670;&nbsp;</a></span>factor_heuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t factor_heuristic </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_primes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>primes</em>[static num_primes], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfactor__conf__t.html">factor_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfactors__t.html">factors_t</a> *&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factor a number using a variety of approaches based on its size. </p>
<p>If conf-&gt;pollard_max is greater than 3, the primes array should include at least 2 and 5 (<a class="el" href="factorization_8h.html#a833e5eb4b48e7f9aff8b1202ef5c86f9">primes_2_5</a> could be used) to avoid an infinite loop since <a class="el" href="factorization_8h.html#af372c8a01b9d6b52314e0291e8082775">factor1_pollard_rho</a> can't factor 4 or 25. Currently a configuration struct must be passed. Kraitcheck methods (quadratic sieve and number field sieve) are not implemented because they are useless on 64 bit integers. Parameters to Pollard-Rho-Brent with gcd aggregation and Lenstra ecf are not tuned by this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number to factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_primes</td><td>the number of primes in the array to try trial division on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primes</td><td>array of primes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">conf</td><td>limits for different algorithms </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">factors</td><td>output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n with all factors found and stored in factors divided out. Thus if n factors completely, 1 is returned. </dd></dl>

</div>
</div>
<a id="af372c8a01b9d6b52314e0291e8082775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af372c8a01b9d6b52314e0291e8082775">&#9670;&nbsp;</a></span>factor1_pollard_rho()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t factor1_pollard_rho </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find a factor of a number using Pollard's Rho algorithm with Floyd cycle finding. </p>
<p>Note that this will not find factors of 4 or 25 no matter what x is. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>random value mod n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise </dd></dl>

</div>
</div>
<a id="a2c27a9bb8e04dc1ee7762d80609bd397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c27a9bb8e04dc1ee7762d80609bd397">&#9670;&nbsp;</a></span>factor1_pollard_rho_brent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t factor1_pollard_rho_brent </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find a factor of a number using Pollard's Rho algorithm with Brent cycle finding and gcd coalescing. </p>
<p>Note that his will not find factors of 4 or 25 no matter what x is. m does not affect whether x will lead to a factor of n, it just means each iteration will be cheaper but up to 2m extraneous iterations could be performed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>random value mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of iterations per gcd check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise </dd></dl>

</div>
</div>
<a id="a579ecfd7ea5828099ccca38d8544c5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579ecfd7ea5828099ccca38d8544c5a9">&#9670;&nbsp;</a></span>factor1_lenstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t factor1_lenstra </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find a factor of a number using Lenstra ecf. </p>
<p>In particular, an affine wierstrass representation is used internally and scalar multiplication is done using a binary "double and add" algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y,a</td><td>random values mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>number of trials before giving up (we compute kP for k from 2 to B) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise </dd></dl>

</div>
</div>
<a id="a060384c42a77493f90148d011ad42a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060384c42a77493f90148d011ad42a29">&#9670;&nbsp;</a></span>factor1_lenstra_montgomery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t factor1_lenstra_montgomery </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="factorization_8h.html#a579ecfd7ea5828099ccca38d8544c5a9">factor1_lenstra</a> but using a projective Montgomery curve and Montgomery ladder. </p>
<p>Instead of an affine Wierstrass curve and binary multiplication. This is supposed to be faster but seems to be about the same. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number to find a factor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y,a</td><td>random numbers mod n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>number of trials before giving up (we compute kP for k from 2 to B) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nontrivial factor of n if found, 1 or n otherwise </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a833e5eb4b48e7f9aff8b1202ef5c86f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833e5eb4b48e7f9aff8b1202ef5c86f9">&#9670;&nbsp;</a></span>primes_2_5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t primes_2_5[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An array containing the primes 2 and 5. </p>
<p><a class="el" href="factorization_8h.html#af372c8a01b9d6b52314e0291e8082775">factor1_pollard_rho</a> and <a class="el" href="factorization_8h.html#a2c27a9bb8e04dc1ee7762d80609bd397">factor1_pollard_rho_brent</a> can't find factors of 4 or 25 using the default polynomial, so if using <a class="el" href="factorization_8h.html#afc0429f4ae877e6068f0cb728ded0576">factor_heuristic</a> at least these primes should be used for trial division if the configuration allows pollard rho to be called. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_073faa820624379b5730e5b4f5cb1c42.html">nut</a></li><li class="navelem"><a class="el" href="factorization_8h.html">factorization.h</a></li>
    <li class="footer">Generated on Wed Mar 2 2022 03:18:48 for Number Theory Utils by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
